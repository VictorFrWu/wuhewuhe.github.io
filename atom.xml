<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>He WU</title>
  
  <subtitle>stay hungry, stay foolish, never give up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhewuhe.github.io/"/>
  <updated>2020-02-23T19:47:06.408Z</updated>
  <id>https://wuhewuhe.github.io/</id>
  
  <author>
    <name>WU He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>graph</title>
    <link href="https://wuhewuhe.github.io/2020/02/23/graph/"/>
    <id>https://wuhewuhe.github.io/2020/02/23/graph/</id>
    <published>2020-02-23T19:46:50.000Z</published>
    <updated>2020-02-23T19:47:06.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图类算法">图类算法</h3><p>在开始解析这道题之前，我们先对图的结构进行分类，在实际实现过程中，有以下几种基本的方式可以来表示图。</p><ul><li>邻接矩阵：对于较小或者中等规模的图的构造较为适用，因为需要V*V大小的空间。</li><li>邻接表数组, 较为常用，使用一个以顶点为索引的数组，数组每个元素都是和该顶点相邻的顶点列表，这种数组占空间相对于邻接矩阵少了很多，并且能很好的找到某个给定点的所有邻接点</li></ul><p>如下图所示</p><p>pic</p><p>按照图中边的方向将图分成有向图和无向图：<br>1）无向图：图中的边没有方向。<br>2）有向图：图中的边有方向。</p><h4 id="图的遍历">图的遍历</h4><p>介绍两种基础且实用的图遍历算法，广度优先搜索和深度优先搜索。</p><h5 id="深度优先搜索">深度优先搜索</h5><p>这是一种典型的递归算法用来搜索图（遍历所有的顶点）；<br>思想：从图的某个顶点i开始，将顶点i标记为已访问顶点，并将访问顶点i的邻接列表中没有被标记的顶点j，将顶点j标记为已访问，并在访问顶点j的邻接列表中未被标记的顶点k依次深度遍历下去，直到某个点的所有邻接列表中的点都被标记为已访问后，返回上层。重复以上过程直到图中的所有顶点都被标记为已访问。</p><h5 id="广度优先搜索">广度优先搜索</h5><p>前面说过，深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示以及递归调用的性质，但是如果要求最短的路径（给定图G和起始点s寻找给定点v和s间是否存在路径，如果存在，找出最短的路径），那么使用前面的DFS算法并不能解决该问题，所以出现了广度优先搜索BFS来实现这个目的，广度优先搜索也是其他算法的基础。<br>在程序中，搜索一幅图的时候会遇到有很多条边都需要被遍历的情况，我们会选择其中一条并将其他边留到以后再继续搜索，在DFS中使用栈结构，使用LIFO的规则来描述，从有待搜索的通道中选取最晚遇到的那个通道，然而在BFS算法中，我们希望按照与起点的距离来遍历所有的顶点，使用FIFO（队列）来进行搜索，也就是搜索最先遇到的那个通道。<br>BFS: 使用一个队列来保存所有已经被标记过的但是其邻接点还未被检查过的顶点，现将顶点加入队列中，然后重复下面的操作，直至队列为空：<br>1）取队列中的下一个顶点v并标记它<br>2）将与v相邻的所有的未被标记的顶点加入队列中。</p><p>广度优先搜索类似于树的按层遍历</p><h4 id="例子">例子</h4><p>pic</p><p>深度优先遍历结果是： A B E F C D G H I</p><blockquote><p>深度优先遍历尽可能优先往深层次进行搜索</p></blockquote><p>pic</p><p>广度优先遍历结果是： A B C D E F G H I</p><blockquote><p>广度优先遍历按层次优先搜索最近的结点，一层一层往外搜索。</p></blockquote><p>通过以上的描述然后我们来找两道题练习实践一下这两个算法。我选了两个有代表性的题目，分别是leetcode200 island 和 207 course schedule。</p><h3 id="Leetcode-200-Island-题目描述">Leetcode 200 Island 题目描述</h3><p>Given a 2d grid map of '1’s (land) and '0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>Input:<br>11110<br>11010<br>11000<br>00000</p><p>Output: 1<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Example 2:</p><p>Input:<br>11000<br>11000<br>00100<br>00011</p><p>Output: 3</p><h3 id="题目概括">题目概括</h3><p>给了一个二维数组，其中0表示水，1表示陆地，问一共有几个小岛？小岛的意思就是横向和竖向是水，没有陆地</p><h4 id="解题思路">解题思路</h4><p>做法是，我们对每个有“1&quot;的位置进行dfs，把和它四联通的位置全部变成“0”，这样就能把一个点推广到一个岛。</p><p>所以，我们总的进行了dfs的次数，就是总过有多少个岛的数目。</p><p>注意理解dfs函数的意义：已知当前是1，把它周围相邻的所有1全部转成0.</p><h5 id="如何记录遍历过的点">如何记录遍历过的点</h5><p>这里大体上有两个方法，我们可以建一个boolean的二维数组，true代表访问过，false代表未访问。这样比较好想，而且保护了原有的数组，但是需要我们另外开辟空间。本题我们可以将访问过的点，直接设置为水，这样还可以省去不少的判断。</p><h5 id="实现点的移动">实现点的移动</h5><p>这里实现的方法有很多，核心思想就是以原点为中心向上下左右四个位置扩散，所以我是新建了一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final static int[][] dirs &#x3D; &#123; &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此即可让点一次以左上右下的顺序移动</p><h5 id="如何实现递归">如何实现递归</h5><p>dfs可以用迭代的方式用stack实现，但是递归写法更简便容易理解，与树相同，优先考虑递归。我写递归一般就是分为两部，第一步是corner case就是何时return，第二部就是base case 正常情况下的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int[] dir : dirs) &#123;</span><br><span class="line">int x &#x3D; dir[0] + i;</span><br><span class="line">int y &#x3D; dir[1] + j;</span><br><span class="line">dfs(grid, x, y, xrows, yrows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现">具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DFS</span><br><span class="line">final static int[][] dirs &#x3D; &#123; &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (grid &#x3D;&#x3D; null || grid.length &#x3D;&#x3D; 0 || grid[0].length &#x3D;&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">final int xrows &#x3D; grid.length;</span><br><span class="line">final int yrows &#x3D; grid[0].length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; grid.length; i++)</span><br><span class="line">for (int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">dfs(grid, i, j, xrows, yrows);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs(char[][] grid, int i, int j, int xrows, int yrows) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; xrows || j &gt;&#x3D; yrows || grid[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; base case</span><br><span class="line">grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">for (int[] dir : dirs) &#123;</span><br><span class="line">int x &#x3D; dir[0] + i;</span><br><span class="line">int y &#x3D; dir[1] + j;</span><br><span class="line">dfs(grid, x, y, xrows, yrows);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-207-course-schedule-题目描述">Leetcode 207 course schedule 题目描述</h3><h4 id="题目描述：">题目描述：</h4><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0, 1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><h4 id="题目大意">题目大意</h4><p>课程表上有一些课，是必须有修学分的先后顺序的，必须要求在上完某些课的情况下才能上下一门。问是否有方案修完所有的课程？</p><h4 id="解题思路-2">解题思路</h4><p>这个题本质上是一个判断一张图是否为有向无环图（DAG）的题目Directed acyclic graph</p><p>如果一个有向图中从任意点出发都不能回到该点的话，这张图就是一个有向无环图<br>课程就表示图中的点，而前置课程的关系则表示了图中的有向边。需要特别注意的是，完成事件A才能继续完成事件B，这样的关系我们通常表示为<strong>A-&gt;B</strong>；但是在题目中，要先完成课程1才能完成课程0，这个关系被表示为了 <code>[0, 1]</code> ，所以在代码中构造图的信息时，需要留意。</p><h5 id="存储每门课程的先决条件">存储每门课程的先决条件</h5><p>对于这个一一对应的问题，很快我们可以想到用hashmap，key存储课程编号，value存储次课程需要的先决条件。但是hashmap本身已经是高级数据结构，这个题目我们可以采用一维数组就完全够了。对prerequisites遍历一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">pres[prerequisites[i][0]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分层遍历-bfs">分层遍历 bfs</h5><p>一提到分层，level traversal我们就可以想到队列了，先进先出，问题是我们需要先对队列进行初始化，就是把不需要预备课程的科目先加入到队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; pres.length; i++) &#123;</span><br><span class="line">if (pres[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何判断是否完成所有课程">如何判断是否完成所有课程</h5><p>这里就是一个循序渐尖的思想，首先我们先从队列中取出一个不需要预备课程的科目，记录下他的id，然后遍历所有的条件，若存在需要改课程的科目，则对其需要的预备课程数目-1，若结果为0，则说明已达标，可继续学习，否则继续遍历。看看最后能学习的课程数量与总课程数量是否相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 查看哪一个课程的必要条件是此刻课程</span><br><span class="line">if (prerequisites[i][1] &#x3D;&#x3D; top) &#123;</span><br><span class="line">pres[prerequisites[i][0]]--;</span><br><span class="line">if (pres[prerequisites[i][0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">numNoPre++;</span><br><span class="line">queue.add(prerequisites[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现-2">具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; method1 BFS</span><br><span class="line">public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (prerequisites &#x3D;&#x3D; null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (numCourses &lt; 0 || prerequisites.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录每个course的prerequisites的数量</span><br><span class="line">int[] pres &#x3D; new int[numCourses];</span><br><span class="line">int len &#x3D; prerequisites.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">pres[prerequisites[i][0]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; record the direct course by queue</span><br><span class="line">Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; pres.length; i++) &#123;</span><br><span class="line">if (pres[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 取出队列的course，判断</span><br><span class="line">int numNoPre &#x3D; queue.size();</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">int top &#x3D; queue.poll();</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 查看哪一个课程的必要条件是此刻课程</span><br><span class="line">if (prerequisites[i][1] &#x3D;&#x3D; top) &#123;</span><br><span class="line">pres[prerequisites[i][0]]--;</span><br><span class="line">if (pres[prerequisites[i][0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">numNoPre++;</span><br><span class="line">queue.add(prerequisites[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断可完成课程书是否等于课程总数</span><br><span class="line">return numNoPre &#x3D;&#x3D; numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>树和图的题目，因为不是顺向思维，我天资愚钝，一直是我的弱项，所以最近在花时间读书和做题提高一下理解。可以说树和图实际上想通的，因为树本身就是一个有方向无环图。所以树的遍历算法和思想也可以应用到图上，之后会写一下深度优先遍历和树遍历inroder，preorder，postorder区别和联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;图类算法&quot;&gt;图类算法&lt;/h3&gt;
&lt;p&gt;在开始解析这道题之前，我们先对图的结构进行分类，在实际实现过程中，有以下几种基本的方式可以来表示图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接矩阵：对于较小或者中等规模的图的构造较为适用，因为需要V*V大小的空间。&lt;/li&gt;
&lt;li&gt;邻
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tomcat刨析</title>
    <link href="https://wuhewuhe.github.io/2020/02/17/tomcat/"/>
    <id>https://wuhewuhe.github.io/2020/02/17/tomcat/</id>
    <published>2020-02-17T22:19:25.000Z</published>
    <updated>2020-02-17T22:25:57.828Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat:</p><ul><li>1 modify tomcat port</li></ul><ol><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; </span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot; </span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>how many method to connect tomcats?</li></ul><p>bio blocking i/o 同步阻塞</p><p>nio <strong>同步阻塞或同步非阻塞IO</strong></p><p>aio(nio.2): <strong>JDK7开始支持，异步非阻塞IO</strong></p><p>apr(apache portable runtime): Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 <strong>提高Tomcat对静态文件的处理性能</strong></p><h2 id="Tomcat有几种部署方式">Tomcat有几种部署方式</h2><ol><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置``节点，设置相关的属性即可</li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ol><h2 id="Tomcat有几种部署方式-2">Tomcat有几种部署方式</h2><ol><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置``节点，设置相关的属性即可</li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ol><h2 id="部署方式第二点：">部署方式第二点：</h2><ul><li>在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-4bf007b65aa9ed8d5cb9508ee064674e_hd.jpg" alt="img"></p><ul><li>找到Tomcat目录下/conf/server.xml文件</li></ul><p><img src="https://pic3.zhimg.com/80/v2-44643fbf206dacfee7debbfdb24ce08a_hd.jpg" alt="img"></p><ul><li>在server.xml中的节点下添加如下代码。<strong>path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;web1&quot; docBase&#x3D;&quot;D:\web1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-660c2e9f1bf3f36736234a7e139e2543_hd.jpg" alt="img"></p><ul><li>访问配置好的web站点</li></ul><p><img src="https://pic3.zhimg.com/80/v2-b2a5a2a2af98b4057c818cc8b4ee711a_hd.jpg" alt="img"></p><h2 id="部署方式第三点：">部署方式第三点：</h2><ul><li>进入到conf\Catalina\localhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字。</strong></li></ul><p><img src="https://pic3.zhimg.com/80/v2-39eeec1d1d3a5109f6b746f62b357a12_hd.jpg" alt="img"></p><ul><li>xml文件的代码如下，<strong>docBase是你web站点的绝对路径</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;Context </span><br><span class="line">    docBase&#x3D;&quot;D:\web1&quot; </span><br><span class="line">    reloadable&#x3D;&quot;true&quot;&gt; </span><br><span class="line">&lt;&#x2F;Context&gt;</span><br></pre></td></tr></table></figure><ul><li>访问web站点下的html资源</li></ul><p><img src="https://pic1.zhimg.com/80/v2-31ff7b7871c2354b783043371075e07c_hd.jpg" alt="img"></p><h2 id="Servlet面试题">Servlet面试题</h2><h2 id="Servlet生命周期">Servlet生命周期</h2><blockquote><p>Servlet生命周期?</p></blockquote><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。</strong></li></ul><h2 id="get方式和post方式有何区别">get方式和post方式有何区别</h2><ul><li><p>GET方式一般用来获取数据</p></li><li><p>POST方式一般用来提交数据</p></li><li><ul><li>原因:</li></ul><ul><li><ul><li>首先是因为GET方式携带的数据量比较小，无法带过去很大的数量</li><li>POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决)</li><li>GET方式比POST方式要快</li></ul></li></ul></li></ul><h2 id="Servlet相关-API">Servlet相关 API</h2><blockquote><p>doGet与doPost方法的两个参数是什么</p></blockquote><ol><li>HttpServletRequest：封装了与请求相关的信息</li><li>HttpServletResponse：封装了与响应相关的信息</li></ol><blockquote><p>获取页面的元素的值有几种方式，分别说一下</p></blockquote><ol><li>request.getParameter() 返回客户端的请求参数的值</li><li>request.getParameterNames() 返回所有可用属性名的枚举</li><li>request.getParameterValues() 返回包含参数的所有值的数组</li></ol><blockquote><p>request.getAttribute()和request.getParameter()区别</p></blockquote><p>用途上:</p><ul><li>request.getAttribute()， <strong>一般用于获取request域对象的数据</strong>(在跳转之前把数据使用setAttribute来放到request对象上)</li><li>request.getParameter()， <strong>一般用于获取客户端提交的参数</strong></li></ul><p>存储数据上:</p><ul><li>request.getAttribute()可以获取Objcet对象</li><li>request.getParameter()只能获取字符串(这也是为什么它一般用于获取客户端提交的参数)</li></ul><h2 id="forward和redirect的区别">forward和redirect的区别</h2><blockquote><p>forward和redirect的区别</p></blockquote><p>forward is server</p><p>redirect is navigator</p><h2 id="tomcat容器是如何创建servlet类实例？用到了什么原理？">tomcat容器是如何创建servlet类实例？用到了什么原理？</h2><blockquote><p>tomcat容器是如何创建servlet类实例？用到了什么原理</p></blockquote><ol><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 <strong>xml文件进行解析，并读取servlet注册信息</strong>。然后，将每个应用中注册的servlet类都进行加载，并通过 <strong>反射的方式实例化</strong>。（有时候也是在第一次请求时实例化）</li><li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ol><h2 id="Servlet安全性问题">Servlet安全性问题</h2><p>由于Servlet是单例的，当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。</p><p>原则：</p><ol><li><p>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></p></li><li><p>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</p><h3 id="Tomcat顶层架构小结：">Tomcat顶层架构小结：</h3></li></ol><p>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</p><p>（2） Server掌管着整个Tomcat的生死大权；</p><p>（4）Service 是对外提供服务的；</p><p>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；</p><p>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p><h3 id="connector-and-container">connector and container</h3><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议</p><h3 id="Connector架构分析">Connector架构分析</h3><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>我们可以把Connector分为四个方面进行理解：</p><p>（1）Connector如何接受请求的？</p><p>（2）如何将请求封装成Request和Response的？</p><p>（3）封装完之后的Request和Response如何交给Container进行处理的？</p><p>（4）Container处理完之后如何交给Connector并返回给客户端的？</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/03/java6-1553178913.png" alt="Tomcat相关面试题，看这篇就够了！"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><p>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理</p><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p><p>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p><h3 id="Container架构分析">Container架构分析</h3><h3 id></h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/03/java1-1553178914.png" alt="Tomcat相关面试题，看这篇就够了！"></p><p>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p><p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p><p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</p><p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tomcat:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 modify tomcat port&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;找到Tomcat目录下的conf文件夹&lt;/li&gt;
&lt;li&gt;进入conf文件夹里面找到server.xml文件&lt;/li&gt;
&lt;li&gt;打开server.xm
      
    
    </summary>
    
    
      <category term="Webservice" scheme="https://wuhewuhe.github.io/categories/Webservice/"/>
    
    
      <category term="tomcat" scheme="https://wuhewuhe.github.io/tags/tomcat/"/>
    
      <category term="connector" scheme="https://wuhewuhe.github.io/tags/connector/"/>
    
      <category term="container" scheme="https://wuhewuhe.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>Java中BIO, NIO, AIO的理解</title>
    <link href="https://wuhewuhe.github.io/2020/02/17/bionioaio/"/>
    <id>https://wuhewuhe.github.io/2020/02/17/bionioaio/</id>
    <published>2020-02-17T22:18:32.000Z</published>
    <updated>2020-02-17T22:28:05.745Z</updated>
    
    <content type="html"><![CDATA[<p>在高能的IO体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下：</p><p>1 什么是同步？<br>2 什么是异步？<br>3 什么是阻塞？<br>4 什么是非阻塞？<br>5 什么是同步阻塞？<br>6 什么是同步非阻塞？<br>7 什么是异步阻塞？<br>8 什么是异步非阻塞？</p><p>先来举个实例生活中的例子：</p><p>如果你想吃一份宫保鸡丁盖饭：</p><p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！</p><p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！</p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。</p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><p>在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。</p><p>1, 同步和异步是针对应用程序和内核的交互而言的。</p><p>2, 阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p><p>由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。</p><ol><li>同步：指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。</li><li>异步：异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）</li><li>阻塞：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读, 或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）</li><li>非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。</li></ol><p>一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。</p><p>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。<br>阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p><p>同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br>所以, IO操作可以分为3类：同步阻塞（即早期的BIO操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。</p><p>同步阻塞(BIO)：<br>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。<br>同步非阻塞(NIO)：<br>在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。<br>异步非阻塞(AIO)：</p><p>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>同步阻塞IO（JAVA BIO）：<br>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>同步非阻塞IO(Java NIO)：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。</p><p>异步阻塞IO（Java NIO）：<br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！</p><p>（Java AIO(NIO.2)）异步非阻塞IO:<br>在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。</p><p>BIO、NIO、AIO适用场景分析:</p><pre><code>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在高能的IO体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下：&lt;/p&gt;
&lt;p&gt;1 什么是同步？&lt;br&gt;
2 什么是异步？&lt;br&gt;
3 什么是阻塞？&lt;br&gt;
4 什么是非阻塞？&lt;br&gt;
5 什么是同步阻塞？&lt;br&gt;
6 什么是同步非阻塞？&lt;br&gt;
7 什么是异步阻
      
    
    </summary>
    
    
      <category term="Webservice" scheme="https://wuhewuhe.github.io/categories/Webservice/"/>
    
    
      <category term="bio" scheme="https://wuhewuhe.github.io/tags/bio/"/>
    
      <category term="aio" scheme="https://wuhewuhe.github.io/tags/aio/"/>
    
      <category term="nio" scheme="https://wuhewuhe.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>JBoss 面试高频</title>
    <link href="https://wuhewuhe.github.io/2020/02/17/jboss/"/>
    <id>https://wuhewuhe.github.io/2020/02/17/jboss/</id>
    <published>2020-02-17T22:16:10.000Z</published>
    <updated>2020-02-17T22:26:34.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q1. What is JBOSS?</strong><br>JBoss is a popular open source application server based on JEE technology. Being JEE based, the JBoss supports cross-platform java applications. It was embedded with Apache Tomcat web server. It runs under any JVM of 1.3 or later versions. JBoss supports JNDI, Servlet/JSP (Tomcat or Jetty), EJB, JTS/JTA, JCA, JMS, Clustering (JavaGroups), Web Services (Axis), and IIOP integration (JacORB).</p><p><strong>What’s the difference between Standalone mode and Domain mode ?</strong><br>When configured in Standalone mode each distribution starts a single JVM process with its own configuration, management instruments and deployments. When configured in Domain mode, multiple servers are managed from a centralized point called Domain Controller which maintain the configuration and provisions applications for deployment on the single nodes which are part of the Domain</p><p><strong>What do you need to set-up a cluster with JBoss ?</strong><br>Basically starting JBoss with the “all” configuration contains everything needed for clustering:<br>It has all the libraries for clustering:<br>JGroups.jar, jboss-cache.jar<br>Clustered beans (cluster-service.xml)<br>HA-JNDI<br>HTTP session replications (tc5-cluster-service.xml)<br>Farming<br>HA-JMS</p><p><strong>. How do you monitor JBoss and detect the bottleneck of an application?</strong><br>Different components of the application are to be measured. This step is to find where the degradation is, whether it is external or internal and where is the appliciation spending all the time. Using Joss JMX agents and monitoring the deployed components to the application server involves in the first step.<br>After finding the most of the time spent by specific components or libraries or most of the resources, one can use Jprobe a specialized tool for examining the single object or the objects loaded in the memory.</p><p><strong>Does Seam run on other application servers besides JBoss ?</strong><br>Seam(jboss 3) runs beautifully on other application servers – just like everything else the Hibernate team does, this is not a JBoss-only thing.</p><p><strong>Which Hibernate object wraps the JDBC Connection?</strong><br>The Session interface wraps a JDBC Connection. This interface is a single threaded object which represents a single unit of work with application and persistent database. It’s retrieved by the SessionFactory’s openSession() method</p><p><strong>How can you start a JTA transaction from a Servlet deployed on JBoss?</strong><br>JBoss registers in the JNDI tree a JTA UserTransaction Object which can be user to manage a distributed transaction.</p><h3 id="What’s-the-default-port-to-access-Administration-Console-in-JBoss-7">What’s the default port to access Administration Console in JBoss 7?</h3><p>9990 is the default port. If it’s installed on <strong>server1</strong> then you need to access like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;server1:9990&#x2F;admin-console</span><br></pre></td></tr></table></figure><h3 id="Which-component-is-responsible-for-handling-clustering">Which component is responsible for handling clustering?</h3><p>JBoss clustering is on top of JGroups toolkit which helps to create, delete, membership detection, notification, <a href="http://etc.in" target="_blank" rel="noopener">etc.in</a> the cluster.</p><h3 id="What-is-difference-between-validate-on-match-and-background-validation">What is difference between <validate-on-match> and <background-validation>?</background-validation></validate-on-match></h3><p>&lt;<strong>validate-on-match</strong>&gt; validate the database connection every time, and if a connection is not valid, it will write a warning in the logs.</p><p>Having “validate-on-match” configured may have a little high load on the database as it may create lots of requests.</p><p>&lt;<strong>background-validation</strong>&gt; validate the connection periodically based on what frequency is configured for “background-validation-millis”. The default configuration is set to zero means disabled.</p><p>Having “ background-validation” set to true will create fewer database connections and it’s side-effects would be not detecting immediately if dead connections.</p><h3 id="What-are-the-file-types-you-can-deploy-in-JBoss">What are the file types you can deploy in JBoss?</h3><p>You can deploy almost any kind of Java/J2EE application, and it supports the following file format.</p><ul><li>WAR – Web application archive</li><li>SAR – Service archive</li><li>JAR – Java Archive</li><li>EAR – Enterprise application archive</li></ul><h3 id="How-can-you-deploy-an-application">How can you deploy an application?</h3><p>There are three possible ways to deploy an application in JBoss application server.</p><ol><li>Admin Console – you can deploy the necessary application files through the administration console.</li><li>Auto-deploy – leverage file system deployment scanner to auto deploy files from deployments folder.</li><li>Automation – use automation tool/ant/scripting to deploy an application.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Q1. What is JBOSS?&lt;/strong&gt;&lt;br&gt;
JBoss is a popular open source application server based on JEE technology. Being JEE based, the J
      
    
    </summary>
    
    
      <category term="Webservice" scheme="https://wuhewuhe.github.io/categories/Webservice/"/>
    
    
      <category term="Serverlet" scheme="https://wuhewuhe.github.io/tags/Serverlet/"/>
    
      <category term="Jboss" scheme="https://wuhewuhe.github.io/tags/Jboss/"/>
    
  </entry>
  
  <entry>
    <title>session，cookie和token究竟是什么</title>
    <link href="https://wuhewuhe.github.io/2020/02/17/sessionCookieToken/"/>
    <id>https://wuhewuhe.github.io/2020/02/17/sessionCookieToken/</id>
    <published>2020-02-17T22:14:47.000Z</published>
    <updated>2020-02-17T22:15:59.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述">简述</h2><p>我在写之前看了很多篇session，cookie的文章，有的人说先有了cookie，后有了session。也有人说先有session，后有cookie。感觉都没有讲的很清楚，泛泛而谈。希望本篇文章对大家有所帮助<br>注：本文需要读者有cookie，session，token的相关基础知识。</p><h2 id="http是一个无状态协议">http是一个无状态协议</h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把 <code>www.zhihu.com/login.html</code> 和 <code>www.zhihu.com/index.html</code> 关联起来，必须使用某些手段和工具</p><h2 id="cookie和session">cookie和session</h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">Cookie详解</a></li></ul><p><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p><ul><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src="https://segmentfault.com/img/bVbmYbQ?w=400&amp;h=200" alt="请求流程"></p><h3 id="注意">注意</h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="小结">小结</h3><p><strong>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</strong></p><h2 id="oken">oken</h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><h3 id="组成">组成</h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放">存放</h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><h3 id="token认证流程">token认证流程</h3><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h2 id="token可以抵抗csrf-cross-site-request-forgrey-，cookie-session不行">token可以抵抗csrf(cross site request forgrey)，cookie+session不行</h2><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为 <code>http://www.bank.com/api/transfer</code> ，body为 <code>count=1000&amp;to=Tom</code> 。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了. 因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做[JWT(Json Web Token)](<a href="https://huanqiang.wang/2017/12/28/JWT" target="_blank" rel="noopener">https://huanqiang.wang/2017/12/28/JWT</a> 介绍/)</li></ul><h2 id="总结">总结</h2><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;简述&lt;/h2&gt;
&lt;p&gt;我在写之前看了很多篇session，cookie的文章，有的人说先有了cookie，后有了session。也有人说先有session，后有cookie。感觉都没有讲的很清楚，泛泛而谈。希望本篇文章对大家有所帮助&lt;br&gt;
注：本文需要读
      
    
    </summary>
    
    
      <category term="Webservice" scheme="https://wuhewuhe.github.io/categories/Webservice/"/>
    
    
      <category term="cookie" scheme="https://wuhewuhe.github.io/tags/cookie/"/>
    
      <category term="session" scheme="https://wuhewuhe.github.io/tags/session/"/>
    
      <category term="token" scheme="https://wuhewuhe.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>Exception处理</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/exceptionChec-k/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/exceptionChec-k/</id>
    <published>2020-02-16T19:40:25.000Z</published>
    <updated>2020-02-16T19:42:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。</p><p>error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。</p><p>exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题</p><ul><li>先来看看java中异常的体系结构图解</li></ul><img src="/2020/02/16/exceptionChec-k/../Desktop/屏幕快照 2020-02-16 20.07.13.png" alt="屏幕快照 2020-02-16 20.07.13" style="zoom:50%; "><p>首先说明一点，java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。</p><p><strong>运行时异常和非运行时异常</strong><br>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择在运行时捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>CheckedException成为编译时异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><p><strong>Java中异常处理机制的原理</strong></p><p>Java通过面向对象的方式对异常进行处理，Java把异常按照不同的类型进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它都是Throwable</p><p>或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java的</p><p>异常处理是通过5个关键词来实现的：try catch  throw throws finally。</p><p>一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws），我们可以通过它的类型来捕捉它，或最后由缺省处理器来处理它（finally）。</p><p>try：用来指定一块预防所有异常的程序</p><p>catch：紧跟在try后面，用来捕获异常</p><p>throw：用来明确的抛出一个异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; throw </span><br><span class="line">public class throwException &#123;</span><br><span class="line">static void checkAge(int age) &#123;</span><br><span class="line">if (age &lt; 18) &#123;</span><br><span class="line">throw new ArithmeticException(&quot;Access denied - You must be at least 18 years old.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Access granted - You are old enough!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">checkAge(15); &#x2F;&#x2F; Set age to 15 (which is below 18...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws：用来标明一个成员函数可能抛出的各种异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)throws InterruptedException </span><br><span class="line">    &#123; </span><br><span class="line">        Thread.sleep(100); </span><br><span class="line">        System.out.println(&quot;Hello Geeks&quot;); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</p><p><strong>final、finally、finalize的区别</strong></p><p>（1）、final用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承</p><p>（2）、finally是异常处理中的一个关键字，表示finally{}里面的代码一定要执行</p><p>（3）、finalize是Object类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</p><p><strong>try()里面有一个return语句，那么后面的finally{}里面的code会不会被执行，什么时候执行，是在return前还是return后？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">int a &#x3D; 1 &#x2F; 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3</p><p><strong>请写出你最常见的5个RuntimeException</strong></p><p>NullPointer;</p><p>ClassNotFound;</p><p>IndexOutOfBounds;</p><p>ClassCast; NoClassDef;</p><p>IllgealArgument;</p><p>NumberFormat;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。&lt;/p&gt;
&lt;p&gt;error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Ja
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Throwable" scheme="https://wuhewuhe.github.io/categories/Java/Throwable/"/>
    
    
      <category term="try catch finally" scheme="https://wuhewuhe.github.io/tags/try-catch-finally/"/>
    
      <category term="Error" scheme="https://wuhewuhe.github.io/tags/Error/"/>
    
      <category term="Exception" scheme="https://wuhewuhe.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>java 浅谈多线程的通讯方式</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/mutlithread/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/mutlithread/</id>
    <published>2020-02-16T15:56:46.000Z</published>
    <updated>2020-02-16T17:01:08.136Z</updated>
    
    <content type="html"><![CDATA[<p>今天在群里面看到一个很有意思的面试题：<br>“编写两个线程，一个线程打印1~25，另一个线程打印字母A~Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”</p><p>这是一道非常好的面试题，非常能彰显被面者关于多线程的功力，一下子就勾起了我的兴趣</p><p>首先我们先有一个helper类：含有两个固定的线程</p><p>此类单例模式生明一个instance</p><p>分别写两个简单的方法，一个生成数字从一到52，另一个生成字母从a到z</p><p>线程提交和终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package MultiThread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class Helper &#123;</span><br><span class="line"></span><br><span class="line">private Helper() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Helper helper &#x3D; new Helper();</span><br><span class="line"></span><br><span class="line">public static Helper getInstance() &#123;</span><br><span class="line">return helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final ExecutorService tPool &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">public static String[] buildNoArr(int max) &#123;</span><br><span class="line">String[] noArr &#x3D; new String[max];</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">noArr[i] &#x3D; Integer.toString(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">return noArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String[] buildCharArr(int max) &#123;</span><br><span class="line">String[] charArr &#x3D; new String[max];</span><br><span class="line">int tmp &#x3D; 65;</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">charArr[i] &#x3D; String.valueOf((char) (tmp + i));</span><br><span class="line">&#125;</span><br><span class="line">return charArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print(String... input) &#123;</span><br><span class="line">if (input &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">for (String each : input) &#123;</span><br><span class="line">System.out.print(each);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(Runnable r) &#123;</span><br><span class="line">tPool.submit(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">tPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法1-一个变量threadToGo-value共享控制">解法1 一个变量threadToGo.value共享控制</h4><p>创建一个final类 , 包含一个变量value，首先启动线程A，给threadgo加上一个同步锁，打印数字，然后发送notice给threadB，此时value值为2，暂停threadA，输出字母，value值恢复为1，周而复始知道达到threadA和B的终止条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class ThreadToGo &#123;</span><br><span class="line">int value &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 2)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">threadToGo.value &#x3D; 2;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 1)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">threadToGo.value &#x3D; 1;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二-利用-Lock-和-Condition-：">解法二 利用 <code>Lock</code> 和 <code>Condition</code> ：</h4><p>整体来讲与解法1相同, 共享一个变量value，新建一个lock和condition，通过try catch finally 给value上锁然后完成线程之间的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line">private Condition condition &#x3D; lock.newCondition();</span><br><span class="line">private static int value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 2)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">value &#x3D; 2;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 1)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">value &#x3D; 1;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法三-volatile">解法三 volatile</h4><p><code>volatile</code> 能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。写法很是巧妙，需要我们理解volatile，是对在内存中的线程排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private volatile ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line">    class ThreadToGo &#123;</span><br><span class="line">        int value &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.value&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.value&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法四-利用-AtomicInteger-：">解法四 利用 <code>AtomicInteger</code> ：</h4><p>和volatile大致相同，利用起本身的同步特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger threadToGo &#x3D; new AtomicInteger(1);</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.set(2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.set(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法五-CyclicBarrier-API">解法五 <code>CyclicBarrier</code> API</h4><p><code>CyclicBarrier</code> 可以实现让一组线程在全部到达 <code>Barrier</code> 时(执行 <code>await()</code> )，再一起同时执行，并且所有线程释放后，还能复用它, 即为Cyclic。<br><code>CyclicBarrier</code> 类提供两个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure><p><strong>这里多说一点，这个API其实还是利用</strong><code>lock</code><strong>和</strong><code>condition</code><strong>，无非是多个线程去争抢</strong><code>CyclicBarrier</code><strong>的instance的lock罢了，最终barrierAction执行时，是在抢到</strong><code>CyclicBarrier</code><strong>instance的那个线程上执行的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private final CyclicBarrier barrier;</span><br><span class="line">private final List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">public MethodSix() &#123;</span><br><span class="line">list &#x3D; Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">barrier &#x3D; new CyclicBarrier(2, newBarrierAction());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">list.add(arr[i + 1]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Runnable newBarrierAction() &#123;</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">Collections.sort(list);</span><br><span class="line">list.forEach(c -&gt; System.out.print(c));</span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conclusion">conclusion</h4><p>多线程高并发是java语言中的一大特性，学生时代的我对其理解的太微不足道，也是通过工作后看到大神写的代码，改bug，还有兴趣的阅读才一点点发现其奥妙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在群里面看到一个很有意思的面试题：&lt;br&gt;
“编写两个线程，一个线程打印1~25，另一个线程打印字母A~Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”&lt;/p&gt;
&lt;p&gt;这是一道非常好的面试题，非常能彰显被面者关于多线程的功力，一下子就勾起了我的兴
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wuhewuhe.github.io/categories/JAVA/"/>
    
      <category term="Multithread" scheme="https://wuhewuhe.github.io/categories/JAVA/Multithread/"/>
    
    
      <category term="lock condition" scheme="https://wuhewuhe.github.io/tags/lock-condition/"/>
    
      <category term="sychronise wait" scheme="https://wuhewuhe.github.io/tags/sychronise-wait/"/>
    
      <category term="atomic" scheme="https://wuhewuhe.github.io/tags/atomic/"/>
    
      <category term="volatile" scheme="https://wuhewuhe.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>design_pattern</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/design-pattern/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/design-pattern/</id>
    <published>2020-02-16T15:43:40.000Z</published>
    <updated>2020-02-16T15:43:40.331Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单例模式 singlenton</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/singleton/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/singleton/</id>
    <published>2020-02-16T15:43:28.000Z</published>
    <updated>2020-02-16T17:36:12.001Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。既然即使是一个初级的程序员，也会使用单例模式了，为什么我们还要在这里特意地讨论它，并且作为第一个模式来分析呢？事实上在我看来，单例模式是很有“深度”的一个模式，要用好、用对它并不是一件简单的事</p><h5 id="定义">定义:</h5><p>确保这个类在内存中只会存在一个对象, 而且自行实例化并向整个系统提供这个实例;</p><h5 id="场景">场景:</h5><p>产生某对象会消耗过多的资源，为避免频繁地创建与销毁对象对资源的浪费</p><blockquote><p>对数据库的操作、访问 IO、线程池（threadpool）、网络请求等。</p></blockquote><p>某种类型的对象应该有且只有一个。如果制造出多个这样的实例，可能导致：程序行为异常、资源使用过量、结果不一致等问题。如果多人能同时操作一个文件，又不进行版本管理，必然会有的修改被覆盖</p><blockquote><p>一个系统只能有：一个窗口管理器或文件系统，计时工具或 ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。</p></blockquote><h5 id="步骤：">步骤：</h5><ul><li>仅自己可以创建，构造函数私有化</li><li>创建一个实例</li><li>getInstance 考虑加锁同步问题</li></ul><h4 id="单列模式的几种基本写法">单列模式的几种基本写法:</h4><h5 id="饿汉式">饿汉式</h5><p>不需要的时候就加载了, 造成资源浪费.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonHungry() &#123;</span><br><span class="line">System.out.println(&quot;hello Singlenton Hungry&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonHungry hungry;</span><br><span class="line"></span><br><span class="line">public static synchronized SinglentonHungry getInstanceHungry() &#123;</span><br><span class="line">if (hungry &#x3D;&#x3D; null) &#123;</span><br><span class="line">hungry &#x3D; new SinglentonHungry();</span><br><span class="line">&#125;</span><br><span class="line">return hungry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonHungry.getInstanceHungry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式">懒汉式</h5><p>懒汉式缺点: 效率低，第一次加载需要实例化，反应稍慢。每次调用getInstance方法都会进行同步，消耗不必要的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonLazy() &#123;</span><br><span class="line">System.out.println(&quot;hello lazy singlenton&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonLazy lazy &#x3D; new SinglentonLazy();</span><br><span class="line"></span><br><span class="line">public static SinglentonLazy getInstanceLazy() &#123;</span><br><span class="line">return lazy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonLazy ss &#x3D; SinglentonLazy.getInstanceLazy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的两种是最常见的, 顾名思义懒汉式和饿汉式, 一个是拿时间换空间, 一个是拿空间换时间, 懒汉式只有我需要他的时候才去加载它, 懒加载机制, 饿汉式不管需不需要我先加载了再说, 先在内存中开辟一块空间, 占用一块地方, 等用到了直接就拿来用. 这两种是最基本的单列模式。</p><h5 id="双重检查单列-double-check-locking">双重检查单列 double check locking</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonDCL &#123;</span><br><span class="line"></span><br><span class="line">private SinglentonDCL() &#123;</span><br><span class="line">System.out.println(&quot;hello singlenton dcl&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile static SinglentonDCL dcl;</span><br><span class="line"></span><br><span class="line">public static SinglentonDCL getInstanceDcl() &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized (SinglentonDCL.class) &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">dcl &#x3D; new SinglentonDCL();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dcl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonDCL.getInstanceDcl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法估计是我们在开发中最常用的, 这次代码的亮点是是在getInstance()方法中进行了双重的判断, 第一层判断的主要避免了不必要的同步, 第二层判断是为了在null的情况下再去创建实例; 举个简单的列子: 假如现在有多个线程同时触发这个方法: 线程A执行到nstance = new Singleton(), 它大致的做了三件事:<br>(1): 给Singleton实例分配内存, 将函数压栈, 并且申明变量类型;<br>(2): 初始化构造函数以及里面的字段, 在堆内存开辟空间;<br>(3): 将instance对象指向分配的内存空间;</p><p><strong>这种写法也并不是保证完全100%的可靠, 由于java编译器允许执行无序</strong></p><h5 id="静态内部内实现单列">静态内部内实现单列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonStaticInner &#123;</span><br><span class="line">private SinglentonStaticInner() &#123;</span><br><span class="line">System.out.println(&quot;hello singleton inner&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final SinglentonStaticInner getInstanceInner() &#123;</span><br><span class="line">return SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonHolder &#123;</span><br><span class="line">private static final SinglentonStaticInner INSTANCE &#x3D; new SinglentonStaticInner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonStaticInner.getInstanceInner();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举实现单列">枚举实现单列</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点: 相对于其他单列来说枚举写法最简单, 并且任何情况下都是单列的</p><h5 id="使用容器单">使用容器单</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; objMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private SingletonManager() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void putObject(String key, Object instance)&#123;</span><br><span class="line">        if(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getObject(String key)&#123;</span><br><span class="line">        return objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序开始的时候将单列类型注入到一个容器之中, 也就是单列ManagerClass, 在使用的时候再根据key值获取对应的实例, 这种方式可以使我们很方便的管理很多单列对象, 也对用户隐藏了具体实现类, 降低了耦合度; 但是为了避免造成内存泄漏, 所以我们一般在生命周期销毁的时候也要去销毁它</p><h4 id="总结">总结</h4><p>单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式都不会有太大的影响。即使如此，出于效率考虑，推荐使用DCL单例（双重检查锁定）和静态内部类单例模式。</p><p>优点：</p><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>单例模式可以避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。</li><li>单例对象如果持有Context，那么很容易引发内存泄露。此时需要注意传递给单例对象的Context最好是Application Context。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式（Singleton Pattern）一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。既然即使是一个初级的程序员，也会使用单例模式了，为什么我们还要在这里特意地讨论它，并且作为第一个模式来分析呢？事实上在我看来，单例
      
    
    </summary>
    
    
      <category term="Design pattern" scheme="https://wuhewuhe.github.io/categories/Design-pattern/"/>
    
    
      <category term="singlenton" scheme="https://wuhewuhe.github.io/tags/singlenton/"/>
    
      <category term="lazy" scheme="https://wuhewuhe.github.io/tags/lazy/"/>
    
      <category term="hungry" scheme="https://wuhewuhe.github.io/tags/hungry/"/>
    
      <category term="double check locking" scheme="https://wuhewuhe.github.io/tags/double-check-locking/"/>
    
      <category term="static inner class" scheme="https://wuhewuhe.github.io/tags/static-inner-class/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/volatile/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/volatile/</id>
    <published>2020-02-16T15:43:16.000Z</published>
    <updated>2020-02-16T15:56:38.224Z</updated>
    
    <content type="html"><![CDATA[<h1>深入浅出java中volatile</h1><p>这周处理ticket的时候发现，我们经常会把数据加载到cache，然后去生明voltile，于是我就梳理了一下知识点，可能有点冷门，但是还是有其用到的地方</p><h3 id="volatile定义">volatile定义</h3><p>如果一个字段被声明为volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><h3 id="volatile的特性">volatile的特性</h3><p>从上面的官方定义我们可以看出 volatile实现了内存可见性<br>内存可见性：简单的讲也就是说一个线程对 声明了volatile的变量进行修改，java会保证其他线程也能看见修改，保证内存中的变量是最新的</p><p>原子性： volatile 能保证单个volatile的操作是原子性的 但不能保证 形如 i++这样的操作是原子性的 （下面会给出代码）</p><h3 id="volatile的使用">volatile的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>只要在变量前声明即可</p><p>volatile 无法保证复合性操作的原子性<br>我们可以通过代码实验来证明这一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title">AtomicTest</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span>    <span class="keyword">static</span>   <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ;k&lt;<span class="number">1000</span>;k++)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws InterruptedException</span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AtomicTest());</span><br><span class="line">            threads[c].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c =<span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c].<span class="keyword">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上， 执行上述代码你会发现每次输出的值都会小于我们所期待的最终值 10000 ，  也就 i++并不是原子性的。<br>所以我们并不建议 volatile使用在这种场景下，我们可以用volatile ：检查某个标记以来判断是否进行下一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(flag)&#123; </span><br><span class="line">      ........</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile的内存可见性">volatile的内存可见性</h3><p>volatile的内存可见性是通过java内存模型对volatile定义的特殊规则定义的。在jvm虚拟机的内存模型中 分为本地内存和主内存，每一个线程都有自己的本地内存，并且共享同一个主内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当写一个<span class="keyword">volatile</span>变量时， java内存模型会把该变量从线程的本地变量刷新到主内存</span><br><span class="line">当读一个<span class="keyword">volatile</span>变量时，java内存模型会去主内存取该变量，然后将本地内存中的值改变</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-2c36332ffe88609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/424/format/webp" alt="img"></p><p>2.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-bc40b98181cd7b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="img"></p><p>3.png</p><h3 id="java内存模型中的volatile-、">java内存模型中的volatile 、</h3><p>java内存模型为了保证volatile 的内存可见性 对volatile还有第二条语义：禁止指令重排序优化（关于重排序后面我也会整理我的心得分享给大家，简单的讲就是java会对没有数据依赖的操作进行指令重排 已达到提升性能的目的）。<br>那么为什么要禁止指令重排序呢？下面我们通过一个简单的代码来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map mapTest;</span><br><span class="line"><span class="keyword">char</span>[] configuration;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> init =<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//假设a线程执行writer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">mapTest =<span class="keyword">new</span> HashMap;</span><br><span class="line">configuration = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];<span class="comment">//读之前的准工作</span></span><br><span class="line">init =<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设b线程执行该代码</span></span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(init )&#123;</span><br><span class="line">  .......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的代码，如果init变量没有被定义为volatile的，那么 init=true 这段代码可能由于指令重排序的优化，导致其被提前执行，这样会导致配置b中使用a线程中的配置信息是出错，<br>volatile变量的赋值的汇编代码是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java代码 ： instance =new singleton（）</span><br><span class="line">汇编代码：  0x01a3de1d: movb <span class="variable">$0x0</span>,0x1104800(%esi);</span><br><span class="line">                     0x01a3de24: lock addl <span class="variable">$0x0</span>,(%esp);</span><br></pre></td></tr></table></figure><p>其中 lock addl $0x0, (%esp) 就相当于一个内存屏障  对于volatile变量来说 读写会具有不同的内存屏障.<br>具体会根据以下规则使用不同的内存屏障</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不&gt;&gt;能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><h3 id="结语">结语</h3><p>引用java并发编程实战中的一段话结束这篇文章<br>仅当volatile 变量能简化代码的实习以及对同步策略的验证时，才应该使用它们，如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期时间的发生（例如，初始化和关闭）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;深入浅出java中volatile&lt;/h1&gt;
&lt;p&gt;这周处理ticket的时候发现，我们经常会把数据加载到cache，然后去生明voltile，于是我就梳理了一下知识点，可能有点冷门，但是还是有其用到的地方&lt;/p&gt;
&lt;h3 id=&quot;volatile定义&quot;&gt;volatile
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Cache" scheme="https://wuhewuhe.github.io/categories/Java/Cache/"/>
    
    
      <category term="volatile" scheme="https://wuhewuhe.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>entry reflect</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/entry-reflect/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/entry-reflect/</id>
    <published>2020-02-16T09:53:19.000Z</published>
    <updated>2020-02-16T09:53:43.093Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分为堆和栈，易懂点吧！</p><p>假如你写了一段代码：Object o=new Object();</p><p>运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p><p>题主想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求哦要用到某个类，哎呀但没加载进jvm，是不是要停下来自己写段代码，new一下，哦启动一下服务器，（脑残）！</p><p>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="reflect" scheme="https://wuhewuhe.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>JVM Method area</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/mthod-area/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/mthod-area/</id>
    <published>2020-02-16T09:47:10.000Z</published>
    <updated>2020-02-16T09:47:51.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。</p></blockquote><h2 id="方法区">方法区</h2><p>方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><blockquote><p>注意：JDK 6 时，String等字符串常量的信息是置于方法区中的，但是到了JDK 7 时，已经移动到了Java堆。所以，方法区也好，Java堆也罢，到底详细的保存了什么，其实没有具体定论，要结合不同的JVM版本来分析。</p></blockquote><blockquote><h3 id="异常">异常</h3><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。<br>运行时常量池溢出：比如一直往常量池加入数据，就会引起OutOfMemoryError异常。</p></blockquote><h3 id="类信息">类信息</h3><blockquote><ol><li>类型全限定名。</li><li>类型的直接超类的全限定名（除非这个类型是java.lang. Object，它没有超类）。</li><li>类型是类类型还是接口类型。</li><li>类型的访问修饰符（public、abstract或final的某个子集）。</li><li>任何直接超接口的全限定名的有序列表。</li><li>类型的常量池。</li><li>字段信息。</li><li>方法信息。</li><li>除了常量意外的所有类（静态）变量。</li><li>一个到类ClassLoader的引用。</li><li>一个到Class类的引用。</li></ol></blockquote><h2 id="1-常量池">1 常量池</h2><h3 id="1-1-Class文件中的常量池">1.1 Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h3 id="1-2-运行时常量池">1.2 运行时常量池</h3><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="1-3-常量池的好处">1.3 常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><blockquote><p>双等号==的含义</p><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul></blockquote><h3 id="1-4-基本类型的包装类和常量池">1.4 基本类型的包装类和常量池</h3><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean。</p><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float, Double并没有实现常量池技术。</p><h4 id="Integer与常量池">Integer与常量池</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));  </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="解释：">解释：</h4><ul><li>(1)Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40); ，从而使用常量池中的对象。</li><li>(2)Integer i1 = new Integer(40); 这种情况下会创建新的对象。</li><li>(3)语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</li></ul><h4 id="String与常量池">String与常量池</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str1 = <span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="解释：-2">解释：</h4><ul><li><p>(1)new String(“abcd”)是在常量池中拿对象，&quot;abcd&quot;是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。</p></li><li><p>(2)连接表达式 +</p><p>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final String A; &#x2F;&#x2F; 常量A</span><br><span class="line">public static final String B;    &#x2F;&#x2F; 常量B</span><br><span class="line">static &#123;  </span><br><span class="line">   A &#x3D; &quot;ab&quot;;  </span><br><span class="line">   B &#x3D; &quot;cd&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">&#x2F;&#x2F; 将两个常量用+连接对s进行初始化  </span><br><span class="line">String s &#x3D; A + B;  </span><br><span class="line">String t &#x3D; &quot;abcd&quot;;  </span><br><span class="line">if (s &#x3D;&#x3D; t) &#123;  </span><br><span class="line">    System.out.println(&quot;s等于t，它们是同一个对象&quot;);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-3">解释：</h4><p>s不等于t，它们不是同一个对象。</p><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xyz"</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure><h4 id="解释：-4">解释：</h4><p>考虑类加载阶段和实际执行时。</p><ul><li>（1）类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li><li>（2）在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s1 持有。</li></ul><p>这条语句创建了2个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String s1 &#x3D; new String(&quot;计算机&quot;);</span><br><span class="line">String s2 &#x3D; s1.intern();</span><br><span class="line">String s3 &#x3D; &quot;计算机&quot;;</span><br><span class="line">System.out.println(&quot;s1 &#x3D;&#x3D; s2? &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">System.out.println(&quot;s3 &#x3D;&#x3D; s2? &quot; + (s3 &#x3D;&#x3D; s2));</span><br><span class="line">&#125;</span><br><span class="line">s1 &#x3D;&#x3D; s2? false</span><br><span class="line">s3 &#x3D;&#x3D; s2? true</span><br></pre></td></tr></table></figure><h4 id="解释：-5">解释：</h4><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串, 如果有则返回该字符串的引用, 如果没有则添加自己的字符串进入常量池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"> String hello = <span class="string">"Hello"</span>, lo = <span class="string">"lo"</span>;</span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == <span class="string">"Hello"</span>) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((other.Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+<span class="string">"lo"</span>)) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+lo)) + <span class="string">" "</span>); <span class="comment">//false</span></span><br><span class="line"> System.<span class="keyword">out</span>.println(hello == (<span class="string">"Hel"</span>+lo).intern()); <span class="comment">//true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">package other;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-6">解释：</h4><p>在同包同类下, 引用自同一String对象.</p><p>在同包不同类下, 引用自同一String对象.</p><p>在不同包不同类下, 依然引用自同一String对象.</p><p>在编译成.class时能够识别为同一字符串的, 自动优化成常量, 引用自同一String对象.</p><p>在运行时创建的字符串具有独立的内存地址, 所以不引用自同一String对象.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方法区&quot;&gt;方法区&lt;/h2&gt;
&lt;p&gt;方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://wuhewuhe.github.io/categories/Java/JVM/"/>
    
    
      <category term="method area" scheme="https://wuhewuhe.github.io/tags/method-area/"/>
    
  </entry>
  
  <entry>
    <title>reflect</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/reflect/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/reflect/</id>
    <published>2020-02-16T09:17:09.000Z</published>
    <updated>2020-02-16T09:39:08.251Z</updated>
    
    <content type="html"><![CDATA[<p>反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。</p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple &#x3D; new Apple(); &#x2F;&#x2F;直接初始化，「正射」</span><br><span class="line">apple.setPrice(4);</span><br></pre></td></tr></table></figure><p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p><p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p><p>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);</span><br><span class="line">Method method &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Object object &#x3D; constructor.newInstance();</span><br><span class="line">method.invoke(object, 4);</span><br></pre></td></tr></table></figure><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect. Apple）。</p><p>所以说什么是反射？</p><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p><h2 id="一个简单的例子">一个简单的例子</h2><p>上面提到的示例程序，其完整的程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Apple &#123;</span><br><span class="line"></span><br><span class="line">    private int price;</span><br><span class="line"></span><br><span class="line">    public int getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(int price) &#123;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;正常的调用</span><br><span class="line">        Apple apple &#x3D; new Apple();</span><br><span class="line">        apple.setPrice(5);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + apple.getPrice());</span><br><span class="line">        &#x2F;&#x2F;使用反射调用</span><br><span class="line">        Class clz &#x3D; Class.forName(&quot;com.chenshuyi.api.Apple&quot;);</span><br><span class="line">        Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">        Constructor appleConstructor &#x3D; clz.getConstructor();</span><br><span class="line">        Object appleObj &#x3D; appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, 14);</span><br><span class="line">        Method getPriceMethod &#x3D; clz.getMethod(&quot;getPrice&quot;);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple Price:5</span><br><span class="line">Apple Price:14</span><br></pre></td></tr></table></figure><p>从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</p><ul><li>获取类的 Class 对象实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.zhenai.api.Apple&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据 Class 对象实例获取 Constructor 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor &#x3D; clz.getConstructor();</span><br></pre></td></tr></table></figure><ul><li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj &#x3D; appleConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>而如果要调用某一个方法，则需要经过下面的步骤：</p><ul><li>获取方法的 Method 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br></pre></td></tr></table></figure><ul><li>利用 invoke 方法调用方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, 14);</span><br></pre></td></tr></table></figure><p>到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。</p><p>在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p><h2 id="反射常用API">反射常用API</h2><h3 id="获取反射中的Class对象">获取反射中的Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><p>**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p><strong>第二种，使用 .class 方法。</strong></p><p>这种方法只适合在编译前就知道操作的 Class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; String.class;</span><br></pre></td></tr></table></figure><p><strong>第三种，使用类对象的 getClass() 方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">Class clz &#x3D; str.getClass();</span><br></pre></td></tr></table></figure><h3 id="通过反射创建类对象">通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p>第一种：通过 Class 对象的 newInstance() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Apple apple &#x3D; (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure><p>第二种：通过 Constructor 对象的 newInstance() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure><h3 id="通过反射获取类属性、方法、构造器">通过反射获取类属性、方法、构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="img"></p><p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Delegate" scheme="https://wuhewuhe.github.io/categories/Java/Delegate/"/>
    
    
      <category term="reflect" scheme="https://wuhewuhe.github.io/tags/reflect/"/>
    
      <category term="invoke" scheme="https://wuhewuhe.github.io/tags/invoke/"/>
    
  </entry>
  
  <entry>
    <title>composite and aggrevgation</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/composite-and-aggrevgation/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/composite-and-aggrevgation/</id>
    <published>2020-02-16T09:05:49.000Z</published>
    <updated>2020-02-16T09:06:57.165Z</updated>
    
    <content type="html"><![CDATA[<ul><li>inheritance and delegate</li></ul><p>both of them are the reuse technique in java, and they are importance design in our daily coding, inheritance is represented by Lioskv, his operations and attributes are inherite by subclass from parent class in the context, which is called super class.</p><p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p><p>Delegation can be an alternative to inheritance.<br>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.<br>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.<br>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</p><ul><li>difference between delegate and inheritance?</li></ul><p>inheitance vise to class, bur delegate vise to object</p><ul><li>Why use delegate?</li></ul><p>it can be an alternative way of inheritance, but the primary advantage of delegate is that it’s flexible and change in run time, it doesn’t force you to accept all method of a super class, you just provide some mthod make you sense</p><ul><li>When to use inheritance?</li></ul><p>You want to express relationship (is-a) then you want to use Inheritance.</p><p>You want to be able to pass your class to an existing API expecting A’s then you need to use inheritance.</p><ul><li>when to use delegate?</li></ul><p>You want to enhance A, but A is final and can no further be sub-classed then you need to use <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/" target="_blank" rel="noopener">composition</a> and delegation.</p><p>In this example, there is an Institute which has no. of departments like CSE, EE. Every department has no. of students. So, we make a Institute class which has a reference to Object or no. of Objects (i.e. List of Objects) of the Department class. That means Institute class is associated with Department class through its Object(s). And Department class has also a reference to Object or Objects (i.e. List of Objects) of Student class means it is associated with Student class through its Object(s).<br>It represents a <strong>Has-A</strong> relationship.<br><a href="https://www.geeksforgeeks.org/media.geeksforgeeks.org/wp-content/uploads/Reference.png" target="_blank" rel="noopener"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Reference.png" alt="Aggregation_1"></a></p><p>Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.</p><ul><li>It represents <strong>part-of</strong> relationship.</li><li>In composition, both the entities are dependent on each other.</li><li>When there is a composition between two entities, the composed object <strong>cannot exist</strong> without the other entity.</li></ul><p>In above example a library can have no. of <strong>books</strong> on same or different subjects. So, If Library gets destroyed then All books within that particular library will be destroyed. i.e. book can not exist without library. That’s why it is composition.</p><p><strong>Aggregation vs Composition</strong></p><ol><li><strong>Dependency:</strong> Aggregation implies a relationship where the child <strong>can exist independently</strong> of the parent. For example, Bank and Employee, delete the Bank and the Employee still exist. whereas Composition implies a relationship where the child <strong>cannot exist independent</strong> of the parent. Example: Human and heart, heart don’t exist separate to a Human</li><li><strong>Type of Relationship:</strong> Aggregation relation is <strong>“has-a”</strong> and composition is <strong>“part-of”</strong> relation.</li><li><strong>Type of association:</strong> Composition is a <strong>strong</strong> Association whereas Aggregation is a <strong>weak</strong> Association.</li></ol><p>In case of aggregation, the Car also performs its functions through an Engine. but the Engine is not always an internal part of the Car. An engine can be swapped out or even can be removed from the car. That’ why we make The Engine type field non-final.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;inheritance and delegate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;both of them are the reuse technique in java, and they are importance design in our daily co
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Design pattern" scheme="https://wuhewuhe.github.io/categories/Java/Design-pattern/"/>
    
    
      <category term="deglate" scheme="https://wuhewuhe.github.io/tags/deglate/"/>
    
      <category term="inheritance" scheme="https://wuhewuhe.github.io/tags/inheritance/"/>
    
      <category term="comoposite" scheme="https://wuhewuhe.github.io/tags/comoposite/"/>
    
      <category term="aggrevgation" scheme="https://wuhewuhe.github.io/tags/aggrevgation/"/>
    
  </entry>
  
  <entry>
    <title>SOLID Object Orient Programming pinciples</title>
    <link href="https://wuhewuhe.github.io/2020/02/15/solid/"/>
    <id>https://wuhewuhe.github.io/2020/02/15/solid/</id>
    <published>2020-02-15T17:41:04.000Z</published>
    <updated>2020-02-15T17:45:22.884Z</updated>
    
    <content type="html"><![CDATA[<p>this is 5 pinciple of object-oriented programming</p><p>In object-oriented computer programming, <strong>SOLID</strong> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.</p><ul><li>s = single respoonsibilty principle</li></ul><p>a class should have a single responsibility, one part of software’s specification should be able to affect the specification of class</p><ul><li>open close principle</li></ul><p>Software class should be opened for extension but closed for modifications</p><ul><li>Liskov</li></ul><p>Object in a program should be replaced with instance of their subtype without correctness of that program</p><ul><li>interface segergation</li></ul><p>many client specific interface are better than one general purpose interface</p><ul><li>dependency inversion</li></ul><p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p><h4 id="single-responsibility">single responsibility</h4><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p><p><strong>example</strong></p><p>First, we create our shapes classes and have the constructors setup the required parameters. Next, we move on by creating the <strong>AreaCalculator</strong> class and then write up our logic to sum up the areas of all provided shapes.</p><p>To use the <strong>AreaCalculator</strong> class, we simply instantiate the class and pass in an array of shapes, and display the output at the bottom of the page.</p><p>All of that logic would be handled by the <strong>AreaCalculator</strong> class, this is what SRP frowns against; the <strong>AreaCalculator</strong> class should only sum the areas of provided shapes, it should not care whether the user wants json or HTML.</p><p>Now, whatever logic you need to output the data to the user is now handled by the <strong>SumCalculatorOutputter</strong> class.</p><h4 id="open-closed-principle">open-closed principle</h4><p>This simply means that a class should be easily extendable without modifying the class itself. Let’s take a look at the <strong>AreaCalculator</strong> class, especially it’s <strong>sum</strong> method.</p><p>If we wanted the <strong>sum</strong> method to be able to sum the areas of more shapes, we would have to add more <strong>if/else blocks</strong> and that goes against the Open-closed principle.</p><p>A way we can make this <strong>sum</strong> method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape’s class.</p><p>The same thing should be done for the <strong>Circle</strong> class, an <strong>area</strong> method should be added. Now, to calculate the sum of any shape provided should be as simple as:</p><p>Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the <strong>AreaCalculator</strong> is actually a shape or if the shape has a method named <strong>area</strong>?</p><p>Coding to an interface is an integral part of <strong>S. O. L. I. D</strong>, a quick example is we create an interface, that every shape implements:</p><p>In our <strong>AreaCalculator</strong> sum method we can check if the shapes provided are actually instances of the <strong>ShapeInterface</strong>, otherwise we throw an exception:</p><h4 id="Liskoc-substitution-principle">Liskoc substitution principle</h4><p>Next up on our list is Liskov substitution, which is arguably the most complex of the 5 principles. Simply put, <strong>if class *A* is a subtype of class *B*, then we should be able to replace *B* with *A* without disrupting the behavior of our program.</strong></p><h4 id="interface-segregation">interface segregation</h4><p><strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we can add another contract to the <strong>ShapeInterface</strong>:</p><p>Any shape we create must implement the <strong>volume</strong> method, but we know that squares are flat shapes and that they do not have volumes, so this interface would force the <strong>Square</strong> class to implement a method that it has no use of.</p><p><strong>ISP</strong> says no to this, instead you could create another interface called <strong>SolidShapeInterface</strong> that has the <strong>volume</strong> contract and solid shapes like cubes e.t.c can implement this interface:</p><p>This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead of using a <strong>ShapeInterface</strong> or a <strong>SolidShapeInterface</strong>.</p><p>You can create another interface, maybe <strong>ManageShapeInterface</strong>, and implement it on both the flat and solid shapes, this way you can easily see that it has a single API for managing the shapes. For example:</p><p>Now in <strong>AreaCalculator</strong> class, we can easily replace the call to the <strong>area</strong> method with <strong>calculate</strong> and also check if the object is an instance of the <strong>ManageShapeInterface</strong> and not the <strong>ShapeInterface</strong>.</p><h4 id="dependecy-inversion">dependecy inversion</h4><p><strong>The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.</strong></p><p>this principle realise the open-close displicine, which means that we don’t need to concentrate which is the shape type exactly, because each shape has his own area and we can call it by the abstraction class.</p><p><strong>in the last, you can find my code in attchement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square s &#x3D; new Square(&quot;square&quot;, 1);</span><br><span class="line">Circle c &#x3D; new Circle(&quot;circle&quot;, 1);</span><br><span class="line">Shapes[] ss &#x3D; &#123; s, c &#125;;</span><br><span class="line">CalculatorArea ca &#x3D; new CalculatorArea(ss);</span><br><span class="line">System.out.println(ca.sumShapes());</span><br><span class="line">FormatOutputter fo &#x3D; new FormatOutputter(formatter.HTML, ca);</span><br><span class="line">fo.transfer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class CalculatorArea &#123;</span><br><span class="line">private Shapes[] shapes;</span><br><span class="line"></span><br><span class="line">public CalculatorArea(Shapes[] shapes) &#123;</span><br><span class="line">this.shapes &#x3D; shapes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.area();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int volumeShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.volume();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shapes &#123;</span><br><span class="line">private int radius;</span><br><span class="line"></span><br><span class="line">public Circle(String name, int radius) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getRadius() &#123;</span><br><span class="line">return radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return (int) (Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) (Math.PI * radius * 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class FormatOutputter &#123;</span><br><span class="line">private CalculatorArea ca;</span><br><span class="line">private formatter format;</span><br><span class="line"></span><br><span class="line">public FormatOutputter(formatter format, CalculatorArea ca) &#123;</span><br><span class="line">this.format &#x3D; format;</span><br><span class="line">this.ca &#x3D; ca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer() &#123;</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case JSON:</span><br><span class="line">System.out.println(&quot;json transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case HTML:</span><br><span class="line">System.out.println(&quot;html transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case TXT:</span><br><span class="line">System.out.println(&quot;txt transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case XML:</span><br><span class="line">System.out.println(&quot;xml transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public enum formatter &#123;</span><br><span class="line">XML, JSON, TXT, HTML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeInterface &#123;</span><br><span class="line">int area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public abstract class Shapes implements ShapeInterface, ShapeVolumInterface &#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Shapes(String name) &#123;</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeVolumInterface &#123;</span><br><span class="line">int volume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Square extends Shapes &#123;</span><br><span class="line">private int length;</span><br><span class="line"></span><br><span class="line">public Square(String name, int length) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return length * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) Math.pow(length, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this is 5 pinciple of object-oriented programming&lt;/p&gt;
&lt;p&gt;In object-oriented computer programming, &lt;strong&gt;SOLID&lt;/strong&gt; is a mnemonic ac
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="solid" scheme="https://wuhewuhe.github.io/tags/solid/"/>
    
      <category term="oop" scheme="https://wuhewuhe.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>装*必备的linux命令</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/linux-command/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/linux-command/</id>
    <published>2020-02-12T18:56:25.000Z</published>
    <updated>2020-02-15T17:47:02.956Z</updated>
    
    <content type="html"><![CDATA[<p>当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演</p><h4 id="常规操作-小试牛刀">常规操作 小试牛刀</h4><p><strong>ls: 类似于dos下的dir命令</strong></p><p>ls最常用的参数有三个： -a -l -F。</p><p>ls –a</p><p>Linux上的文件以. 开头的文件被系统视为隐藏文件，仅用ls命令是看不到他们的，而用ls -a除了显示一般文件名外，连隐藏文件也会显示出来。</p><p>ls –l</p><p>该参数显示更详细的文件信息。</p><p>ls –F</p><p>使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。但是现在基本上所有的Linux发行版本的ls都已经内建了-F参数，也就是说，不用输入这个参数，我们也能看到各种分辨符号。</p><p><strong>cd: 用于切换用户当前工作目录</strong></p><p>cd aaa 进入aaa目录</p><p>cd 命令后不指定目录，会切换到当前用户的home 目录</p><p>cd ~ 作用同cd后不指定目录，切换到当前用户的home 目录</p><p>cd - 命令后跟一个减号，则会退回到切换前的目录</p><p>cd … 返回到当前目录下的上一级目录</p><p><strong>pwd：用于显示用户当前工作目录</strong></p><p><strong>mkdir 和 rmdir</strong></p><p>midir: 创建目录 rmdir: 删除目录</p><p>两个命令都支持-p参数，对于mkdir命令若指定路径的父目录不存在则一并创建，对于rmdir命令则删除指定路径的所有层次目录，如果文件夹里有内容，则不能用rmdir命令</p><p>如下：</p><p>mkdir -p 1/2/3</p><p>rmdir -p 1/2/3</p><p><strong>tar 打包压缩与解压缩</strong></p><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2</a>命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file&#x3D;&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br></pre></td></tr></table></figure><p><strong>将文件全部打包成tar包</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！ </span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure><p>在选项 <code>f</code> 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 <code>z</code> 选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加 <code>j</code> 选项，则以.tar.bz2来作为tar包名。</p><p><strong>查阅上述tar包内有哪些文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 <code>z</code> 这个选项了。</p><p><strong>将tar包解压缩</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;opt&#x2F;soft&#x2F;test&#x2F;log.tar.gz</span><br></pre></td></tr></table></figure><h4 id="文件操作-装-的核心操作">文件操作 装*的核心操作</h4><p><strong>touch</strong></p><p>inux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令&quot;touch&quot;修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure><p><strong>cp：复制命令</strong></p><p>复制一个文件到另一目录：cp 1.txt …/test2</p><p>复制一个文件到本目录并改名：cp 1.txt 2.txt</p><p>复制一个文件夹a并改名为b：cp -r a b</p><p><strong>mv：移动命令</strong></p><p>将一个文件移动到另一个目录：mv 1.txt …/test1</p><p>将一个文件在本目录改名：mv 1.txt 2.txt</p><p>将一个文件一定到另一个目录并改名：mv 1.txt …/test1/2.txt</p><p><strong>rm命令</strong></p><p>rm命令用于删除文件，与dos下的del/erase命令相似，rm命令常用的参数有三个：-i，-r，-f。</p><p>–i ：系统在删除文件之前会先询问确认，用户回车之后，文件才会真的被删除。需要注意，linux下删除的文件是不能恢复的，删除之前一定要谨慎确认。</p><p>–r：该参数支持目录删除，功能和rmdir命令相似。</p><p>–f：和-i参数相反，-f表示强制删除</p><p><strong>cat命令</strong></p><p>cat命令的功能是显示或连结一般的ascii文本文件。cat是concatenate的简写，类似于dos下面的type命令。用法如下：</p><p>cat file1 显示file1文件内容</p><p>cat file1 file2 依次显示file1, file2的内容</p><p>cat file1 file2 &gt; file3 把file1, file2的内容结合起来，再“重定向（&gt;）”到file3文件中。</p><p>&quot;&gt;“是右重定向符，表示将左边命令结果当成右边命令的输入，注意：如果右侧文件是一个已存在文件，其原有内容将会被清空，而变成左侧命令输出内容。如果希望以追加方式写入，请改用”&gt;&gt;&quot;重定向符。</p><p>如果&quot;&gt;&quot;左边没有指定文件，如： cat &gt;file1，将会等用户输入，输入完毕后再按[Ctrl]+[c]或[Ctrl]+[d]，就会将用户的输入内容写入file1。</p><p><strong>echo命令</strong></p><p>echo命令的使用频率不少于ls和cat，尤其是在shell脚本编写中。</p><p>语法：echo [-ne][字符串]</p><p>功能：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开， 并在最后加上换行符。</p><p>参数：</p><p>-n 显示字串时在最后自动换行</p><p>-e 支持以下格式的转义字符， -E 不支持以下格式的转义字符</p><p>/a 发出警告声；</p><p>/b 删除前一个字符；</p><p>/c 最后不加上换行符号；</p><p>/f 换行但光标仍旧停留在原来的位置；</p><p>/n 换行且光标移至行首；</p><p>/r 光标移至行首，但不换行；</p><p>/t 插入tab；</p><p>/v 与/f相同；</p><p>// 插入/字符；</p><p><strong>more，less，clear</strong></p><p>n more，less命令</p><p>这两个命令用于查看文件，如果一个文件太长，显示内容超出一个屏幕，用cat命令只能看到最后的内容，用more和less两个命令可以分页查看。more指令可以使超过一页的文件内容分页暂停显示，用户按键后才继续显示下一页。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，更方便浏览阅读。</p><p>less的常用动作命令：</p><p>回车键 向下移动一行；</p><p>y 向上移动一行；</p><p>空格键 向下滚动一屏；</p><p>b 向上滚动一屏；</p><p>d 向下滚动半屏；</p><p>h less的帮助；</p><p>u 向上洋动半屏；</p><p>w 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示；</p><p>g 跳到第一行；</p><p>G 跳到最后一行；</p><p>p n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示；</p><p>/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词；</p><p>v 调用vi编辑器；</p><p>q 退出less</p><p>!command 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</p><p>n clear命令</p><p>clear命令是用来清除当前屏幕显示的，不需任何参数，和dos下的cls命令功能相同。</p><h4 id="读写操作-装-境界更上一层楼">读写操作 装*境界更上一层楼</h4><p><strong>vim 高级文本编辑器</strong></p><p>Vim 经常被认为是 “程序员的编辑器”, 它在程序编写时非常有用，很多人认为它是一个完整的集成开发环境(IDE)。仅管如此，Vim并不只是程序员使用的。Vim可以用于多种文档编辑，从email排版到配置文件编写。</p><p><strong>编辑模式</strong>（Normal）：执行命令，也称为正常模式<br>**插入模式 **（Insert）：输入文本<br><strong>命令模式</strong>：执行 <strong>冒号</strong> 命令</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>按下键 i ，进入 <em>Insert</em> 模式（ 这时候，你可以输入文本）</li><li>按 ESC键，就可退回到<em>Normal</em> 模式下</li></ul><p>在Normal下基本命令操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">Insert</span> 模式，按 <span class="selector-tag">ESC</span>回到 <span class="selector-tag">Normal</span>模式。 <span class="selector-tag">x</span> 删当前光标所在的一个字符。<span class="selector-pseudo">:wq</span> 存盘+退出 (<span class="selector-pseudo">:w</span>存盘, <span class="selector-pseudo">:q</span>退出) （注<span class="selector-pseudo">:w</span> 后可以跟文件名）<span class="selector-pseudo">:q</span> ! 不保存退出 <span class="selector-tag">Shift</span>+<span class="selector-tag">ZZ</span> 退出本文档 <span class="selector-tag">dd</span> 删除当前行，并把删除的行存到剪贴板里 <span class="selector-tag">p</span> 粘贴剪贴板<span class="selector-pseudo">:help</span> 显示相关命令的帮助（<span class="selector-pseudo">:q</span> 退出帮助） 移动光标 <span class="selector-tag">hjkl</span> (←↓↑→)</span><br></pre></td></tr></table></figure><p>简单的光标移动命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       当前行第一列</span><br><span class="line">w       移到下一个单词</span><br><span class="line">^       移动到第一个非空白字符</span><br><span class="line">$       移动到最后一列</span><br><span class="line">g       移动到最后一个非空白字符</span><br><span class="line">%       匹配括号移动，包括 (, &#123;, [。 （把光标先移到括号上）</span><br><span class="line"></span><br><span class="line">*       移动光标到上一个匹配的单词</span><br><span class="line"></span><br><span class="line"><span class="comment">#       移动光标到下一个匹配的单词</span></span><br><span class="line">/pattern搜索   pattern的字符串（如果搜索出多个匹配，可按n键到下一个）</span><br></pre></td></tr></table></figure><p><strong>wc命令</strong></p><p>该命令用于统计指定文件中的字节数、字数、行数。该命令各选项含义如下：</p><p>-l 统计行数</p><p>-w 统计字数</p><p>-c 统计字节数</p><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。</p><p>行数、字数、字节数、文件名</p><p>如果命令行中没有文件名，则输出中不出现文件名。</p><p><strong>grep 命令</strong></p><p>grep是（global search regular expression(RE) and print out the line的缩写，用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被””引用，模板后的所有字符串被看作文件名。搜索结果送到屏幕，不影响原文件内容。</p><p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>示例：</p><p>$ ls -l | grep ‘^a’</p><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><p>$ grep ‘test’ d*</p><p>显示所有以d开头的文件中包含test的行。</p><p>$ grep ‘test’ aa bb cc</p><p>显示在aa，bb，cc文件中匹配test的行。</p><p>$ grep ‘[a-z]/{5/}’ aa</p><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><p>$ grep ‘w/(es/)t.*/1’ aa</p><p>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.<em>），这些字符后面紧跟着另外一个es（/1），找到就显示该行。如果用egrep或grep -E，就不用&quot;/&quot;号进行转义，直接写成’w(es)t.</em>/1’就可以了。</p><h4 id="进程操作-比肩程序员">进程操作 比肩程序员</h4><p><strong>nohup 挂起操作</strong></p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。</p><p>nohup command 或者 nohup command &amp;</p><p>这之间的差别是带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上）；</p><p><strong>tip: crl + z 可以切换当前进程到后台运行</strong></p><p><strong>ps 进程</strong></p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><ul><li>ps工具标识进程的5种状态码:</li></ul><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><ul><li>命令参数</li></ul><p>a 显示所有进程</p><p>-a 显示同一终端下的所有程序</p><p>-A 显示所有进程</p><p>c 显示进程的真实名称</p><p>-au 显示较详细的资讯</p><p>-aux 显示所有包含其他使用者的行程</p><ul><li>各相关信息的意义：</li></ul><p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p><p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p><p>UID 程序被该 UID 所拥有</p><p>PID 就是这个程序的 ID ！</p><p>PPID 则是其上级父程序的ID</p><p>C CPU 使用的资源百分比</p><p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p><p>SZ 使用掉的内存大小</p><p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p><p>TTY 登入者的终端机位置</p><p>TIME 使用掉的 CPU 时间。</p><p>CMD 所下达的指令为何</p><p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID</p><p><strong>kill</strong></p><p>Linux kill命令用于删除执行中的程序或工作。</p><p>彻底杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456(pid)</span><br></pre></td></tr></table></figure><p><strong>head，tail</strong></p><p>n head和tail命令 看log找错误改bug</p><p>都用于查看文本文件，区别在于： head显示文件的头n行，tail显示文件的尾n行，缺省情况n都为10行。可以通过-n方式指定行数，如：</p><p>head -100 file和tail -100 file分别表示显示文件头100行和尾100行内容。</p><p>n tail -f命令</p><p>可以实时查看文件新增内容。</p><h4 id="系统权限与磁盘管理操作-运维聊一聊">系统权限与磁盘管理操作 运维聊一聊</h4><p><strong>df disk free查看分区大小和占用情况</strong></p><p>-l 仅显示本地磁盘(默认）</p><p>-a 显示所有文件系统的磁盘使用情况，包含比如/proc/（查看包括0字节文件）</p><p>-h 以1024进制计算最合适的单位显示磁盘容量</p><p>-H 以1000进制计算最合适的单位显示磁盘容量</p><p>-T 显示磁盘分区类型（各个分区使用的文件系统）</p><p><strong>du disk usage统计磁盘上的文件大小</strong></p><p>-b 以byte为单位统计文件</p><p>-k 以KB为单位统计文件</p><p>-m 以MB为单位统计文件</p><p>-h 以1024进制计算最合适的单位统计文件</p><p>-H 以1000进制计算最合适的单位统计文件</p><p>-s 指定统计目标<br>第一 主分区和扩展分区总数不能超过4个<br>第二 扩展分区最多只能有一个<br>第三 扩展分区不能直接存取数据</p><p><strong>磁盘分区 fdisk</strong></p><ul><li>硬盘分区工具 &quot;fdisk&quot;命令</li></ul><p>使用fdisk分区需要跟一些参数</p><p>分区操作：</p><p>\0.fdisk -l 查看当前系统分区情况</p><p>1.fdisk /dev/sdb 进入分区模式 （fdisk 需要分区的磁盘设备名）</p><ol start="2"><li><p>输入 m 查看命令帮助信息</p></li><li><p>输入 n 添加分区</p></li></ol><p>p：主分区</p><p>e：扩展分区</p><p>l : 逻辑分区</p><p>设置起始和结束</p><p>大小 +数字[k, M, G]</p><p>\4. 输入 p 查看分配逻辑</p><p>\5. 输入 d 删除对应分区逻辑（删除是扩展分区的话，对应的逻辑分区也被删除）</p><p>\6. 输入 w 将分区逻辑实施并退出 fdisk命令</p><p>补充：在fdisk内部操作的分区操作，只是计划，只有当键入 w 时才会进行实际的分区</p><p><strong>chown</strong></p><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h4 id="计算机网络操作-神进化完成">计算机网络操作 *神进化完成</h4><p><strong>netstat 查看网络状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">    -t  列出TCP协议端口</span><br><span class="line">    -u  列出UDP协议端口</span><br><span class="line">    -n  不适用域名与服务名，而使用IP地址和端口号</span><br><span class="line">    -l  仅列出在监听状态网络服务</span><br><span class="line">    -a  列出所有的网络连接</span><br><span class="line">    -r  列出路由列表，功能和route命令一致</span><br><span class="line">    常用：-tuln –an –rn</span><br></pre></td></tr></table></figure><p><strong>route</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">route</span> –<span class="selector-tag">n</span> 查看路由列表（可以看到网关） <span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">default</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 临时设定网关</span><br></pre></td></tr></table></figure><p><strong>ifconfig 关闭与启动网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdown 网卡设备名</span><br><span class="line">    禁用该网卡设备</span><br><span class="line">ifup 网卡设备名</span><br><span class="line">    启用该网卡设备</span><br></pre></td></tr></table></figure><p><strong>nslookup 域名解析命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nslookup</span> <span class="selector-attr">[主机名或IP]</span> 进行域名与<span class="selector-tag">IP</span>地址解析 <span class="selector-tag">nslookup</span>&gt;<span class="selector-tag">server</span> 查看本机<span class="selector-tag">DNS</span>服务器</span><br></pre></td></tr></table></figure><p><strong>ping 网络测试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ping</span> <span class="selector-attr">[选项]</span> <span class="selector-tag">ip</span>或域名 探测指定<span class="selector-tag">IP</span>或域名的网络状况 <span class="selector-tag">-c</span> 次数：指定<span class="selector-tag">ping</span>报的次数</span><br></pre></td></tr></table></figure><p><strong>SSH 远程连接</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH命令</span><br><span class="line">    ssh 用户名<span class="meta">@ip</span></span><br><span class="line">        远程管理指定Linux服务器</span><br><span class="line">    scp [-r] 用户名<span class="meta">@ip</span>:文件路径 本地路径</span><br><span class="line">        下载文件到本地</span><br><span class="line">    scp [-r] 本地文件 用户名<span class="meta">@ip</span>:上传路径</span><br><span class="line">        上传文件到远程服务器</span><br></pre></td></tr></table></figure><p><strong>traceroute追踪</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-attr">[xuanxiang]</span> <span class="selector-tag">IP</span>或域名 路由跟踪命令 <span class="selector-tag">-n</span> 使用<span class="selector-tag">IP</span>，不使用域名，速度更快</span><br></pre></td></tr></table></figure><h4 id="curl-wget-必杀操作">curl wget 必杀操作</h4><p>当想要直接通过 [Linux] 命令行下载文件，马上就能想到两个工具：wget 和 cURL。它们有很多一样的特征，可以很轻易的完成一些相同的任务，虽然它们有一些相似的特征，但它们并不是完全一样。这两个程序适用与不同的场合，在特定场合下，都拥有各自的特性。</p><p>wget 和 cURL 都可以下载内容。它们的核心就是这么设计的。它们都可以向互联网发送请求并返回请求项。这可以是文件、图片或者是其他诸如网站的原始 HTML 之类。</p><p>这两个程序都可以进行 HTTP POST 请求。这意味着它们都可以向网站发送数据，比如说填充表单什么的。</p><p>由于这两者都是命令行工具，它们都被设计成可脚本化。wget 和 cURL 都可以写进你的 Bash 脚本 ，自动与新内容交互，下载所需内容。</p><p>wget 简单直接。这意味着你能享受它超凡的下载速度。wget 是一个独立的程序，无需额外的资源库，更不会做其范畴之外的事情。</p><p>wget 是专业的直接下载程序，支持递归下载。同时，它也允许你下载网页中或是 FTP 目录中的任何内容。</p><p>wget 拥有智能的默认设置。它规定了很多在常规浏览器里的事物处理方式，比如 cookies 和重定向，这都不需要额外的配置。可以说，wget 简直就是无需说明，开罐即食！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//soft.vpser.net/lnmp/lnmp1.1-full.tar.gz</span></span><br><span class="line">    下载命令</span><br></pre></td></tr></table></figure><p>cURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。</p><p>cURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。</p><p>cURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。</p><p>cURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。</p><p>cURL 同样支持让数据发送变得更容易的 gzip 压缩技术。</p><p>那你应该使用 cURL 还是使用 wget？这个比较得看实际用途。如果你想快速下载并且没有担心参数标识的需求，那你应该使用轻便有效的 wget。如果你想做一些更复杂的使用，直觉告诉你，你应该选择 cRUL。</p><p>cURL 支持你做很多事情。你可以把 cURL 想象成一个精简的命令行网页浏览器。它支持几乎你能想到的所有协议，可以交互访问几乎所有在线内容。唯一和浏览器不同的是，cURL 不会渲染接收到的相应信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演&lt;/p&gt;
&lt;h4 id=&quot;常规操作-小试牛刀&quot;&gt;常规操作 小试牛刀&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ls: 类似于dos下的dir命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ls最常用的参数有三个：
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://wuhewuhe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://wuhewuhe.github.io/tags/linux/"/>
    
      <category term="file" scheme="https://wuhewuhe.github.io/tags/file/"/>
    
      <category term="net" scheme="https://wuhewuhe.github.io/tags/net/"/>
    
      <category term="process" scheme="https://wuhewuhe.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>interface and class</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/interface-and-class/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/interface-and-class/</id>
    <published>2020-02-12T18:53:37.000Z</published>
    <updated>2020-02-12T18:55:50.013Z</updated>
    
    <content type="html"><![CDATA[<p>interface</p><p>contains parameter and method</p><p>method par default is public abstract, we can not concerate but since java 8, default</p><p>parameter par default is public static final</p><p>a interface can extends multi interface, but it should realise all of the parment methods</p><p>abstract class</p><p>abstract class can concentrate method and contains various type : public private static</p><p>abstract class can have static method</p><p>hériter only one class</p><p>1、抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。</p><p>2、当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</p><p>3、当注重代码的扩展性跟可维护性时，应当优先采用接口。①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活; ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;contains parameter and method&lt;/p&gt;
&lt;p&gt;method par default is public abstract, we can not concerate but since java 8, defau
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Java/Interview/"/>
    
    
      <category term="interface" scheme="https://wuhewuhe.github.io/tags/interface/"/>
    
      <category term="class" scheme="https://wuhewuhe.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>hashcode, equals区别与联系</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/hashcode-equal/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/hashcode-equal/</id>
    <published>2020-02-12T07:05:28.000Z</published>
    <updated>2020-02-15T17:44:59.644Z</updated>
    
    <content type="html"><![CDATA[<p>有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。下面我们一起来看一下，它们到底有什么区别，总结一波！</p><p>01、hashCode介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.hashCode());}</code></pre><p>}<br>通过调用hashCode()方法获取对象的hash值。</p><p>02、equals介绍<br>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.equals(obj));}</code></pre><p>}<br>03、hashCode() 和 equals() 有什么关系？<br>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我们梳理了一下 “hashCode() 和 equals()的关系”。我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><p>3.1、不会创建“类对应的散列表”<br>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</p><p>equals() 用来比较该类的两个对象是否相等，而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 举个例子</p><p>public class DemoNormalTest {</p><pre><code>public static void main(String[] args) {// 新建2个相同内容的Person对象，// 再用equals比较它们是否相等Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>p1.equals(p3) : false; p1(2018699554) p3(1735600054)<br>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><p>3.2、会创建“类对应的散列表”<br>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的:</p><p>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。<br>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。<br>举个例子</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，    Person p1 = new Person(&quot;eee&quot;, 100);    Person p2 = new Person(&quot;eee&quot;, 100);    Person p3 = new Person(&quot;aaa&quot;, 200);    // 新建HashSet对象     HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();    set.add(p1);    set.add(p2);    set.add(p3);    // 比较p1 和 p2， 并打印它们的hashCode()    System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());     // 打印set    System.out.printf(&quot;set:%s\n&quot;, set); }private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>set:[(eee, 100), (aaa, 200), (eee, 100)]<br>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>举个例子，我们同时覆盖equals() 和 hashCode()方法。</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);Person p4 = new Person(&quot;EEE&quot;, 100);// 新建HashSet对象HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();set.add(p1);set.add(p2);set.add(p3);set.add(p4);// 比较p1 和 p2， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());// 比较p1 和 p4， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());// 打印setSystem.out.printf(&quot;set:%s\n&quot;, set);}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot; + name + &quot;, &quot; + age + &quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}/** * 重写hashCode方法 */@Overridepublic int hashCode() {int nameHash = name.toUpperCase().hashCode();return nameHash ^ age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(68545) p2(68545)<br>p1.equals(p4) : false; p1(68545) p4(68545)<br>set:[(eee, 100), (EEE, 100), (aaa, 200)]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="hashcode" scheme="https://wuhewuhe.github.io/tags/hashcode/"/>
    
      <category term="equals" scheme="https://wuhewuhe.github.io/tags/equals/"/>
    
  </entry>
  
  <entry>
    <title>set家族的对比</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/</id>
    <published>2020-02-12T06:57:33.000Z</published>
    <updated>2020-02-12T07:04:04.558Z</updated>
    
    <content type="html"><![CDATA[<p>Set接口<br>Set 接口与 List 接口相比没有那么多操作方法，比如：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><p>对比一下Set接口和Collection接口就知道，其实Set接口仅仅对Collection所有方法进行继承而已，而自己没有扩展任何方法，Set接口与Collection接口一样，都是15个方法。</p><img src="/2020/02/12/set-hashset-treeset-linkedset/set.jpg" alt="set" style="zoom:100%; ">Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。这里说的相同元素指的是用 equals() 方法比价后返回 true，当然了如果用 == 也返回true，那肯定也是相同的。一. HashSet特点：<ol><li><p>HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是无序的。</p></li><li><p>HashSet如何保证唯一性？</p></li></ol><p>1). HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2). 确保唯一性的两个方法：hashCode()和equals()方法。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>二. LinkedHashSet<br>特点：</p><ol><li><p>LinkedHashSet中不能有相同元素，可以有一个Null元素，元素严格按照放入的顺序排列。</p></li><li><p>LinkedHashSet如何保证有序和唯一性？</p></li></ol><p>1). 底层数据结构由哈希表和链表组成。</p><p>2). 链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>三. TreeSet<br>特点：</p><ol><li><p>TreeSet是中不能有相同元素，不可以有Null元素，根据元素的自然顺序进行排序。</p></li><li><p>TreeSet如何保证元素的排序和唯一性？</p></li></ol><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(log(n))</p></li><li><p>非线程安全</p></li></ol><p>四. 总结：<br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Set接口&lt;br&gt;
Set 接口与 List 接口相比没有那么多操作方法，比如：&lt;/p&gt;
&lt;p&gt;1、List 接口能直接设置或获取某个元素的值，而Set接口不能。&lt;/p&gt;
&lt;p&gt;2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。&lt;/p&gt;
&lt;p&gt;3、List
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
      <category term="Set" scheme="https://wuhewuhe.github.io/categories/Java/Collections/Set/"/>
    
    
      <category term="hashset" scheme="https://wuhewuhe.github.io/tags/hashset/"/>
    
      <category term="linkedhashset" scheme="https://wuhewuhe.github.io/tags/linkedhashset/"/>
    
      <category term="treeset" scheme="https://wuhewuhe.github.io/tags/treeset/"/>
    
  </entry>
  
  <entry>
    <title>讲清楚Vector vs ArrayList vs LinkedList</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/</id>
    <published>2020-02-11T20:10:29.000Z</published>
    <updated>2020-02-11T20:22:35.670Z</updated>
    
    <content type="html"><![CDATA[<p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></li><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></li><li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p></li><li><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p></li><li><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p></li><li><p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p></li><li><p>笼统来说：LinkedList：增删改快，ArrayList：查询快（有索引的存在）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ArrayLis
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
    
      <category term="vector" scheme="https://wuhewuhe.github.io/tags/vector/"/>
    
      <category term="arraylist" scheme="https://wuhewuhe.github.io/tags/arraylist/"/>
    
      <category term="linkedlist" scheme="https://wuhewuhe.github.io/tags/linkedlist/"/>
    
  </entry>
  
</feed>
