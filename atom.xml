<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>He WU</title>
  
  <subtitle>stay hungry, stay foolish, never give up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhewuhe.github.io/"/>
  <updated>2020-02-15T17:45:22.884Z</updated>
  <id>https://wuhewuhe.github.io/</id>
  
  <author>
    <name>WU He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SOLID Object Orient Programming pinciples</title>
    <link href="https://wuhewuhe.github.io/2020/02/15/solid/"/>
    <id>https://wuhewuhe.github.io/2020/02/15/solid/</id>
    <published>2020-02-15T17:41:04.000Z</published>
    <updated>2020-02-15T17:45:22.884Z</updated>
    
    <content type="html"><![CDATA[<p>this is 5 pinciple of object-oriented programming</p><p>In object-oriented computer programming, <strong>SOLID</strong> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.</p><ul><li>s = single respoonsibilty principle</li></ul><p>a class should have a single responsibility, one part of software’s specification should be able to affect the specification of class</p><ul><li>open close principle</li></ul><p>Software class should be opened for extension but closed for modifications</p><ul><li>Liskov</li></ul><p>Object in a program should be replaced with instance of their subtype without correctness of that program</p><ul><li>interface segergation</li></ul><p>many client specific interface are better than one general purpose interface</p><ul><li>dependency inversion</li></ul><p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p><h4 id="single-responsibility">single responsibility</h4><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p><p><strong>example</strong></p><p>First, we create our shapes classes and have the constructors setup the required parameters. Next, we move on by creating the <strong>AreaCalculator</strong> class and then write up our logic to sum up the areas of all provided shapes.</p><p>To use the <strong>AreaCalculator</strong> class, we simply instantiate the class and pass in an array of shapes, and display the output at the bottom of the page.</p><p>All of that logic would be handled by the <strong>AreaCalculator</strong> class, this is what SRP frowns against; the <strong>AreaCalculator</strong> class should only sum the areas of provided shapes, it should not care whether the user wants json or HTML.</p><p>Now, whatever logic you need to output the data to the user is now handled by the <strong>SumCalculatorOutputter</strong> class.</p><h4 id="open-closed-principle">open-closed principle</h4><p>This simply means that a class should be easily extendable without modifying the class itself. Let’s take a look at the <strong>AreaCalculator</strong> class, especially it’s <strong>sum</strong> method.</p><p>If we wanted the <strong>sum</strong> method to be able to sum the areas of more shapes, we would have to add more <strong>if/else blocks</strong> and that goes against the Open-closed principle.</p><p>A way we can make this <strong>sum</strong> method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape’s class.</p><p>The same thing should be done for the <strong>Circle</strong> class, an <strong>area</strong> method should be added. Now, to calculate the sum of any shape provided should be as simple as:</p><p>Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the <strong>AreaCalculator</strong> is actually a shape or if the shape has a method named <strong>area</strong>?</p><p>Coding to an interface is an integral part of <strong>S. O. L. I. D</strong>, a quick example is we create an interface, that every shape implements:</p><p>In our <strong>AreaCalculator</strong> sum method we can check if the shapes provided are actually instances of the <strong>ShapeInterface</strong>, otherwise we throw an exception:</p><h4 id="Liskoc-substitution-principle">Liskoc substitution principle</h4><p>Next up on our list is Liskov substitution, which is arguably the most complex of the 5 principles. Simply put, <strong>if class *A* is a subtype of class *B*, then we should be able to replace *B* with *A* without disrupting the behavior of our program.</strong></p><h4 id="interface-segregation">interface segregation</h4><p><strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we can add another contract to the <strong>ShapeInterface</strong>:</p><p>Any shape we create must implement the <strong>volume</strong> method, but we know that squares are flat shapes and that they do not have volumes, so this interface would force the <strong>Square</strong> class to implement a method that it has no use of.</p><p><strong>ISP</strong> says no to this, instead you could create another interface called <strong>SolidShapeInterface</strong> that has the <strong>volume</strong> contract and solid shapes like cubes e.t.c can implement this interface:</p><p>This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead of using a <strong>ShapeInterface</strong> or a <strong>SolidShapeInterface</strong>.</p><p>You can create another interface, maybe <strong>ManageShapeInterface</strong>, and implement it on both the flat and solid shapes, this way you can easily see that it has a single API for managing the shapes. For example:</p><p>Now in <strong>AreaCalculator</strong> class, we can easily replace the call to the <strong>area</strong> method with <strong>calculate</strong> and also check if the object is an instance of the <strong>ManageShapeInterface</strong> and not the <strong>ShapeInterface</strong>.</p><h4 id="dependecy-inversion">dependecy inversion</h4><p><strong>The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.</strong></p><p>this principle realise the open-close displicine, which means that we don’t need to concentrate which is the shape type exactly, because each shape has his own area and we can call it by the abstraction class.</p><p><strong>in the last, you can find my code in attchement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square s &#x3D; new Square(&quot;square&quot;, 1);</span><br><span class="line">Circle c &#x3D; new Circle(&quot;circle&quot;, 1);</span><br><span class="line">Shapes[] ss &#x3D; &#123; s, c &#125;;</span><br><span class="line">CalculatorArea ca &#x3D; new CalculatorArea(ss);</span><br><span class="line">System.out.println(ca.sumShapes());</span><br><span class="line">FormatOutputter fo &#x3D; new FormatOutputter(formatter.HTML, ca);</span><br><span class="line">fo.transfer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class CalculatorArea &#123;</span><br><span class="line">private Shapes[] shapes;</span><br><span class="line"></span><br><span class="line">public CalculatorArea(Shapes[] shapes) &#123;</span><br><span class="line">this.shapes &#x3D; shapes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.area();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int volumeShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.volume();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shapes &#123;</span><br><span class="line">private int radius;</span><br><span class="line"></span><br><span class="line">public Circle(String name, int radius) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getRadius() &#123;</span><br><span class="line">return radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return (int) (Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) (Math.PI * radius * 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class FormatOutputter &#123;</span><br><span class="line">private CalculatorArea ca;</span><br><span class="line">private formatter format;</span><br><span class="line"></span><br><span class="line">public FormatOutputter(formatter format, CalculatorArea ca) &#123;</span><br><span class="line">this.format &#x3D; format;</span><br><span class="line">this.ca &#x3D; ca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer() &#123;</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case JSON:</span><br><span class="line">System.out.println(&quot;json transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case HTML:</span><br><span class="line">System.out.println(&quot;html transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case TXT:</span><br><span class="line">System.out.println(&quot;txt transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case XML:</span><br><span class="line">System.out.println(&quot;xml transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public enum formatter &#123;</span><br><span class="line">XML, JSON, TXT, HTML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeInterface &#123;</span><br><span class="line">int area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public abstract class Shapes implements ShapeInterface, ShapeVolumInterface &#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Shapes(String name) &#123;</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeVolumInterface &#123;</span><br><span class="line">int volume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Square extends Shapes &#123;</span><br><span class="line">private int length;</span><br><span class="line"></span><br><span class="line">public Square(String name, int length) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return length * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) Math.pow(length, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this is 5 pinciple of object-oriented programming&lt;/p&gt;
&lt;p&gt;In object-oriented computer programming, &lt;strong&gt;SOLID&lt;/strong&gt; is a mnemonic ac
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="solid" scheme="https://wuhewuhe.github.io/tags/solid/"/>
    
      <category term="oop" scheme="https://wuhewuhe.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>装*必备的linux命令</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/linux-command/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/linux-command/</id>
    <published>2020-02-12T18:56:25.000Z</published>
    <updated>2020-02-15T17:47:02.956Z</updated>
    
    <content type="html"><![CDATA[<p>当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演</p><h4 id="常规操作-小试牛刀">常规操作 小试牛刀</h4><p><strong>ls: 类似于dos下的dir命令</strong></p><p>ls最常用的参数有三个： -a -l -F。</p><p>ls –a</p><p>Linux上的文件以. 开头的文件被系统视为隐藏文件，仅用ls命令是看不到他们的，而用ls -a除了显示一般文件名外，连隐藏文件也会显示出来。</p><p>ls –l</p><p>该参数显示更详细的文件信息。</p><p>ls –F</p><p>使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。但是现在基本上所有的Linux发行版本的ls都已经内建了-F参数，也就是说，不用输入这个参数，我们也能看到各种分辨符号。</p><p><strong>cd: 用于切换用户当前工作目录</strong></p><p>cd aaa 进入aaa目录</p><p>cd 命令后不指定目录，会切换到当前用户的home 目录</p><p>cd ~ 作用同cd后不指定目录，切换到当前用户的home 目录</p><p>cd - 命令后跟一个减号，则会退回到切换前的目录</p><p>cd … 返回到当前目录下的上一级目录</p><p><strong>pwd：用于显示用户当前工作目录</strong></p><p><strong>mkdir 和 rmdir</strong></p><p>midir: 创建目录 rmdir: 删除目录</p><p>两个命令都支持-p参数，对于mkdir命令若指定路径的父目录不存在则一并创建，对于rmdir命令则删除指定路径的所有层次目录，如果文件夹里有内容，则不能用rmdir命令</p><p>如下：</p><p>mkdir -p 1/2/3</p><p>rmdir -p 1/2/3</p><p><strong>tar 打包压缩与解压缩</strong></p><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2</a>命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file&#x3D;&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br></pre></td></tr></table></figure><p><strong>将文件全部打包成tar包</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！ </span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure><p>在选项 <code>f</code> 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 <code>z</code> 选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加 <code>j</code> 选项，则以.tar.bz2来作为tar包名。</p><p><strong>查阅上述tar包内有哪些文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 <code>z</code> 这个选项了。</p><p><strong>将tar包解压缩</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;opt&#x2F;soft&#x2F;test&#x2F;log.tar.gz</span><br></pre></td></tr></table></figure><h4 id="文件操作-装-的核心操作">文件操作 装*的核心操作</h4><p><strong>touch</strong></p><p>inux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令&quot;touch&quot;修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure><p><strong>cp：复制命令</strong></p><p>复制一个文件到另一目录：cp 1.txt …/test2</p><p>复制一个文件到本目录并改名：cp 1.txt 2.txt</p><p>复制一个文件夹a并改名为b：cp -r a b</p><p><strong>mv：移动命令</strong></p><p>将一个文件移动到另一个目录：mv 1.txt …/test1</p><p>将一个文件在本目录改名：mv 1.txt 2.txt</p><p>将一个文件一定到另一个目录并改名：mv 1.txt …/test1/2.txt</p><p><strong>rm命令</strong></p><p>rm命令用于删除文件，与dos下的del/erase命令相似，rm命令常用的参数有三个：-i，-r，-f。</p><p>–i ：系统在删除文件之前会先询问确认，用户回车之后，文件才会真的被删除。需要注意，linux下删除的文件是不能恢复的，删除之前一定要谨慎确认。</p><p>–r：该参数支持目录删除，功能和rmdir命令相似。</p><p>–f：和-i参数相反，-f表示强制删除</p><p><strong>cat命令</strong></p><p>cat命令的功能是显示或连结一般的ascii文本文件。cat是concatenate的简写，类似于dos下面的type命令。用法如下：</p><p>cat file1 显示file1文件内容</p><p>cat file1 file2 依次显示file1, file2的内容</p><p>cat file1 file2 &gt; file3 把file1, file2的内容结合起来，再“重定向（&gt;）”到file3文件中。</p><p>&quot;&gt;“是右重定向符，表示将左边命令结果当成右边命令的输入，注意：如果右侧文件是一个已存在文件，其原有内容将会被清空，而变成左侧命令输出内容。如果希望以追加方式写入，请改用”&gt;&gt;&quot;重定向符。</p><p>如果&quot;&gt;&quot;左边没有指定文件，如： cat &gt;file1，将会等用户输入，输入完毕后再按[Ctrl]+[c]或[Ctrl]+[d]，就会将用户的输入内容写入file1。</p><p><strong>echo命令</strong></p><p>echo命令的使用频率不少于ls和cat，尤其是在shell脚本编写中。</p><p>语法：echo [-ne][字符串]</p><p>功能：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开， 并在最后加上换行符。</p><p>参数：</p><p>-n 显示字串时在最后自动换行</p><p>-e 支持以下格式的转义字符， -E 不支持以下格式的转义字符</p><p>/a 发出警告声；</p><p>/b 删除前一个字符；</p><p>/c 最后不加上换行符号；</p><p>/f 换行但光标仍旧停留在原来的位置；</p><p>/n 换行且光标移至行首；</p><p>/r 光标移至行首，但不换行；</p><p>/t 插入tab；</p><p>/v 与/f相同；</p><p>// 插入/字符；</p><p><strong>more，less，clear</strong></p><p>n more，less命令</p><p>这两个命令用于查看文件，如果一个文件太长，显示内容超出一个屏幕，用cat命令只能看到最后的内容，用more和less两个命令可以分页查看。more指令可以使超过一页的文件内容分页暂停显示，用户按键后才继续显示下一页。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，更方便浏览阅读。</p><p>less的常用动作命令：</p><p>回车键 向下移动一行；</p><p>y 向上移动一行；</p><p>空格键 向下滚动一屏；</p><p>b 向上滚动一屏；</p><p>d 向下滚动半屏；</p><p>h less的帮助；</p><p>u 向上洋动半屏；</p><p>w 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示；</p><p>g 跳到第一行；</p><p>G 跳到最后一行；</p><p>p n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示；</p><p>/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词；</p><p>v 调用vi编辑器；</p><p>q 退出less</p><p>!command 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</p><p>n clear命令</p><p>clear命令是用来清除当前屏幕显示的，不需任何参数，和dos下的cls命令功能相同。</p><h4 id="读写操作-装-境界更上一层楼">读写操作 装*境界更上一层楼</h4><p><strong>vim 高级文本编辑器</strong></p><p>Vim 经常被认为是 “程序员的编辑器”, 它在程序编写时非常有用，很多人认为它是一个完整的集成开发环境(IDE)。仅管如此，Vim并不只是程序员使用的。Vim可以用于多种文档编辑，从email排版到配置文件编写。</p><p><strong>编辑模式</strong>（Normal）：执行命令，也称为正常模式<br>**插入模式 **（Insert）：输入文本<br><strong>命令模式</strong>：执行 <strong>冒号</strong> 命令</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>按下键 i ，进入 <em>Insert</em> 模式（ 这时候，你可以输入文本）</li><li>按 ESC键，就可退回到<em>Normal</em> 模式下</li></ul><p>在Normal下基本命令操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">Insert</span> 模式，按 <span class="selector-tag">ESC</span>回到 <span class="selector-tag">Normal</span>模式。 <span class="selector-tag">x</span> 删当前光标所在的一个字符。<span class="selector-pseudo">:wq</span> 存盘+退出 (<span class="selector-pseudo">:w</span>存盘, <span class="selector-pseudo">:q</span>退出) （注<span class="selector-pseudo">:w</span> 后可以跟文件名）<span class="selector-pseudo">:q</span> ! 不保存退出 <span class="selector-tag">Shift</span>+<span class="selector-tag">ZZ</span> 退出本文档 <span class="selector-tag">dd</span> 删除当前行，并把删除的行存到剪贴板里 <span class="selector-tag">p</span> 粘贴剪贴板<span class="selector-pseudo">:help</span> 显示相关命令的帮助（<span class="selector-pseudo">:q</span> 退出帮助） 移动光标 <span class="selector-tag">hjkl</span> (←↓↑→)</span><br></pre></td></tr></table></figure><p>简单的光标移动命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       当前行第一列</span><br><span class="line">w       移到下一个单词</span><br><span class="line">^       移动到第一个非空白字符</span><br><span class="line">$       移动到最后一列</span><br><span class="line">g       移动到最后一个非空白字符</span><br><span class="line">%       匹配括号移动，包括 (, &#123;, [。 （把光标先移到括号上）</span><br><span class="line"></span><br><span class="line">*       移动光标到上一个匹配的单词</span><br><span class="line"></span><br><span class="line"><span class="comment">#       移动光标到下一个匹配的单词</span></span><br><span class="line">/pattern搜索   pattern的字符串（如果搜索出多个匹配，可按n键到下一个）</span><br></pre></td></tr></table></figure><p><strong>wc命令</strong></p><p>该命令用于统计指定文件中的字节数、字数、行数。该命令各选项含义如下：</p><p>-l 统计行数</p><p>-w 统计字数</p><p>-c 统计字节数</p><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。</p><p>行数、字数、字节数、文件名</p><p>如果命令行中没有文件名，则输出中不出现文件名。</p><p><strong>grep 命令</strong></p><p>grep是（global search regular expression(RE) and print out the line的缩写，用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被””引用，模板后的所有字符串被看作文件名。搜索结果送到屏幕，不影响原文件内容。</p><p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>示例：</p><p>$ ls -l | grep ‘^a’</p><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><p>$ grep ‘test’ d*</p><p>显示所有以d开头的文件中包含test的行。</p><p>$ grep ‘test’ aa bb cc</p><p>显示在aa，bb，cc文件中匹配test的行。</p><p>$ grep ‘[a-z]/{5/}’ aa</p><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><p>$ grep ‘w/(es/)t.*/1’ aa</p><p>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.<em>），这些字符后面紧跟着另外一个es（/1），找到就显示该行。如果用egrep或grep -E，就不用&quot;/&quot;号进行转义，直接写成’w(es)t.</em>/1’就可以了。</p><h4 id="进程操作-比肩程序员">进程操作 比肩程序员</h4><p><strong>nohup 挂起操作</strong></p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。</p><p>nohup command 或者 nohup command &amp;</p><p>这之间的差别是带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上）；</p><p><strong>tip: crl + z 可以切换当前进程到后台运行</strong></p><p><strong>ps 进程</strong></p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><ul><li>ps工具标识进程的5种状态码:</li></ul><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><ul><li>命令参数</li></ul><p>a 显示所有进程</p><p>-a 显示同一终端下的所有程序</p><p>-A 显示所有进程</p><p>c 显示进程的真实名称</p><p>-au 显示较详细的资讯</p><p>-aux 显示所有包含其他使用者的行程</p><ul><li>各相关信息的意义：</li></ul><p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p><p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p><p>UID 程序被该 UID 所拥有</p><p>PID 就是这个程序的 ID ！</p><p>PPID 则是其上级父程序的ID</p><p>C CPU 使用的资源百分比</p><p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p><p>SZ 使用掉的内存大小</p><p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p><p>TTY 登入者的终端机位置</p><p>TIME 使用掉的 CPU 时间。</p><p>CMD 所下达的指令为何</p><p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID</p><p><strong>kill</strong></p><p>Linux kill命令用于删除执行中的程序或工作。</p><p>彻底杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456(pid)</span><br></pre></td></tr></table></figure><p><strong>head，tail</strong></p><p>n head和tail命令 看log找错误改bug</p><p>都用于查看文本文件，区别在于： head显示文件的头n行，tail显示文件的尾n行，缺省情况n都为10行。可以通过-n方式指定行数，如：</p><p>head -100 file和tail -100 file分别表示显示文件头100行和尾100行内容。</p><p>n tail -f命令</p><p>可以实时查看文件新增内容。</p><h4 id="系统权限与磁盘管理操作-运维聊一聊">系统权限与磁盘管理操作 运维聊一聊</h4><p><strong>df disk free查看分区大小和占用情况</strong></p><p>-l 仅显示本地磁盘(默认）</p><p>-a 显示所有文件系统的磁盘使用情况，包含比如/proc/（查看包括0字节文件）</p><p>-h 以1024进制计算最合适的单位显示磁盘容量</p><p>-H 以1000进制计算最合适的单位显示磁盘容量</p><p>-T 显示磁盘分区类型（各个分区使用的文件系统）</p><p><strong>du disk usage统计磁盘上的文件大小</strong></p><p>-b 以byte为单位统计文件</p><p>-k 以KB为单位统计文件</p><p>-m 以MB为单位统计文件</p><p>-h 以1024进制计算最合适的单位统计文件</p><p>-H 以1000进制计算最合适的单位统计文件</p><p>-s 指定统计目标<br>第一 主分区和扩展分区总数不能超过4个<br>第二 扩展分区最多只能有一个<br>第三 扩展分区不能直接存取数据</p><p><strong>磁盘分区 fdisk</strong></p><ul><li>硬盘分区工具 &quot;fdisk&quot;命令</li></ul><p>使用fdisk分区需要跟一些参数</p><p>分区操作：</p><p>\0.fdisk -l 查看当前系统分区情况</p><p>1.fdisk /dev/sdb 进入分区模式 （fdisk 需要分区的磁盘设备名）</p><ol start="2"><li><p>输入 m 查看命令帮助信息</p></li><li><p>输入 n 添加分区</p></li></ol><p>p：主分区</p><p>e：扩展分区</p><p>l : 逻辑分区</p><p>设置起始和结束</p><p>大小 +数字[k, M, G]</p><p>\4. 输入 p 查看分配逻辑</p><p>\5. 输入 d 删除对应分区逻辑（删除是扩展分区的话，对应的逻辑分区也被删除）</p><p>\6. 输入 w 将分区逻辑实施并退出 fdisk命令</p><p>补充：在fdisk内部操作的分区操作，只是计划，只有当键入 w 时才会进行实际的分区</p><p><strong>chown</strong></p><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h4 id="计算机网络操作-神进化完成">计算机网络操作 *神进化完成</h4><p><strong>netstat 查看网络状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">    -t  列出TCP协议端口</span><br><span class="line">    -u  列出UDP协议端口</span><br><span class="line">    -n  不适用域名与服务名，而使用IP地址和端口号</span><br><span class="line">    -l  仅列出在监听状态网络服务</span><br><span class="line">    -a  列出所有的网络连接</span><br><span class="line">    -r  列出路由列表，功能和route命令一致</span><br><span class="line">    常用：-tuln –an –rn</span><br></pre></td></tr></table></figure><p><strong>route</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">route</span> –<span class="selector-tag">n</span> 查看路由列表（可以看到网关） <span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">default</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 临时设定网关</span><br></pre></td></tr></table></figure><p><strong>ifconfig 关闭与启动网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdown 网卡设备名</span><br><span class="line">    禁用该网卡设备</span><br><span class="line">ifup 网卡设备名</span><br><span class="line">    启用该网卡设备</span><br></pre></td></tr></table></figure><p><strong>nslookup 域名解析命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nslookup</span> <span class="selector-attr">[主机名或IP]</span> 进行域名与<span class="selector-tag">IP</span>地址解析 <span class="selector-tag">nslookup</span>&gt;<span class="selector-tag">server</span> 查看本机<span class="selector-tag">DNS</span>服务器</span><br></pre></td></tr></table></figure><p><strong>ping 网络测试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ping</span> <span class="selector-attr">[选项]</span> <span class="selector-tag">ip</span>或域名 探测指定<span class="selector-tag">IP</span>或域名的网络状况 <span class="selector-tag">-c</span> 次数：指定<span class="selector-tag">ping</span>报的次数</span><br></pre></td></tr></table></figure><p><strong>SSH 远程连接</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH命令</span><br><span class="line">    ssh 用户名<span class="meta">@ip</span></span><br><span class="line">        远程管理指定Linux服务器</span><br><span class="line">    scp [-r] 用户名<span class="meta">@ip</span>:文件路径 本地路径</span><br><span class="line">        下载文件到本地</span><br><span class="line">    scp [-r] 本地文件 用户名<span class="meta">@ip</span>:上传路径</span><br><span class="line">        上传文件到远程服务器</span><br></pre></td></tr></table></figure><p><strong>traceroute追踪</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-attr">[xuanxiang]</span> <span class="selector-tag">IP</span>或域名 路由跟踪命令 <span class="selector-tag">-n</span> 使用<span class="selector-tag">IP</span>，不使用域名，速度更快</span><br></pre></td></tr></table></figure><h4 id="curl-wget-必杀操作">curl wget 必杀操作</h4><p>当想要直接通过 [Linux] 命令行下载文件，马上就能想到两个工具：wget 和 cURL。它们有很多一样的特征，可以很轻易的完成一些相同的任务，虽然它们有一些相似的特征，但它们并不是完全一样。这两个程序适用与不同的场合，在特定场合下，都拥有各自的特性。</p><p>wget 和 cURL 都可以下载内容。它们的核心就是这么设计的。它们都可以向互联网发送请求并返回请求项。这可以是文件、图片或者是其他诸如网站的原始 HTML 之类。</p><p>这两个程序都可以进行 HTTP POST 请求。这意味着它们都可以向网站发送数据，比如说填充表单什么的。</p><p>由于这两者都是命令行工具，它们都被设计成可脚本化。wget 和 cURL 都可以写进你的 Bash 脚本 ，自动与新内容交互，下载所需内容。</p><p>wget 简单直接。这意味着你能享受它超凡的下载速度。wget 是一个独立的程序，无需额外的资源库，更不会做其范畴之外的事情。</p><p>wget 是专业的直接下载程序，支持递归下载。同时，它也允许你下载网页中或是 FTP 目录中的任何内容。</p><p>wget 拥有智能的默认设置。它规定了很多在常规浏览器里的事物处理方式，比如 cookies 和重定向，这都不需要额外的配置。可以说，wget 简直就是无需说明，开罐即食！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//soft.vpser.net/lnmp/lnmp1.1-full.tar.gz</span></span><br><span class="line">    下载命令</span><br></pre></td></tr></table></figure><p>cURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。</p><p>cURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。</p><p>cURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。</p><p>cURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。</p><p>cURL 同样支持让数据发送变得更容易的 gzip 压缩技术。</p><p>那你应该使用 cURL 还是使用 wget？这个比较得看实际用途。如果你想快速下载并且没有担心参数标识的需求，那你应该使用轻便有效的 wget。如果你想做一些更复杂的使用，直觉告诉你，你应该选择 cRUL。</p><p>cURL 支持你做很多事情。你可以把 cURL 想象成一个精简的命令行网页浏览器。它支持几乎你能想到的所有协议，可以交互访问几乎所有在线内容。唯一和浏览器不同的是，cURL 不会渲染接收到的相应信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演&lt;/p&gt;
&lt;h4 id=&quot;常规操作-小试牛刀&quot;&gt;常规操作 小试牛刀&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ls: 类似于dos下的dir命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ls最常用的参数有三个：
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://wuhewuhe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://wuhewuhe.github.io/tags/linux/"/>
    
      <category term="file" scheme="https://wuhewuhe.github.io/tags/file/"/>
    
      <category term="net" scheme="https://wuhewuhe.github.io/tags/net/"/>
    
      <category term="process" scheme="https://wuhewuhe.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>interface and class</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/interface-and-class/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/interface-and-class/</id>
    <published>2020-02-12T18:53:37.000Z</published>
    <updated>2020-02-12T18:55:50.013Z</updated>
    
    <content type="html"><![CDATA[<p>interface</p><p>contains parameter and method</p><p>method par default is public abstract, we can not concerate but since java 8, default</p><p>parameter par default is public static final</p><p>a interface can extends multi interface, but it should realise all of the parment methods</p><p>abstract class</p><p>abstract class can concentrate method and contains various type : public private static</p><p>abstract class can have static method</p><p>hériter only one class</p><p>1、抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。</p><p>2、当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</p><p>3、当注重代码的扩展性跟可维护性时，应当优先采用接口。①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活; ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;contains parameter and method&lt;/p&gt;
&lt;p&gt;method par default is public abstract, we can not concerate but since java 8, defau
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Java/Interview/"/>
    
    
      <category term="interface" scheme="https://wuhewuhe.github.io/tags/interface/"/>
    
      <category term="class" scheme="https://wuhewuhe.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>hashcode, equals区别与联系</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/hashcode-equal/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/hashcode-equal/</id>
    <published>2020-02-12T07:05:28.000Z</published>
    <updated>2020-02-15T17:44:59.644Z</updated>
    
    <content type="html"><![CDATA[<p>有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。下面我们一起来看一下，它们到底有什么区别，总结一波！</p><p>01、hashCode介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.hashCode());}</code></pre><p>}<br>通过调用hashCode()方法获取对象的hash值。</p><p>02、equals介绍<br>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.equals(obj));}</code></pre><p>}<br>03、hashCode() 和 equals() 有什么关系？<br>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我们梳理了一下 “hashCode() 和 equals()的关系”。我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><p>3.1、不会创建“类对应的散列表”<br>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</p><p>equals() 用来比较该类的两个对象是否相等，而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 举个例子</p><p>public class DemoNormalTest {</p><pre><code>public static void main(String[] args) {// 新建2个相同内容的Person对象，// 再用equals比较它们是否相等Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>p1.equals(p3) : false; p1(2018699554) p3(1735600054)<br>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><p>3.2、会创建“类对应的散列表”<br>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的:</p><p>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。<br>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。<br>举个例子</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，    Person p1 = new Person(&quot;eee&quot;, 100);    Person p2 = new Person(&quot;eee&quot;, 100);    Person p3 = new Person(&quot;aaa&quot;, 200);    // 新建HashSet对象     HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();    set.add(p1);    set.add(p2);    set.add(p3);    // 比较p1 和 p2， 并打印它们的hashCode()    System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());     // 打印set    System.out.printf(&quot;set:%s\n&quot;, set); }private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>set:[(eee, 100), (aaa, 200), (eee, 100)]<br>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>举个例子，我们同时覆盖equals() 和 hashCode()方法。</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);Person p4 = new Person(&quot;EEE&quot;, 100);// 新建HashSet对象HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();set.add(p1);set.add(p2);set.add(p3);set.add(p4);// 比较p1 和 p2， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());// 比较p1 和 p4， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());// 打印setSystem.out.printf(&quot;set:%s\n&quot;, set);}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot; + name + &quot;, &quot; + age + &quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}/** * 重写hashCode方法 */@Overridepublic int hashCode() {int nameHash = name.toUpperCase().hashCode();return nameHash ^ age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(68545) p2(68545)<br>p1.equals(p4) : false; p1(68545) p4(68545)<br>set:[(eee, 100), (EEE, 100), (aaa, 200)]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="hashcode" scheme="https://wuhewuhe.github.io/tags/hashcode/"/>
    
      <category term="equals" scheme="https://wuhewuhe.github.io/tags/equals/"/>
    
  </entry>
  
  <entry>
    <title>set家族的对比</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/</id>
    <published>2020-02-12T06:57:33.000Z</published>
    <updated>2020-02-12T07:04:04.558Z</updated>
    
    <content type="html"><![CDATA[<p>Set接口<br>Set 接口与 List 接口相比没有那么多操作方法，比如：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><p>对比一下Set接口和Collection接口就知道，其实Set接口仅仅对Collection所有方法进行继承而已，而自己没有扩展任何方法，Set接口与Collection接口一样，都是15个方法。</p><img src="/2020/02/12/set-hashset-treeset-linkedset/set.jpg" alt="set" style="zoom:100%; ">Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。这里说的相同元素指的是用 equals() 方法比价后返回 true，当然了如果用 == 也返回true，那肯定也是相同的。一. HashSet特点：<ol><li><p>HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是无序的。</p></li><li><p>HashSet如何保证唯一性？</p></li></ol><p>1). HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2). 确保唯一性的两个方法：hashCode()和equals()方法。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>二. LinkedHashSet<br>特点：</p><ol><li><p>LinkedHashSet中不能有相同元素，可以有一个Null元素，元素严格按照放入的顺序排列。</p></li><li><p>LinkedHashSet如何保证有序和唯一性？</p></li></ol><p>1). 底层数据结构由哈希表和链表组成。</p><p>2). 链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>三. TreeSet<br>特点：</p><ol><li><p>TreeSet是中不能有相同元素，不可以有Null元素，根据元素的自然顺序进行排序。</p></li><li><p>TreeSet如何保证元素的排序和唯一性？</p></li></ol><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(log(n))</p></li><li><p>非线程安全</p></li></ol><p>四. 总结：<br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Set接口&lt;br&gt;
Set 接口与 List 接口相比没有那么多操作方法，比如：&lt;/p&gt;
&lt;p&gt;1、List 接口能直接设置或获取某个元素的值，而Set接口不能。&lt;/p&gt;
&lt;p&gt;2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。&lt;/p&gt;
&lt;p&gt;3、List
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
      <category term="Set" scheme="https://wuhewuhe.github.io/categories/Java/Collections/Set/"/>
    
    
      <category term="hashset" scheme="https://wuhewuhe.github.io/tags/hashset/"/>
    
      <category term="linkedhashset" scheme="https://wuhewuhe.github.io/tags/linkedhashset/"/>
    
      <category term="treeset" scheme="https://wuhewuhe.github.io/tags/treeset/"/>
    
  </entry>
  
  <entry>
    <title>讲清楚Vector vs ArrayList vs LinkedList</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/</id>
    <published>2020-02-11T20:10:29.000Z</published>
    <updated>2020-02-11T20:22:35.670Z</updated>
    
    <content type="html"><![CDATA[<p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></li><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></li><li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p></li><li><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p></li><li><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p></li><li><p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p></li><li><p>笼统来说：LinkedList：增删改快，ArrayList：查询快（有索引的存在）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ArrayLis
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
    
      <category term="vector" scheme="https://wuhewuhe.github.io/tags/vector/"/>
    
      <category term="arraylist" scheme="https://wuhewuhe.github.io/tags/arraylist/"/>
    
      <category term="linkedlist" scheme="https://wuhewuhe.github.io/tags/linkedlist/"/>
    
  </entry>
  
  <entry>
    <title>面试高频HashMap VS HashTable</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/hashmapVsHashtable/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/hashmapVsHashtable/</id>
    <published>2020-02-11T20:05:27.000Z</published>
    <updated>2020-02-11T20:07:51.252Z</updated>
    
    <content type="html"><![CDATA[<p>在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一样的。·<br>在使用时一般是用ArrayList代替Vector，LinkedList代替Stack，HashMap代替HashTable，即使在多线程中需要同步，也是用同步包装类。<br>另外在使用上还有一些小的差异，比如：</p><ul><li><p>HashTable的key和value都不允许为null值，而HashMap的key和value则都是允许null值的。这个其实没有好坏之分，只是Sun为了统一Collection的操作特性而改进的。</p></li><li><p>HashTable有一个contains(Object value)方法，功能上与containsValue(Object value)一样，但是在实现上花销更大，现在已不推荐使用。而HashMap只有containsValue(Object value)方法。</p></li><li><p>HashTable使用Enumeration，HashMap使用Iterator。Iterator其实与Enmeration功能上很相似，只是多了删除的功能。用Iterator不过是在名字上变得更为贴切一些。模式的另外一个很重要的功用，就是能够形成一种交流的语言（或者说文化）。有时候，你说Enumeration大家都不明白，说Iterator就都明白了。</p></li></ul><p><strong>不同点</strong></p><h4 id="接口">接口</h4><p><img src="https://pic3.zhimg.com/80/v2-12c49eba132902bbea990a4d77ecce37_hd.jpg" alt="img" style="zoom:50%;"><img src="https://pic3.zhimg.com/80/v2-d7d5449c9638ec4955288a3aa2ba9f13_hd.jpg" alt="img"></p><p>HashMap和Hashtable不仅作者不同，而且连父类也是不一样的。HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口</p><p>Dictionary类是一个已经被废弃的类（见其源码中的注释）。父类都被废弃，自然而然也没人用它的子类Hashtable了。</p><h4 id="线程安全">线程安全</h4><p>线程安全性不同</p><p>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</p><p>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，</p><p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><h4 id="初始容量大小和每次扩充容量大小的不同">初始容量大小和每次扩充容量大小的不同</h4><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说Hashtable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。</p><h4 id="计算hash值的方法不同">计算hash值的方法不同</h4><p>为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p><p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><p><img src="https://pic4.zhimg.com/50/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"></p><p>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</p><p>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p><p>HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算</p><p>为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Java/Interview/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Interview/Collections/"/>
    
    
      <category term="hashmap" scheme="https://wuhewuhe.github.io/tags/hashmap/"/>
    
      <category term="hashtable" scheme="https://wuhewuhe.github.io/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>2分钟说清楚shell和batch文件</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/shellandbatch/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/shellandbatch/</id>
    <published>2020-02-11T19:52:06.000Z</published>
    <updated>2020-02-11T19:54:35.748Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg" alt="Batch Programming (Dos Scripting) VS Shell Scripting" style="zoom:50%; ">Batch file</p><p>batch programming vs shell programming</p><p><img src="http://www.gonet.com.cn/~editor/eweditor/uploadfile/20171027141729471.png" alt="区别"></p><p>由于我们普通人接触UNIX的比较少，就不在多说。今天主要来说说WINDOWS系统和LINUX及苹果操作系统的区别。首先这三个系统设计上有本质的区别。最大的区别在于WINDOWS是一个成熟的商业操作系统，拿过来就能用，而LINUX不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。</p><img src="https://img-blog.csdn.net/20180619102423833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVfQXlt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表格" style="zoom:%; "><p>When I started my career in IT field, I have landed into windows world, as I know that no companies give chance to a fresher to work on production Linux/Unix servers. Its a good experience to work on <strong>DOS scripts(aka Batch programming).</strong> There are many <strong>similarities/differences/advantages/disadvantages</strong> between <strong>Batch programming</strong> and <strong>Shell scripting</strong>. Lets see what they are.</p><p><strong>Similarities</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Sequential execution of group commands in a batch file</td><td>Sequential execution of group command in shell scripts</td></tr><tr><td>2</td><td>Can read inputs from users</td><td>Can read inputs from users</td></tr><tr><td>3</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td></tr><tr><td>4</td><td>Supports advanced features such as Functions and Arrays</td><td>Supports advanced features such as Functions and Arrays</td></tr><tr><td>5</td><td>Supports regular expressions(using findstr)</td><td>Supports regular expressions</td></tr><tr><td>6</td><td>Can include other programming codes such as perl(ie…in middle of dos script we can include some other programming language code for effective scripting to get our desired output)</td><td>Can include other programming codes such as Perl, AWK, SED etc.</td></tr></tbody></table><p><strong>Differences</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Lack of richness of tools/commands</td><td>Have good number of tools(as of my knowledge there are more than 75000 commands in Linux/Unix)</td></tr><tr><td>2</td><td>Supports only one vendor(i.e.windows)</td><td>Supports for number of vendors such as Sun/apple/IBM AIX/HP-UX/GNU Linux etc.</td></tr><tr><td>3</td><td>No other variants for DOS</td><td>There are number of variants such as bash, ksh, csh, zsh etc…</td></tr><tr><td>4</td><td>Low capabilities of integrating with other programming code in batch scripting</td><td>Good capabilities of integrating other programming code in shell script</td></tr><tr><td>5</td><td>Cannot handle complex regular expressions</td><td>Can handle complex regular expressions.</td></tr><tr><td>6</td><td>A batch file should always end with .bat</td><td>There is no such concept like file extension, but a shell script file permission should be set to executable.</td></tr><tr><td>7</td><td>To execute a batch program just enter the file name at CLI</td><td>To execute a shell script, here are the ways to execute it 1)chmod +x <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a>; ./shellscript.sh 2)sh <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg&quot; alt=&quot;Batch Programming (Dos Scripting) VS Shell
      
    
    </summary>
    
    
      <category term="OS" scheme="https://wuhewuhe.github.io/categories/OS/"/>
    
    
      <category term="shell" scheme="https://wuhewuhe.github.io/tags/shell/"/>
    
      <category term="batch" scheme="https://wuhewuhe.github.io/tags/batch/"/>
    
  </entry>
  
  <entry>
    <title>由String浅谈Immutable不可变对象设计模式</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/java-immutable/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/java-immutable/</id>
    <published>2020-02-11T07:11:08.000Z</published>
    <updated>2020-02-11T07:31:30.180Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是Immutable</h1><p>Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而<strong>不用加锁实现线程安全</strong>，因为不可变对象一定是线程安全的，同时由于不需要用一些锁机制等保证内存一致性问题也减少了同步开销。<br>谈到Immutable Object会让很多Javaer联想到Java语言中的final关键字，final关键字可以修饰属性、方法和类。final的作用为</p><blockquote><p>final 修饰的 class 代表该类不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p></blockquote><p>那是不是被final修饰的对象就可以认为是Immutable Object呢？当然不是。请看下面的例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strList = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strList.add(<span class="string">"ONE"</span>);  <span class="comment">//ok</span></span><br><span class="line">strList.add(<span class="string">"TWO"</span>);  <span class="comment">//ok</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; unmodifiableStrList = Collections.unmodifiableList(strList);</span><br><span class="line">unmodifiableStrList.add(<span class="string">"THREE"</span>); <span class="comment">//throw UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p>这个例子中 <code>strList</code> 声明成final，只能说明strList变量指向的地址空间不能改变但是该地址空间指向的内容是可以修改的。</p><h1>如何定义Immutable Object</h1><p>Java 语言目前还没有原生的不可变对象的支持，但在<a href="https://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener">Java™ Tutorials</a>中给出的如何定义一个不可变对象的方法。</p><p>类中的属性不提供&quot;setter&quot;方法；</p><p>类中所有的属性声明成private和final类型；</p><p>类也声明成final的，以防止类被继承；</p><p>如果有属性是引用类型的，也要防止引用类型的属性被调用方修改了，如通过构造器初始化所有成员，尤其是引用对象要进行深拷贝(deep copy，符合copy-on-write 原则)；</p><p>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，也要深拷贝，创建私有的 copy。</p><p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name,String address)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getAddress() &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看上面示例中使用到的 <code>Collections.unmodifiableList()</code> 方法是如何将一个可变的对象变成不可变对象</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; unmodifiableList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的list是ArrayList，他是RandomAccess的实例</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(<span class="keyword">list</span>) :</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableList&lt;&gt;(<span class="keyword">list</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UnmodifiableRandomAccessList对象是Collections的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableRandomAccessList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    UnmodifiableRandomAccessList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnmodifiableList</code> 是 <code>UnmodifiableRandomAccessList</code> 的父类，它们两个都是 <code>Collections</code> 的静态内部类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;E&gt; <span class="title">extends</span> <span class="title">UnmodifiableCollection</span>&lt;E&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List</span>&lt;E&gt; &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;? extends E&gt; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    UnmodifiableList(List&lt;? extends E&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        super(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">list</span> = <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">list</span>.get(index);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List unmodifiableStrList = Collections.unmodifiableList(strList);</code> 语句执行之后unmodifiableStrList变量实际指向的类型会变成 <code>UnmodifiableList</code> 。然后再执行add方法的时候就会抛出 <code>UnsupportedOperationException</code> 异常。<br>除了 <code>unmodifiableList()</code> 方法之外， <code>Collections</code> 中还定义了将其他集合修饰成不可变对象的方法。</p><ul><li>Collections.unmodifiableCollection()</li><li>Collections.unmodifiableMap()</li><li>Collections.unmodifiableSortedMap()</li><li>Collections.unmodifiableSet()</li><li>Collections.unmodifiableSortedSet()</li></ul><p>其基本实现思路和 <code>unmodifiableList()</code> 方法是一样的，另外 <code>Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;);</code> 返回的List对象也是不可变的。</p><h1>String对象的不可变性</h1><p><code>String</code> 是典型的 Immutable 类，被声明成为 final class，它的属性基本都是 final 的。由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。下面是String源码的部分摘录，可以看到它是符合Immutable Object的定义规则的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D;</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 进行深拷贝来构造引用类型的成员变量 *&#x2F;</span><br><span class="line">    public String(char value[]) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public String(StringBuilder builder) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">    &#125;</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen &#x3D; str.length();</span><br><span class="line">        if (otherLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; value.length;</span><br><span class="line">        char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public char[] toCharArray() &#123;</span><br><span class="line">        &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">        char result[] &#x3D; new char[value.length];</span><br><span class="line">        System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可见，string是线程安全的，java中string对象需要慎用尤其是我们有大量的字符串拼接修改删除增加的操作时，这会造成大量的内存开销，由此我们可以考虑使用stringbuilder。如果需要同步，则可以使用stringbuffer</p><p>那就要分别看看它们的 <code>append()</code> 源码了；</p><p>StringBuilder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder中的append方法没有使用synchronized关键字，意味着多个线程可以同时访问这个方法。那么问题就来了额，如果两个线程同时访问到这个方法，那么AbstractStringBuilder中的count是不是就是相同的，所以这两个线程都是在底层char数组的count位置开始append添加，那么最终的结果肯定就是在后执行的那个线程append进去的数据会将前面一个覆盖掉。因此我们的控制台输出才会出现StringBuilder一直都是小于1000的。然而StringBuffer却不会发生这种情况。</p><h2 id="总结">总结</h2><ol><li>StringBuilder相比StringBuffer效率更高，但多线程不安全；</li><li>在单线程中字符串的频繁拼接使用StringBuilder效率更高，对于多线程使用StringBuffer则更安全；</li><li>字符串简单操作时没必要使用上述两者，还是用String类型提高速度；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;什么是Immutable&lt;/h1&gt;
&lt;p&gt;Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而&lt;s
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="string" scheme="https://wuhewuhe.github.io/tags/string/"/>
    
      <category term="immutable" scheme="https://wuhewuhe.github.io/tags/immutable/"/>
    
      <category term="stringbuilder" scheme="https://wuhewuhe.github.io/tags/stringbuilder/"/>
    
      <category term="stringbuffer" scheme="https://wuhewuhe.github.io/tags/stringbuffer/"/>
    
  </entry>
  
  <entry>
    <title>大白话说Serializable</title>
    <link href="https://wuhewuhe.github.io/2020/02/10/transient-java/"/>
    <id>https://wuhewuhe.github.io/2020/02/10/transient-java/</id>
    <published>2020-02-10T19:51:27.000Z</published>
    <updated>2020-02-10T21:02:35.531Z</updated>
    
    <content type="html"><![CDATA[<p>大白话定义：</p><p>序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.</p><p><strong>切记序列化不考虑static变量</strong></p><p>Java原生序列化方式是通过实现Serializable接口实现的. 不实现该接口会导致无法序列化, 抛出异常如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException</span><br></pre></td></tr></table></figure><p>序列化的应用场景：</p><blockquote><p>将对象转换为字节流, 用于网络传输, 例如用于RPC远程调用。</p><p>将对象保存到磁盘中</p></blockquote><p>Java原生序列化是通过IO包中的ObjectInputStream和ObjectOutputStream实现的。ObjectOutputStream类负责实现序列化, ObjectInputStream类负责实现反序列化。</p><h4 id="Java序列化反序列化实例">Java序列化反序列化实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Person [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class testPerson &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transient">transient</h4><p>出于安全问题，有时候不会把指定字段进行序列化保存，例如密码, 此处以Person对象的pwd字段为例, 为pwd字段添加transient修饰后，默认序列化机制会忽略它。</p><p>对比结果如下 尽管我们对pwd初始化为mdp，但是由于transient关键字，则pwd不被序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;);</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;null]</span><br></pre></td></tr></table></figure><p>如果transient修饰的字段也需要序列化和反序列化，可以使用readObject和writeObject方法。</p><p>我们只需要在当前 Person 类中添加 readObject() 和 writeObject() 方法，在 writeObject 方法中实现对 pwd 的字段赋值，就可以使pwd字段被序列化到字节流中；在 readObject 方法中实现对 pwd 字段读取，并赋值给Person对象即可。<br>添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private transient String pwd;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream s) throws Exception &#123;</span><br><span class="line">s.defaultReadObject();</span><br><span class="line">this.pwd &#x3D; (String) s.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream s) throws Exception &#123;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">this.pwd &#x3D; &quot;pwd&quot;;</span><br><span class="line">s.writeObject(this.pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPwd(String pwd) &#123;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readObject和writeObject在本文后段内容会讲解.</p><p>这里的defaultWriteObject方法作用是序列化非transient字段以及非静态字段; 这里的defaultReadObject方法作用是反序列化非transient字段以及非静态字段; 当类中含有非transient字段时, 一定要加上这两个方法.</p><p>如果被序列化的类中存在多个transient的字段, 序列化时需要如下操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class TransientPerson implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private transient Integer age;</span><br><span class="line">private transient String name;</span><br><span class="line">private transient Integer money;</span><br><span class="line"></span><br><span class="line">public TransientPerson(Integer age, String name, Integer money) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">this.age &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.money &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.name &#x3D; (String) stream.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeObject(this.age);</span><br><span class="line">stream.writeObject(this.money);</span><br><span class="line">stream.writeObject(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMoney(Integer money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;TransientPerson [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;transientperson.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">TransientPerson person &#x3D; new TransientPerson(3, &quot;abc&quot;, 123);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">TransientPerson newPerson &#x3D; (TransientPerson) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc, money &#x3D; 123]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><hr><p>这里writeObject和readObject的使用是有顺序的, 例如第一次writeObject是将age作为Object写入, 所以第一次调用readObject读到的对象就一定是age; 所以, 写入的顺序是age, money, name, 读取时候的顺序一定也要是age, money, name.</p><p>上面理论上会写入了四个对象, 第一个是defaultWriteObject写入的Person对象, 之后写入的是age(Integer对象), money(Integer), name(String).</p><p>当然这里defaultWriteObject没有写入, 因为所有成员字段都是transient修饰, 所以实际上只有三个对象(age, money, name). 换句话说, 当所有字段被transient修饰时, 可以不用defaultWriteObject和defaultReadObject.</p><h4 id="serialVersionUID">serialVersionUID</h4><p>当person对象被序列化保存到person.txt文件时, 在Person对象中添加新的属性address, 只执行反序列化代码, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">&#x2F;&#x2F;Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;, &quot;paris&quot;);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.writeObject(person);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">&#x2F;&#x2F;System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><p>输出结果依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;pwd, address&#x3D;null]</span><br></pre></td></tr></table></figure><p>但是我们删除serialVersionUID字段后再次执行, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line">private transient String pwd;</span><br><span class="line">private String address; &#x2F;&#x2F; 新添加的属性</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd, String address) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">this.address &#x3D; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: wotest.test.Person;  local class incompatible: stream classdesc serialVersionUID &#x3D; 1,  local class serialVersionUID &#x3D; 3229018537912438741</span><br></pre></td></tr></table></figure><p>原因:</p><blockquote><p>没有定义serialVersionUID值, 反序列化可能会出现 <code>local class incompatible</code> 异常, 是Java的安全机制.</p><p>当序列化对象时, 如果该对象所属类没有serialVersionUID, Java编译器会对jvm中该类的Class文件进行摘要算法生成一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; serialVersionUID(version1), 并保存在序列化结果中. </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当反序列化时, jvm会再次对jvm中Class文件摘要生成一个serialVersionUID(version2). 当且仅当version1=version2时, 才会将反序列化结果加载入jvm中, 否则jvm会判断为不安全, 拒绝载入并抛出 <code>local class incompatible</code> 异常.</p><p>这样存在的问题就是, 当对象被序列化后, 其所属类只要进行过类名称, 它所实现的接口的名称, 以及所有成员名称的修改, 会导致摘要算法算出的serialVersionUID变化.</p></blockquote><p>从而version1 != version2导致抛出异常.</p><blockquote><p>例如序列化对象存储在磁盘中后, jvm停止, 对其所属类进行修改. 再次启动jvm, 对该对象序列化时就会抛异常.</p></blockquote><p>由此可知, 反序列化时会通过比较serialVersionUID进行 <code>判断反序列化内容是否安全</code> , 所以添加如下声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 3229018537912438741L;</span><br></pre></td></tr></table></figure><p>将serialVersionUID值固定下来, 可以防止这种情况下的反序列化失败.</p><p><strong>另外, 如果 User 对象升级版本，修改了结构，而且不想兼容之前的版本，那么只需要修改下 serialVersionUID 的值就可以了。</strong></p><p>建议，每个需要序列化的对象，都要添加一个 serialVersionUID 字段。</p><p><strong>最后延伸一下，HashMap中重写的writeObject和readObject</strong></p><h5 id="HashMap序列化存在的问题">HashMap序列化存在的问题</h5><p>HashMap有必须重写它们的理由, 因为序列化会导致字节流在不同的jvm中传输, 而序列化基本要求就是反序列化后的对象与序列化之前的对象是一致的.</p><p>HashMap中，由于Entry的存放位置是根据Key的Hash值计算, 对于同一个Key，在不同的jvm中计算得出的Hash值可能是不同的.</p><p>Hash值不同导致HashMap对象反序列化的结果与序列化之前不一致. 有可能序列化之前Key=’name’的元素放在数组的第0个位置, 而反序列化后在数组第2个位置.</p><h5 id="HashMap的解决方式">HashMap的解决方式</h5><ul><li><p>将可能造成数据不一致的元素使用transient修饰，然后重写writeObject/readObject方法, 在该方法中操作这些敏感元素, 避免默认序列化方法的干扰。被transient修饰的元素有: Entry[] table, size, modCount。</p></li><li><p>首先，HashMap序列化的时候会屏蔽掉负载因子, 只把不为空的key和value进行序列化. 传送到新的jvm反序列化时, 根据新的jvm处的规则重新对key进行hash算法, 重新填充一个数组. 这样避免了对象的不一致.</p></li></ul><h5 id="HashMap源码">HashMap源码</h5><p>writeObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    int buckets &#x3D; capacity();</span><br><span class="line">    &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s); &#x2F;&#x2F; 将有效的键值对进行了序列化.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到writeObject中序列化了buckets和size, 之后又通过internalWriteEntries方法将有效的键值对进行了序列化.</p><p>之后在readObject方法中反序列化时也要按照这个顺序.</p></blockquote><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                &#x2F;&#x2F; Read and ignore number of buckets</span><br><span class="line">    int mappings &#x3D; s.readInt(); &#x2F;&#x2F; Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; &#x2F;&#x2F; (if zero, use defaults)</span><br><span class="line">        &#x2F;&#x2F; Size the table using given load factor only if within</span><br><span class="line">        &#x2F;&#x2F; range of 0.25...4.0</span><br><span class="line">        float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;</span><br><span class="line">        int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft &#x3D; (float)cap * lf;</span><br><span class="line">        threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table &#x3D; tab;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key &#x3D; (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value &#x3D; (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按照顺序依次读出了:</p><ul><li>对象中非transient以及非static字段(defaultReadObject方法);</li><li>buckets, 但是被忽略了(见注释: Read and ignore number of buckets);</li><li>size(int mappings = s.readInt());</li><li>根据size遍历读取键值对(for (int i = 0; i &lt; mappings; i++)).</li></ul></blockquote><p>遍历读取的键值对最终依据新的规则保存到了新的map中, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key &#x3D; (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value &#x3D; (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList重写writeObject和readObject">ArrayList重写writeObject和readObject</h4><p>值得注意的是, ArrayList重写writeObject和readObject. 是因为在ArrayList中的数组容量基本上都会比实际的元素的数大, 为了避免序列化没有元素的数组而重写.</p><ul><li>writeObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in capacity</span><br><span class="line">    s.readInt(); &#x2F;&#x2F; ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a &#x3D; elementData;</span><br><span class="line">        &#x2F;&#x2F; Read in all elements in the proper order.</span><br><span class="line">        for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大白话定义：&lt;/p&gt;
&lt;p&gt;序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切记序列化不考虑static变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java原生序列化方式是通过实现Serializable接口实现的.
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="serialisation" scheme="https://wuhewuhe.github.io/tags/serialisation/"/>
    
      <category term="deserialisation" scheme="https://wuhewuhe.github.io/tags/deserialisation/"/>
    
  </entry>
  
  <entry>
    <title>动态委托</title>
    <link href="https://wuhewuhe.github.io/2020/02/04/delegate-avance/"/>
    <id>https://wuhewuhe.github.io/2020/02/04/delegate-avance/</id>
    <published>2020-02-04T21:36:17.000Z</published>
    <updated>2020-02-04T21:59:21.759Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇的内容<br>大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;技术方法</span><br><span class="line">public interface OledTch &#123;</span><br><span class="line">&#x2F;&#x2F; 技术名称</span><br><span class="line">public void tchName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 色彩饱和度</span><br><span class="line">public void colorSaturation();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星</span><br><span class="line">public class Sumsung implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;98%NTSC - Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;华为</span><br><span class="line">public class Huawei implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;富士康</span><br><span class="line">public class Fotconn implements OledTch &#123;</span><br><span class="line">private OledTch oledMap; &#x2F;&#x2F;富土康的OLED生产图纸</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：甲方指定用哪家的图纸就用哪家的图纸</span><br><span class="line">public Fotconn(OledTch oledMap) &#123;</span><br><span class="line">this.oledMap &#x3D; oledMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：默认情况下，用华为的生产图纸</span><br><span class="line">public Fotconn() &#123;</span><br><span class="line">this.oledMap &#x3D; new Huawei();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">oledMap.tchName();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">                oledMap.colorSaturation();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class Xiaomi_Pipeline &#123;</span><br><span class="line"></span><br><span class="line">public void oled() &#123;</span><br><span class="line">Sumsung sumsung &#x3D; new Sumsung(); &#x2F;&#x2F; 确定使用三星的OLED技术</span><br><span class="line">Fotconn fotconn &#x3D; new Fotconn(sumsung);&#x2F;&#x2F; 告诉乙方 富土康：“我要三星图纸生产的OLED”</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小米正在生产: &quot;);</span><br><span class="line">fotconn.tchName();</span><br><span class="line">fotconn.colorSaturation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testXiaomi8() &#123;</span><br><span class="line">Xiaomi_Pipeline xiaomi8 &#x3D; new Xiaomi_Pipeline();</span><br><span class="line">xiaomi8.oled();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.39.03.png" alt="屏幕快照 2020-02-04 22.39.03" style="zoom:33%; "><p>我想讲一下我今天新学到的这个思路，就是动态代理，假象一个环境，我们用schduler来调控我们的任务，然后每一个任务对应不同的service，每个service我们有具体的实现方法，这时我们可以用到invoke的动态委托，我来画一个图。</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.04.13.png" alt="屏幕快照 2020-02-04 22.04.13" style="zoom:50%; "><h4 id="使用动态代理">使用动态代理</h4><h4 id="定义接口">定义接口</h4><p>下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下动态代理的简单实现，委托类和代理类都实现了Sell接口，Sell接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 委托类和代理类都实现了Sell接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Sell &#123; </span><br><span class="line">    void sell(); </span><br><span class="line">    void ad();</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler接口">InvocationHandler接口</h4><p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 调用处理程序</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface InvocationHandler &#123; </span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。</p><h4 id="委托类的定义">委托类的定义</h4><p>动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Vendor implements Sell &#123; </span><br><span class="line">    public void sell() &#123; </span><br><span class="line">        System.out.println(&quot;In sell method&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        System,out.println(&quot;ad method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中介类">中介类</h4><p>上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123; </span><br><span class="line">    &#x2F;&#x2F;obj为委托类对象; </span><br><span class="line">    private Object obj; </span><br><span class="line"> </span><br><span class="line">    public DynamicProxy(Object obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @Override </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span><br><span class="line">        System.out.println(&quot;before&quot;); </span><br><span class="line">        Object result &#x3D; method.invoke(obj, args); </span><br><span class="line">        System.out.println(&quot;after&quot;); </span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法</p><h3 id="动态生成代理类">动态生成代理类</h3><p>动态生成代理类的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123; </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建中介类实例 </span><br><span class="line">        DynamicProxy inter &#x3D; new DynamicProxy(new Vendor()); </span><br><span class="line">        &#x2F;&#x2F;加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取代理类实例sell </span><br><span class="line">        Sell sell &#x3D; (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter)); </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;通过代理类对象调用代理类方法，实际上会转到invoke方法调用 </span><br><span class="line">        sell.sell(); </span><br><span class="line">        sell.ad(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br></pre></td></tr></table></figure><p>复制代码方法的三个参数含义分别如下：<br>loader：定义了代理类的ClassLoder;<br>interfaces：代理类实现的接口列表<br>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例<br>我们运行一下，看看我们的动态代理是否能正常工作。我这里运行后的输出为</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cbbd27e07f9a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="代理模式">代理模式</h3><p>这个应该是设计模式中最简单的一个了，类图</p><p>代理模式最大的特点就是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作</p><p>Java动态代理其实内部也是通过Java反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后作一些相应的处理，这样说的比较笼统，举个简单的例子</p><p>比如我们在应用中有这样一个需求，在对某个类的一个方法的调用前和调用后都要做一下日志操作，</p><p>一个普通的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AppService &#123;  </span><br><span class="line">    public boolean createApp(String name);  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该接口的默认实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AppServiceImpl implements AppService &#123;  </span><br><span class="line">    public boolean createApp(String name) &#123;  </span><br><span class="line">        System.out.println(&quot;App[&quot;+name+&quot;] has been created.&quot;);  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>日志处理器（实质充当了中介类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 注意需实现Handler接口  </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LoggerInterceptor implements InvocationHandler &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;目标对象的引用，这里设计成Object类型，更具通用性  </span><br><span class="line">    public LoggerInterceptor(Object target)&#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] arg)  throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;Entered &quot;+target.getClass().getName()+&quot;-&quot;+method.getName()+&quot;,with arguments&#123;&quot;+arg[0]+&quot;&#125;&quot;);  </span><br><span class="line">        Object result &#x3D; method.invoke(target, arg);&#x2F;&#x2F;调用目标对象的方法  </span><br><span class="line">        System.out.println(&quot;Before return:&quot;+result);  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>外部调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AppService target &#x3D; new AppServiceImpl();&#x2F;&#x2F;生成目标对象  </span><br><span class="line">        &#x2F;&#x2F;接下来创建代理对象  </span><br><span class="line">        AppService proxy &#x3D; (AppService) Proxy.newProxyInstance(  </span><br><span class="line">                target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), new LoggerInterceptor(target));  </span><br><span class="line">        proxy.createApp(&quot;Kevin Test&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上一篇的内容&lt;br&gt;
大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="delegate" scheme="https://wuhewuhe.github.io/tags/delegate/"/>
    
      <category term="design pattern" scheme="https://wuhewuhe.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>浅谈java中的委托和继承</title>
    <link href="https://wuhewuhe.github.io/2020/02/04/delagate-java/"/>
    <id>https://wuhewuhe.github.io/2020/02/04/delagate-java/</id>
    <published>2020-02-04T19:55:16.000Z</published>
    <updated>2020-02-04T21:08:08.613Z</updated>
    
    <content type="html"><![CDATA[<p>上学的时候听到过委托这个词，写程序的时候自己用到过这种方式，面试的时候被问到过，做题的时候也有相关的练习，今天工作的时候debug看到我们自己也用到了delegate这个设计模式作为基类，所以就在这里总结一下。</p><p>为了区分继承 Inheritance，在这里将两者对比</p><h5 id="概念">概念</h5><p><strong>delegate和inheritance都可以提高代码的复用性</strong></p><ul><li><p>delegate：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象</p></li><li><p>继承：利用extends来扩展一个基类。</p></li></ul><hr><h5 id="Delegation（委托）">Delegation（委托）</h5><p>首先我们来看委托： 委托分为委托方和依赖方，他要求特定的方法在运行时调用不同的代码，这就是委托依赖与动态绑定，例如我们看一下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">void foo() &#123;</span><br><span class="line">this.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">System.out.println(&quot;a.bar&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在B类中，不使用继承，而是利用委托结合A，达到复用A类中代码的效果，其实平常我们在编程中也写过很多这样的例子只是不知道这种设计模式就是委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a &#x3D; a; </span><br><span class="line">    &#125;</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        a.foo(); &#x2F;&#x2F; call foo() on the a-instance &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;b.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面代码的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    A a &#x3D; new A();</span><br><span class="line">    B b &#x3D; new B(a); </span><br><span class="line">    b.foo();</span><br><span class="line">    b.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易地看出来结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.bar</span><br><span class="line">b.bar</span><br></pre></td></tr></table></figure><p>这就是一种简单的委派机制。</p><p>当然在当下IDP（控制反转：这里不多赘述了，之前也提到过这是spring的核心之一）的时代，接口才是王道，所以我们可以换另一种方式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoggingList&lt;E&gt; implements List&lt;E&gt;&#123;</span><br><span class="line"> private final List&lt;E&gt; list1;</span><br><span class="line">    public LoggingList(List&lt;E&gt; list) &#123; </span><br><span class="line">        this.list1 &#x3D; list; </span><br><span class="line">    &#125; </span><br><span class="line">    public boolean add(E e) &#123; </span><br><span class="line">        System.out.println(&quot;Adding &quot; + e); </span><br><span class="line">        return list1.add(e); </span><br><span class="line">    &#125; </span><br><span class="line">    public E remove(int index) &#123; </span><br><span class="line">        System.out.println(&quot;Removing at &quot; + index); </span><br><span class="line">        return list1.remove(index); </span><br><span class="line">    &#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">list1.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这就相当于我们重写add，remove和clear三个方法，但是没有继承</p><h4 id="委派的几种类型归纳">委派的几种类型归纳</h4><ul><li>Use (A use B)</li><li>Composition/aggregation (A owns B)</li><li>Association (A has B)</li></ul><h4 id="Dependency（依赖）-临时性的delegation">Dependency（依赖）: 临时性的delegation</h4><ul><li>在这种关系中，一个类使用另一个类而不将其作为一个属性。</li><li>两类之间的这种关系称为“uses-a”关系。例如，它可以是一个参数，或者在一个方法中本地使用，参考下面的代码：</li></ul><p>首先新建一个课程类：</p><p>public class Course {}</p><p>在课表类总使用课程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CourseSchedule &#123;</span><br><span class="line">    List&lt;Course&gt; courses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public void add (Course c) &#123;</span><br><span class="line">        courses.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove (Course c) &#123;</span><br><span class="line">        courses.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，并没有将Course类作为CourseSchedule类的属性来使用，而是作为迭代器中的元素和方法中的参数来使用。</p><h4 id="Association（关联）-永久性的delegation">Association（关联）: 永久性的delegation</h4><p>关联是类之间的持久关系，允许一个对象实例让另一个对象实例代表它自己做其他事。<br>这种关系属于has-a的关系，是结构化的，因为它指定了一种对象与另一种对象相连接，并且不代表行为，即不在该类的方法中使用另一个类的方法，只是简单的将不同的对象连接起来。</p><p>下面展示一下关联的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Teacher &#123;    </span><br><span class="line">private Student [] students;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;    </span><br><span class="line">private Teacher teacher;    </span><br><span class="line">Course[] selectedCourses; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在两个类中（Student和Teacher）互相都有彼此的实例，而且没有使用继承，就直接将这几个不同的类相连接，这就是利用了Association方式。</p><h4 id="Composition-更强的delegation">Composition: 更强的delegation</h4><p>组合是将简单对象或数据类型组合成更复杂的方法的一种方法。<br>这种关系是a-part-of关系，一个类有另一个属性或实例变量——实现了一个对象包含另一个对象。<br>let s show 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Heart &#123;&#125;</span><br><span class="line">class Person &#123; </span><br><span class="line">    private Heart heart &#x3D; new Heart();</span><br><span class="line">    public void operation () &#123; </span><br><span class="line">        heart.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式理解起来就很简单了，直接在该类中实例化一个其他类，然后该调用方法调用方法，对这个实例想怎么用怎么用，十分灵活。<br>不过需要注意的是：<br>这里的实例是private的，也就是说，外界访问不到，这样的话，更改其值只能在该方法中；而且每次创建该类的对象时，就已经创建好这个类中的实例；也就是说一旦创建好该类的对象，其中的属性指向便已经创建好。</p><h4 id="Aggregation">Aggregation</h4><p>聚集：对象存在于另一个之外，是在外部创建的，所以它作为一个参数传递给构造函数。<br>这种关系是has-a的关系，区别于</p><p>让我们看一个这个例子的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;&#125;</span><br><span class="line">class Course &#123; </span><br><span class="line">    private Student[] students; </span><br><span class="line">    public addStudent (Student s) &#123; </span><br><span class="line">        studtents.append(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这里，内部的属性是可以在外部指定的，而不是完全依赖该类。</p><h4 id="Composition-vs-Aggregation">Composition vs. Aggregation</h4><p>组合和聚集是最常用的两种delegation方式，可以说，其中的使用包括了依赖和关联方式，并在其上做了进一步的扩展。二者很相似，但又有很多不同之处，这里举一个例子看一下二者的最大不同之处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer(HttpListener listener, RequestProcessor processor) &#123;</span><br><span class="line">        this.listener &#x3D; listener;</span><br><span class="line">        this.processor &#x3D; processor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer() &#123; </span><br><span class="line">        this.listener &#x3D; new HttpListener(80); </span><br><span class="line">        this.processor &#x3D; new RequestProcessor(“&#x2F;www&#x2F;root”);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inheritance（继承）">Inheritance（继承）</h4><p>继承就很好说了，直接是一个类利用extends扩展其父类，而且一个类只能扩展一个父类，但是可以多层扩展。<br>参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        this.bar(); </span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;A.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    public B() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void foo() &#123; </span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        System.out.println(&quot;B.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以猜一下下面代码的输出的结果，比较有趣：</p><p>B b = new B();<br>b.foo();<br>我这里运行的结果是</p><p>B.bar<br>可以看到，在继承中，子类拥有父类所有的方法，而且还可以继续增加父类中没有的方法。</p><h4 id="适用于不同场合">适用于不同场合</h4><p>总而言之，委派和继承都是为了代码复用，只是方式不同。</p><ul><li>委托可以被看作是对象级别的重用机制，而继承是类级别的重用机制。</li><li>此外，如果子类只需要复用父类中的一小部分方法，可以不需 要使用继承，而是通过委派机制来实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上学的时候听到过委托这个词，写程序的时候自己用到过这种方式，面试的时候被问到过，做题的时候也有相关的练习，今天工作的时候debug看到我们自己也用到了delegate这个设计模式作为基类，所以就在这里总结一下。&lt;/p&gt;
&lt;p&gt;为了区分继承 Inheritance，在这里将两
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="delegate" scheme="https://wuhewuhe.github.io/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>rmi_java_springboot</title>
    <link href="https://wuhewuhe.github.io/2020/01/30/rmi-java-springboot/"/>
    <id>https://wuhewuhe.github.io/2020/01/30/rmi-java-springboot/</id>
    <published>2020-01-30T19:41:53.000Z</published>
    <updated>2020-01-30T19:41:54.021Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker vs VM 与 web url的关系</title>
    <link href="https://wuhewuhe.github.io/2020/01/26/computerwebadnresources/"/>
    <id>https://wuhewuhe.github.io/2020/01/26/computerwebadnresources/</id>
    <published>2020-01-26T21:18:49.000Z</published>
    <updated>2020-01-26T21:20:34.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-What-Happens-When-You-Type-in-a-URL">1 What Happens When You Type in a URL?</h3><p>1 enter url in browser</p><p>2 browser look up ip address of domaine via dns</p><p>3 browser send a request to server</p><p>4 server returns a http response</p><p>5 browser rends html</p><p>6 browser need css js images then repeat 3-5</p><p>7 finish loading, send futur async request</p><h3 id="2-How-Web-Browsers-and-Web-Servers-Communicate">2 How Web Browsers and Web Servers Communicate?</h3><p>Web browsers and servers communicate using TCP/IP. Hypertext Transfer Protocol is the standard application protocol on top of TCP/IP supporting web browser requests and server responses</p><p>Web browsers also rely on DNSto work with URLs. These protocol standards enable different brands of web browsers to communicate with different brands of web servers without requiring special logic for each combination.</p><p>1 A person specifies a URL in a browser.</p><p>2  The browser initiates a TCP connection to the web server or server pool (using port 80 by default). As part of this process, the browser also makes DNS lookup requests to convert the URL to an IP address.</p><p>3 After the server completes acknowledgment of its side of the TCP connection, the browser sends HTTP requests to the server to retrieve the content.</p><p>4 after the server replies with content for the page, the browser retrieves it from the HTTP packets and displays it accordingly. Content can include embedded URLs for advertising banners or other external content, that in turn triggers the browser to issue new TCP connection requests to those locations. The browser may also save temporary information about its connections to local files on the client computer called <em>cookies</em>.</p><p>5 Any errors encountered during the request for the content might be shown as http status error line</p><h3 id="3-what-is-microservice-architecture">3 what is microservice architecture?</h3><p>A microservices architecture takes this same approach and extends it to the loosely coupled services which can be developed, deployed, and maintained independently. Each of these services is responsible for discrete task and can communicate with other services through simple APIs to solve a larger complex business problem.</p><p>Once developed, these services can also be deployed independently of each other and hence its easy to identify hot services and scale them independent of whole application. Microservices also offer improved fault isolation whereby in the case of an error in one service the whole application doesn’t necessarily stop functioning. When the error is fixed, it can be deployed only for the respective service instead of redeploying an entire application.</p><p>Another advantage which a microservices architecture brings to the table is making it easier to choose the technology stack (programming languages, databases, etc.) which is best suited for the required functionality (service) instead of being required to take a more standardized, one-size-fits-all approach.</p><h3 id="4-Difference-between-docker-and-vm">4 Difference between docker and vm?</h3><p>Docker is virtual machine that was more lightweight, economical, and scalable. Docker is a container-based technology that lets you develop distributed applications</p><p>**A virtual machine is a system which acts exactly like a computer.**In simple terms, it makes it possible to run what appears to be on many separate computers on hardware, that is one computer. Each virtual machine requires its underlying operating system, and then the hardware is virtualized.</p><p>**Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container</p><p><strong>. Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container.</strong></p><img src="https://geekflare.com/wp-content/uploads/2019/09/traditional-vs-new-gen.png" alt="Traditional vs New Gen" style="zoom:60%; "><p>The operating system support of Virtual machine and Docker container is very different. From the image above, you can see each virtual machine has its guest operating system above the host operating system, which makes virtual machines heavy. While on the other hand, Docker containers share the host operating system, and that is why they are lightweight.</p><p>Sharing the host operating system between the containers make them very light and helps them to boot up in just a few seconds. Hence, the overhead to manage the container system is very low compared to that of virtual machines.</p><p>The docker containers are suited for situations where you want to run multiple applications over a single operating system kernel.<strong>But if you have applications or servers that need to run on different operating system flavors, then virtual machines are required.</strong></p><p><strong>Security</strong></p><p>The virtual machine does no share operating system, and there is strong isolation in the host kernel. Hence, they are more secure as compared to Containers. A container have a lot of security risks, and vulnerabilities as the containers have shared host kernel.</p><p><strong>Portability</strong></p><p>Docker containers are easily portable because they do not have separate operating systems. A container can be ported to a different OS, and it can start immediately. On the other hand, virtual machines have separate OS, so porting a virtual machine is difficult as compared to containers, and it also takes a lot of time to port a virtual machine because of its size.</p><p>For development purposes where the applications must be developed and tested in different platforms, Docker containers are the ideal choice.</p><p><strong>Performance</strong></p><p>Comparing Virtual machines and Docker Containers would not be fair because they both are used for different purposes. But the lightweight architecture of docker its less resource-intensive feature makes it a better choice than a virtual machine. As a result, of which containers can startup very fast compared to that of virtual machines, and the resource usage varies depending on the load or traffic in it.</p><p>Unlike the case of virtual machines, there is no need to allocate resources permanently to containers. Scaling up and duplicating the containers is also an easy task compared to that of virtual machines, as there is no need to install an operating system in them.</p><table><thead><tr><th><strong>Virtual Machine</strong></th><th><strong>Docker Container</strong></th></tr></thead><tbody><tr><td>Hardware-level process isolation</td><td>OS level process isolation</td></tr><tr><td>Each VM has a separate OS</td><td>Each container can share OS</td></tr><tr><td>Boots in minutes</td><td>Boots in seconds</td></tr><tr><td>VMs are of few GBs</td><td>Containers are lightweight (KBs/MBs)</td></tr><tr><td>Ready-made VMs are difficult to find</td><td>Pre-built docker containers are easily available</td></tr><tr><td>VMs can move to new host easily</td><td>Containers are destroyed and re-created rather than moving</td></tr><tr><td>Creating VM takes a relatively longer time</td><td>Containers can be created in seconds</td></tr><tr><td>More resource usage</td><td>Less resource usage</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-What-Happens-When-You-Type-in-a-URL&quot;&gt;1 What Happens When You Type in a URL?&lt;/h3&gt;
&lt;p&gt;1 enter url in browser&lt;/p&gt;
&lt;p&gt;2 browser look u
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Interview/"/>
    
    
      <category term="docker" scheme="https://wuhewuhe.github.io/tags/docker/"/>
    
      <category term="network" scheme="https://wuhewuhe.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>spring高频面试题</title>
    <link href="https://wuhewuhe.github.io/2020/01/26/springBootMVC/"/>
    <id>https://wuhewuhe.github.io/2020/01/26/springBootMVC/</id>
    <published>2020-01-26T16:36:59.000Z</published>
    <updated>2020-01-26T17:21:21.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本常识">基本常识</h3><hr><p>使用Spring框架的好处是什么？**</p><ul><li>**轻量：**Spring是轻量的，基本的版本大约2MB。</li><li>**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li>**面向切面的编程(AOP)：**Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li>**容器：**Spring包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li>**事务管理：**Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li>**异常处理：**Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛出的）转化为一致的unchecked异常。</li></ul><p><strong>Spring由哪些模块组成?</strong></p><p>以下是Spring框架的基本模块：</p><ul><li><p>Coremodule</p><p>spring core模块是spring的核心容器，它实现了<strong>ioc</strong>模式，提供了spring框架的基础功能。此模块中包含的beanfactory类是spring的核心类，负责javabean的配置与管理。它采用factory模式实现了ioc即依赖注入。</p></li><li><p>Beanmodule</p><p>谈到javabean，它是一种 java 类，它遵从一定的设计模式，使它们易于和其他开发工具和组件一起使用。定义 javabean 是一种java 语言写成的可重用组件。要编写javabean，类必须是具体类和公共类，并且具有无参数的构造器。</p></li><li><p>Contextmodule</p><p>pring context模块继承beanfactory（或者说spring核心）类，并且添加了事件处理、国际化、资源装载、透明装载、以及数据校验等功能。它还提供了框架式的bean的访问方式和很多企业级的功能，如jndi访问、支持ejb、远程调用、集成模板框架、email和定时任务调度等。</p></li><li><p>ExpressionLanguagemodule</p></li><li><p>dao模块</p></li></ul><p>dao是 data access object的缩写，dao模式思想是将业务逻辑代码与数据库交互代码分离，降低两者耦合。通过dao模式可以使结构变得更为清晰，代码更为简洁。dao模块提供了jdbc的抽象层，简化了数据库厂商的异常错误（不再从sqlexception继承大批代码），大幅度减少代码的编写，并且提供了对声明式事务和编程式事务的支持。</p><ul><li>orm映射模块</li></ul><p>spring orm 模块提供了对现有orm框架的支持，各种流行的orm框架已经做得非常成熟，并且拥有大规模的市场，spring没有必要开发新的orm工具，它对hibernate提供了完美的整合功能，同时也支持其他orm工具。注意这里spring是提供各类的接口（support），目前比较流行的下层数据库封闭映射框架，如 ibatis, hibernate等</p><p><strong>为什么说Spring是一个容器？</strong></p><p>因为用来形容它用来存储单例的bean对象这个特性。</p><p><strong>Spring配置文件</strong></p><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><p><strong>什么是SpringIOC容器？</strong></p><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p><strong>IOC的优点是什么？</strong></p><p>IOC或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><p><strong>ApplicationContext通常的实现是什么?</strong></p><ul><li>**FileSystemXmlApplicationContext：**此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li><li>**ClassPathXmlApplicationContext：**此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li>**WebXmlApplicationContext：**此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><h3 id="依赖注入">依赖注入</h3><hr><p>什么是Spring的依赖注入？**</p><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><ul><li><p>**构造器依赖注入：**构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 强制依赖</p></li><li><p>**Setter方法注入：**Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 可选依赖</p></li></ul><h3 id="Springbeans">Springbeans</h3><hr><p><strong>什么是Springbeans?</strong></p><p>Springbeans是那些形成Spring应用的主干的java对象。它们被SpringIOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean>的形式定义。</bean></p><p>Spring框架定义的beans都是单件beans。在beantag中有个属性”singleton”，如果它被赋为TRUE，bean就是单件，否则就是一个prototypebean。默认是TRUE，所以所有在Spring框架中的beans缺省都是单件。</p><p><strong>Spring框架中的单例bean是线程安全的吗?</strong></p><p>不，Spring框架中的单例bean不是线程安全的。</p><p><strong>解释Spring框架中bean的生命周期。</strong></p><ul><li>Spring容器从XML文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware接口，Spring传递bean的ID到setBeanName方法。</li><li>如果Bean实现了BeanFactoryAware接口，Spring传递beanfactory给setBeanFactory方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors和bean关联，这些bean的postProcessAfterInitialization()方法将被调用。</li><li>如果bean实现了DisposableBean，它将调用destroy()方法。</li></ul><p><strong>哪些是重要的bean生命周期方法？你能重载它们吗？</strong></p><p>有两个重要的bean生命周期方法，第一个是setup，它是在容器加载bean的时候被调用。第二个方法是teardown它是在容器卸载类的时候被调用。</p><p>Thebean标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><p><strong>什么是Spring的内部bean？</strong></p><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义innerbean，在Spring的基于XML的配置元数据中，可以在<property>或<constructor-arg>元素内使用<bean>元素，内部bean通常是匿名的，它们的Scope一般是prototype。</bean></constructor-arg></property></p><p><strong>在Spring中如何注入一个java集合？</strong></p><p>Spring提供以下几种集合的配置元素：</p><ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为String类型。</props></li></ul><p><strong>什么是bean装配?</strong></p><p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><p><strong>什么是bean的自动装配？</strong></p><p>Spring容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p><p><strong>自动装配有哪些局限性?</strong></p><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p>**模糊特性：**自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><p><strong>解释不同方式的自动装配。</strong></p><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ul><li><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref属性来进行装配。</li><li>**byName：**通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li>**byType:：**通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li><strong>constructor：这个方式类似于</strong>byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>**autodetect：**首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><h3 id="Spring-注解">Spring 注解</h3><hr><p><strong>什么是基于Java的Spring注解配置? 给一些注解的例子.</strong></p><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration注解为例，它用来标记类可以当做一个bean的定义，被SpringIOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><p><strong>什么是基于注解的容器配置?</strong></p><p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p><p>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p><p><strong>怎样开启注解装配？</strong></p><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<a href="context:annotation-config/">context:annotation-config/</a>元素。</p><p><strong>@Required注解</strong></p><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p><p><strong>@Autowired注解</strong></p><p>@Autowired注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p><p><strong>@Qualifier注解</strong></p><p>当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p><h3 id="Spring-数据访问">Spring 数据访问</h3><hr><p><strong>在Spring框架中如何更有效地使用JDBC?</strong></p><p>使用SpringJDBC框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements和queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><p>Add jDBC dependency -&gt; Instance class -&gt; DaoInterface -&gt; JDBCObjectImp</p><p><strong>JdbcTemplate</strong></p><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><p><strong>pring对DAO的支持</strong></p><p>Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，HibernateorJDO结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p><p><strong>使用Spring通过什么方式访问Hibernate?</strong></p><p>在Spring中有两种方式访问Hibernate：</p><p>控制反转HibernateTemplate和Callback。</p><p>继承HibernateDAOSupport提供一个AOP拦截器。</p><p><strong>Spring支持的ORM</strong></p><p>Spring支持以下ORM：</p><ul><li>Hibernate</li><li>iBatis</li><li>JPA(JavaPersistenceAPI)</li><li>TopLink</li><li>JDO(JavaDataObjects)</li><li>OJB</li></ul><p><strong>Spring支持的事务管理类型</strong></p><p>Spring支持两种类型的事务管理：</p><p>· <strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>· **声明式事务管理：**这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><p><strong>你更倾向用那种事务管理类型？</strong></p><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p><h4 id="Spring面向切面编程（AOP）"><strong>Spring面向切面编程（AOP）</strong></h4><hr><p><strong>解释AOP</strong></p><p>面向切面的编程，或AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p><p><strong>Aspect切面</strong></p><p>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在SpringAOP中，切面通过带有@Aspect注解的类实现。</p><p><strong>在SpringAOP中，关注点和横切关注的区别是什么？</strong></p><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p><strong>通知</strong></p><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用五种类型的通知：</p><p><strong>before</strong>：前置通知，在一个方法执行前被调用。</p><p>**after:**在方法执行之后调用的通知，无论方法执行是否成功。</p><p>**after-returning:**仅当方法成功完成后执行的通知。</p><p>**after-throwing:**在方法抛出异常退出时执行的通知。</p><p>**around:**在方法执行之前和之后调用的通知。</p><p><strong>什么是代理?</strong></p><p>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的</p><p><strong>解释基于XMLSchema方式的切面实现。</strong></p><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h4 id="Spring的MVC"><strong>Spring的MVC</strong></h4><hr><p><strong>什么是Spring的MVC框架？</strong></p><p>Spring配备构建Web应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p><p><strong>DispatcherServlet</strong></p><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><p><strong>WebApplicationContext</strong></p><p>WebApplicationContext继承了ApplicationContext并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的servlet。</p><p><strong>什么是SpringMVC框架的控制器？</strong></p><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><p><strong>@Controller注解</strong></p><p>该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用ServletAPI。</p><p><strong>@RequestMapping注解</strong></p><p>该注解是用来映射一个URL到一个类或一个特定的方处理法上。</p><p><strong>返回Json用什么注解？</strong></p><p>@ResponseBody</p><h4 id="Spring事务支持的隔离级别">Spring事务支持的隔离级别</h4><hr><p>Spring 事务上提供以下的隔离级别:</p><ul><li>ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别</li><li>ISOLATION_READ_UNCOMMITTED　: 允许读取未提交的数据变更，可能会导致脏读，幻读或不可重复读</li><li>ISOLATION_READ_COMMITTD : 允许读取为提交数据, 可以阻止脏读，当时幻读或不可重复读仍可能发生</li><li>ISOLATION_REPEATABLE_READ: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生</li><li>ISOLATION_SERIALIZABLE :　完全服从ACID</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本常识&quot;&gt;基本常识&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;使用Spring框架的好处是什么？**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**轻量：**Spring是轻量的，基本的版本大约2MB。&lt;/li&gt;
&lt;li&gt;**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Interview/"/>
    
    
      <category term="spring" scheme="https://wuhewuhe.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>leetcode SQL 175-185整理</title>
    <link href="https://wuhewuhe.github.io/2020/01/26/leetcodeSQL/"/>
    <id>https://wuhewuhe.github.io/2020/01/26/leetcodeSQL/</id>
    <published>2020-01-25T23:03:29.000Z</published>
    <updated>2020-01-26T11:17:50.849Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 例题整理 查询用mysql实现</p><h3 id="175-Combine-Two-Tables组合两个表">175. Combine Two Tables组合两个表</h3><img src="/2020/01/26/leetcodeSQL/sql175.png" alt="sql175" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT P.FirstName, P.LastName, A.City, A.State</span><br><span class="line">FROM Person AS P LEFT JOIN Address AS A</span><br><span class="line">ON P.PersonId &#x3D; A.PersonId;</span><br></pre></td></tr></table></figure><h3 id="176-Second-Highest-Salary-第二高的薪水">176. Second Highest Salary 第二高的薪水</h3><img src="/2020/01/26/leetcodeSQL/sql176.png" alt="sql176" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">select </span><br><span class="line">(SELECT DISTINCT</span><br><span class="line">    Salary </span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">ORDER BY Salary DESC</span><br><span class="line">LIMIT 1 OFFSET 1) as SecondHighestSalary</span><br><span class="line"></span><br><span class="line">2 </span><br><span class="line">select max(salary) as SecondHighestSalary</span><br><span class="line">from employee</span><br><span class="line">where salary &lt; (select max(salary) from employee);</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) AS SecondHighestSalary</span><br></pre></td></tr></table></figure><h3 id="177-Nth-Highest-Salary">177. Nth Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql177.png" alt="sql177" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    declare m int;</span><br><span class="line">    set m &#x3D; n-1;</span><br><span class="line"> RETURN (</span><br><span class="line">   select distinct salary from employee order by salary desc limit m,1</span><br><span class="line"> );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="178-rank-scores">178.rank scores</h3><img src="/2020/01/26/leetcodeSQL/sql178.png" alt="sql178" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(distinct Score) FROM Scores WHERE Score &gt;&#x3D; s.Score) Rank</span><br><span class="line">FROM Scores s</span><br><span class="line">ORDER BY Score desc</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) as tm WHERE s &gt;&#x3D; Score) as Rank</span><br><span class="line">FROM Scores</span><br><span class="line">ORDER BY Score desc</span><br></pre></td></tr></table></figure><h3 id="180-Consecutive-number">180. Consecutive number</h3><img src="/2020/01/26/leetcodeSQL/sql180.png" alt="sql180" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    l1.Num AS ConsecutiveNums</span><br><span class="line">FROM</span><br><span class="line">    Logs l1,</span><br><span class="line">    Logs l2,</span><br><span class="line">    Logs l3</span><br><span class="line">WHERE</span><br><span class="line">    l1.Id &#x3D; l2.Id - 1</span><br><span class="line">    AND l2.Id &#x3D; l3.Id - 1</span><br><span class="line">    AND l1.Num &#x3D; l2.Num</span><br><span class="line">    AND l2.Num &#x3D; l3.Num</span><br></pre></td></tr></table></figure><h3 id="181-Employees-Earning-More-Than-Their-Managers超过经理收入的员工">181. Employees Earning More Than Their Managers超过经理收入的员工</h3><img src="/2020/01/26/leetcodeSQL/sql181.png" alt="sql181" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT E1.Name AS Employee</span><br><span class="line">FROM Employee AS E1 INNER JOIN Employee AS E2</span><br><span class="line">ON E1.ManagerId &#x3D; E2.Id</span><br><span class="line">WHERE E1.Salary &gt; E2.Salary;</span><br></pre></td></tr></table></figure><h3 id="182-Duplicate-Emails查找重复的电子邮箱">182. Duplicate Emails查找重复的电子邮箱</h3><img src="/2020/01/26/leetcodeSQL/sql182.png" alt="sql182" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email</span><br><span class="line">FROM Person</span><br><span class="line">GROUP BY Email</span><br><span class="line">HAVING COUNT(Id) &gt; 1;</span><br></pre></td></tr></table></figure><h3 id="183-Customers-Who-Never-Order">183. Customers Who Never Order</h3><img src="/2020/01/26/leetcodeSQL/sql183.png" alt="sql183" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.name as Customers</span><br><span class="line">from customers as c</span><br><span class="line">where c.id not in (select o.CustomerId from orders as o)</span><br></pre></td></tr></table></figure><h3 id="184-Department-Highest-Salary">184. Department Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql184.png" alt="sql184" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    Department.name AS &#39;Department&#39;,</span><br><span class="line">    Employee.name AS &#39;Employee&#39;,</span><br><span class="line">    Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department ON Employee.DepartmentId &#x3D; Department.Id</span><br><span class="line">WHERE</span><br><span class="line">    (Employee.DepartmentId , Salary) IN</span><br><span class="line">    (   SELECT</span><br><span class="line">            DepartmentId, MAX(Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        GROUP BY DepartmentId</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="185-Departement-top-3-salary">185. Departement top 3 salary</h3><img src="/2020/01/26/leetcodeSQL/sql185.png" alt="sql185" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee e1</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department d ON e1.DepartmentId &#x3D; d.Id</span><br><span class="line">WHERE</span><br><span class="line">    3 &gt; (SELECT</span><br><span class="line">            COUNT(DISTINCT e2.Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee e2</span><br><span class="line">        WHERE</span><br><span class="line">            e2.Salary &gt; e1.Salary</span><br><span class="line">                AND e1.DepartmentId &#x3D; e2.DepartmentId</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQL 例题整理 查询用mysql实现&lt;/p&gt;
&lt;h3 id=&quot;175-Combine-Two-Tables组合两个表&quot;&gt;175. Combine Two Tables组合两个表&lt;/h3&gt;
&lt;img src=&quot;/2020/01/26/leetcodeSQL/sql175.p
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Interview/"/>
    
    
      <category term="sql" scheme="https://wuhewuhe.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Spring, Spring MVC, SpringBoot介绍</title>
    <link href="https://wuhewuhe.github.io/2020/01/26/spring/"/>
    <id>https://wuhewuhe.github.io/2020/01/26/spring/</id>
    <published>2020-01-25T23:00:04.000Z</published>
    <updated>2020-01-26T16:43:18.698Z</updated>
    
    <content type="html"><![CDATA[<p>浅谈spring springMVC Springboot三者</p><blockquote><p>The <strong>Spring Framework</strong> is an application framework and inversion of control container for the Java platform. The framework’s core features can be used by any Java application, but there are extensions for building web applications on top of the Java EE (Enterprise Edition) platform. Although the framework does not impose any specific programming model, it has become popular in the Java community as an addition to, or even replacement for the Enterprise JavaBeans (EJB) model. The Spring Framework is open source.</p></blockquote><h4 id="什么是Spring">什么是Spring</h4><p>我们说到Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，<strong>通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等</strong>，比如基于Spring的项目里经常能看到的 <code>Bean</code> ，它代表的就是由Spring管辖的对象。</p><p>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个 <code>WelcomeService</code> 服务接口，一般情况下都是通过 <code>WelcomeService service = new WelcomeServiceImpl();</code> 创建实例并进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> WelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换 <code>WelcomeServiceImpl</code> 为一个 <code>MockWelcomeServiceImpl</code> ，以方便测试，怎么办？没有其他办法，只有改代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> MockWelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；<br>下面看通过Spring的IOC如何实现，首先将 <code>WelcomeService</code> 交由Spring管理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.WelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/welcome"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String welcome() &#123;</span><br><span class="line">        <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，只需要更改配置文件，将 <code>WelcomeService</code> 对应的实现改为 <code>MockWelcomeServiceImpl</code> 即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这种方式对业务代码没有任何侵入，<strong>它有效的实现松耦合</strong>，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等</p><p><strong>纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案</strong></p><h4 id="什么是Spring-MVC？">什么是Spring MVC？</h4><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），<strong>主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易</strong>，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.qgd.oms.web.common.mvc.OmsDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/css/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">location</span>=<span class="string">"/static/views/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/fonts/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/lib/ueditor/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/img/"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.validationQuery&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultAutoCommit"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxOpenPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"configService"</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.ConfigService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configStore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.impl.DbConfigStore"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskScheduler"</span> <span class="attr">ref</span>=<span class="string">"defaultScheduler"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"refreshInterval"</span> <span class="attr">value</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若需添加其它功能，如security，则需添加对应配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/css/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/js/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/img/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span> <span class="attr">entry-point-ref</span>=<span class="string">"omsAuthenticationEntryPoint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logout</span> <span class="attr">logout-url</span>=<span class="string">"/omsmc/authentication/logout/*"</span> <span class="attr">success-handler-ref</span>=<span class="string">"omsLogoutSuccessHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">logout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/omsmc/authentication/login*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/ms/**/*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/**'</span> <span class="attr">access</span>=<span class="string">"authenticated"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;security:form-login /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-filter</span> <span class="attr">ref</span>=<span class="string">"omsUsernamePasswordAuthenticationFilter"</span> <span class="attr">position</span>=<span class="string">"FORM_LOGIN_FILTER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remember-me</span> <span class="attr">services-ref</span>=<span class="string">"omsRememberMeServices"</span> <span class="attr">key</span>=<span class="string">"yfboms"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h4 id="什么是Spring-Boot？">什么是Spring Boot？</h4><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node. Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于<strong>实现自动配置，降低项目搭建的复杂度</strong>，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入spring-boot-starter-web依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-starter-web&lt;/</span>artifactId&gt;</span><br><span class="line">&lt;<span class="regexp">/dependency&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Spring Boot应用，直接写业务逻辑即可</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"how are you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MockServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为 <code>spring-boot-starter-web</code> 模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是<strong>约定优于配置</strong>原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持</p><p>在Spring Boot中，你会发现你引入的所有包都是<em>starter</em>形式，如：</p><ul><li><code>spring-boot-starter-web-services</code> ，针对SOAP Web Services</li><li><code>spring-boot-starter-web</code> ，针对Web应用与网络接口</li><li><code>spring-boot-starter-jdbc</code> ，针对JDBC</li><li><code>spring-boot-starter-data-jpa</code> ，基于hibernate的持久层框架</li><li><code>spring-boot-starter-cache</code> ，针对缓存支持</li></ul><p>Spring Boot对starter的解释如下：</p><blockquote><p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</p></blockquote><h1>Spring，Spring MVC，Spring Boot 三者比较</h1><p>其实写到这里，很多读者应该已经清楚，这三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能，下面用一张图来描述三者的关系：</p><img src="/2020/01/26/spring/mvc_spring_boot.png" alt="mvc_spring_boot" style="zoom:33%;"><p>最后一句话总结：<strong>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浅谈spring springMVC Springboot三者&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;Spring Framework&lt;/strong&gt; is an application framework and inversion of co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>sql高频概念</title>
    <link href="https://wuhewuhe.github.io/2020/01/25/sqlExecuteProcess/"/>
    <id>https://wuhewuhe.github.io/2020/01/25/sqlExecuteProcess/</id>
    <published>2020-01-25T22:18:26.000Z</published>
    <updated>2020-01-26T10:56:37.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SQL">SQL</h4><blockquote><p>SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system.</p></blockquote><h4 id="sql语法的分析是从右到左">sql语法的分析是从右到左</h4><p>1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。<br>2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。<br>3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。<br>5）选择优化器，不同的优化器一般产生不同的“执行计划”<br>6）选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。<br>7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。<br>8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>9）运行“执行计划”</p><h4 id="select-语句执行顺序">select 语句执行顺序</h4><p>1 from子句组装来自不同数据源的数据；</p><p>2 where子句基于指定的条件对记录行进行筛选；</p><p>3 group by子句将数据划分为多个分组；</p><p>4 使用聚集函数进行计算；</p><p>5 使用having子句筛选分组；</p><p>6 计算所有的表达式；</p><p>7 select 的字段；</p><p>8 使用order by对结果集进行排序。<br>SQL语言不同于其他编程语言的最明显特征是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语句中，第一个被处理的子句式FROM，而不是第一出现的SELECT。SQL查询处理的步骤序号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)SELECT (9) DISTINCT (11) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(1)  FROM &lt;left_table&gt;</span><br><span class="line">(3) &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(2) ON &lt;join_condition&gt;</span><br><span class="line">(4) WHERE &lt;where_condition&gt;</span><br><span class="line">(5) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6) WITH &#123;CUBE | ROLLUP&#125;</span><br><span class="line">(7) HAVING &lt;having_condition&gt;</span><br><span class="line">(10) ORDER BY &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><h4 id="where与having的区别">where与having的区别</h4><p>对需要进行分组的数据进行限制，汇总函数不能用在 WHERE 子句中，而是要用HAVING 子句 。HAVING子句允许你将汇总函数作为条件。</p><h4 id="UNION与UNION-ALL合并">UNION与UNION ALL合并</h4><p>UNION将返回两个查询的结果并去除其中的重复部分，UNION ALL与UNION一样对表进行了合并，但是它不去掉重复的记录。</p><h4 id="数据定义语言">数据定义语言</h4><p>Data definition language</p><blockquote><p>A <strong>data definition</strong> or <strong>data description language</strong> (<strong>DDL</strong>) is a syntax similar to a computer <a href="https://en.wikipedia.org/wiki/Programming_language" target="_blank" rel="noopener">programming language</a> for defining <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener">data structures</a>, especially <a href="https://en.wikipedia.org/wiki/Database_schema" target="_blank" rel="noopener">database schemas</a>. DDL statements create and modify database objects such as tables, indexes, and users. Common DDL statements are CREATE, ALTER, and DROP</p></blockquote><p>类似于我们编程的数据结构，用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束，DDL不需要commit.</p><h4 id="数据操作语言">数据操作语言</h4><p><strong>DML</strong>（<strong>Data Manipulation Language</strong>）<strong>数据操纵语言</strong>statements are used for managing data within schema objects.</p><p>由DBMS提供，用于让用户或程序员使用，实现对数据库中数据的操作。<br>DML分成交互型DML和嵌入型DML两类。<br>依据语言的级别，DML又可分成过程性DML和非过程性DML两种。<br>需要commit.<br>SELECT<br>INSERT<br>UPDATE<br>DELETE<br>MERGE<br>CALL<br>EXPLAIN PLAN<br>LOCK TABLE</p><h4 id="数据库控制语言"><strong>数据库控制语言</strong></h4><p><strong>DCL</strong>（<strong>Data Control Language</strong>）<strong>数据库控制语言</strong> 授权，角色控制等<br>GRANT 授权<br>REVOKE 取消授权</p><h4 id="TCL-（Transaction-Control-Language）-事务控制语言">TCL**（<strong>Transaction Control Language</strong>）**事务控制语言</h4><p>SAVEPOINT 设置保存点<br>ROLLBACK 回滚<br>SET TRANSACTION</p><h4 id="Turncate-和-drop">Turncate 和 drop</h4><p>turncate只删除表中的数据，不触碰表的结构。drop删除整个表，<strong>小心使用drop与turncate，因为他们是数据定义语言，不能roll back</strong></p><h4 id="MINUS相减">MINUS相减</h4><p>返回的记录是存在于第一个表中但不存在于第二个表中的记录。如果解释器不支持一般用table_name1 t2 LEFT OUTER JOIN table_name2 t2 WHERE t2.col_name IS NULL;</p><h4 id="关于空值【高频】"><strong>关于空值【高频】</strong></h4><p>SQL中的空值是NULL，空值是不能用等号来比较的，而是要用IS NULL或者IS NOT NULL来判断值是否为空值。</p><p>面试的时候往往需要在输出结果中对空值进行处理，这时候最好用的就是IFNULL函数和ISNULL函数了。<strong>IFNULL</strong>是当SQL查询某个字段为空的时候，查询结果中设置其值为默认值。<strong>ISNULL</strong>使用指定的替换值替换 NULL：<br>ISNULL (检查的对象, 如果为空值替换的值)</p><p>可惜，MySQL中ISNULL只是用来判断是否为空，不能实现替换功能，所以用IFNULL代替，语法和上面的ISNULL一样。</p><h4 id="返回前几行【高频】"><strong>返回前几行【高频】</strong></h4><p>MySQL的LIMIT+数字和TOP子句是等价的，并非所有的数据库系统都支持 TOP 子句。所以我们来简单看一下limit+offset的用法。以下这两句都合乎语法，但是有区别：</p><p>select * from table_name limit 3,1;        # 跳过前3条数据，从数据库中第4条开始查询，取一条数据，即第4条数据<br>select * from table_name limit 3 offset 1;   # 从数据库中的第2条数据开始查询3条数据，即第2条到第4条</p><p>记住这两句，再加上order by column_name (desc) 就能应付“消费第二多的客户”、“点击量第5到20名”之类的问题的。</p><h4 id="条件语句【中频】"><strong>条件语句【中频】</strong></h4><p>条件语句考得并不多，但是如果很久不用MySQL就容易忘记。MySQL里常用的条件语句是Case。Case语句分为两种：简单Case函数和Case搜索函数。</p><p>- 简单Case函数：<br>CASE gender WHEN ‘0’ THEN ‘male’ WHEN ‘1’ THEN ‘female’ ELSE ‘others’ END<br>- Case搜索函数：<br>CASE WHEN age &lt; 18 THEN ‘未成年人’ WHEN age &lt; 60 THEN ‘成年人’ ELSE ‘老年人’ END</p><p>Case语句只返回第一个符合条件的结果，剩下的条件会被自动忽略，比如上例中一个数据的age为16，那么它就在第一个case中被返回，不会进入第二个when中进行判断，因此返回’未成年人’而不是’成年人’。</p><h4 id="随机抽样【低频】"><strong>随机抽样【低频】</strong></h4><p>有时候面试会考到如何在SQL表中随机抽样，这时候就要用到RAND()函数。</p><p>通常被面试者的第一反应是：SELECT * FROM table ORDER BY RAND() LIMIT 10000，这样来抽取一万个样本。但是如果数据量很大，上述的做法太慢了：它对于每一行都用了RAND()函数，这一步复杂度是O(n)；然后再排序，这一步的复杂度O(nlogn)。</p><p>所以可以改用这个方法：SELECT * FROM table WHERE RAND() &lt;= .3，这样可以抽出约30%的数据，然后再用TOP或者LIMIT子句。</p><h4 id="自然连接和内链接区别">自然连接和内链接区别</h4><p>自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列，但是相同列的数量不能大于1</p><h4 id="subquery和join的对比">subquery和join的对比</h4><p>与子查询相比，join的查询效率还是比子查询高，因为使用子查询时，数据库还要建一张临时表</p><h4 id="子查询执行顺序">子查询执行顺序</h4><p>带有子查询时，先执行子查询在执行主查询</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;SQL&quot;&gt;SQL&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL is a domain-specific language used in programming and designed for managing data held in a relatio
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Interview/"/>
    
    
      <category term="sql" scheme="https://wuhewuhe.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>20道SQL 面试题帮你拿到第一个offer</title>
    <link href="https://wuhewuhe.github.io/2020/01/25/sql20questions/"/>
    <id>https://wuhewuhe.github.io/2020/01/25/sql20questions/</id>
    <published>2020-01-25T21:38:55.000Z</published>
    <updated>2020-01-25T21:41:50.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本语法">基本语法</h3><p><strong>创建表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE table_name (</span><br><span class="line"> column1 datatype null or not null(optional),</span><br><span class="line"> column2 datatype null or not null(optional),</span><br><span class="line"> column3 datatype null or not null(optional),</span><br><span class="line">  ....</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure><p><strong>删除表中数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><p><strong>修改：添加列，删除列，修改列名，数据类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP COLUMN DateOfBirth;</span><br><span class="line"></span><br><span class="line">-- 修改列名</span><br><span class="line">alter table table_name </span><br><span class="line">rename column oldname to newname</span><br><span class="line"></span><br><span class="line">-- 修改列的数据类型</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name datatype;</span><br></pre></td></tr></table></figure><h4 id="常见问题">常见问题</h4><p><strong>1 查询姓“孟”老师的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(教师号)</span><br><span class="line">from teacher</span><br><span class="line">where 教师姓名 like &#39;孟%&#39;;</span><br></pre></td></tr></table></figure><p><strong>2 查询课程编号为“0002”的总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sum(成绩)</span><br><span class="line">from score</span><br><span class="line">where 课程号 &#x3D; &#39;0002&#39;;</span><br></pre></td></tr></table></figure><p><strong>3 查询选了课程的学生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct 学号) as 学生人数 </span><br><span class="line">from score;</span><br></pre></td></tr></table></figure><h4 id="练习-分组">练习 分组</h4><p><strong>4 查询各科成绩最高和最低的分， 以如下的形式显示：课程号，最高分，最低分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号,max(成绩) as 最高分,min(成绩) as 最低分</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>5 查询每门课程被选修的学生</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, count(学号)</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>6 查询男生、女生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 性别,count(*)</span><br><span class="line">from student</span><br><span class="line">group by 性别;</span><br></pre></td></tr></table></figure><h4 id="分组结果的条件">分组结果的条件</h4><p><strong>注意使用group by  having</strong></p><p><strong>7 查询平均成绩大于60分学生的学号和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, avg(成绩)</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having avg(成绩)&gt;60;</span><br></pre></td></tr></table></figure><p><strong>8 查询student表中重名的学生，结果包含id和name，按name, id升序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name</span><br><span class="line">from student</span><br><span class="line">where name in (</span><br><span class="line">select name from student group by name having(count(*) &gt; 1)</span><br><span class="line">) order by name;</span><br></pre></td></tr></table></figure><p><strong>9 在student_course表中查询平均分不及格的学生，列出学生id和平均分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sid,avg(score) as avg_score</span><br><span class="line">from student_course</span><br><span class="line">group by sid having(avg_score&lt;60);</span><br></pre></td></tr></table></figure><p><strong>10 查询至少选修两门课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, count(课程号) as 选修课程数目</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><p><strong>11查询不及格的课程并按课程号从大到小排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号 </span><br><span class="line">from score </span><br><span class="line">where score &lt; 60 </span><br><span class="line">group by 课程号desc</span><br></pre></td></tr></table></figure><p><strong>12 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">group by 课程号</span><br><span class="line">order by 平均成绩 asc,课程号 desc;</span><br></pre></td></tr></table></figure><p><strong>13 查询两门以上不及格课程的同学的学号及其平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号， avg（成绩） as 平均成绩</span><br><span class="line">from score</span><br><span class="line">where score &lt; 60</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><h4 id="复杂查询-子查询">复杂查询 : 子查询</h4><p><strong>14 查询所有课程成绩小于60分学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in （ select 学号</span><br><span class="line">from student</span><br><span class="line">where score &lt; 60)</span><br></pre></td></tr></table></figure><p><strong>15 查询没有学全所有课的学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号) &lt; (select count(课程号) from course))</span><br></pre></td></tr></table></figure><p><strong>16 查询出只选修了两门课程的全部学生的学号和姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from course</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&#x3D;2）;</span><br></pre></td></tr></table></figure><h4 id="多表查询">多表查询</h4><h5 id="区分概念">区分概念</h5><p>表A记录如下：</p><p>aID　　　　　aNum<br>1　　　　　a20050111<br>2　　　　　a20050112<br>3　　　　　a20050113<br>4　　　　　a20050114<br>5　　　　　a20050115</p><p>表B记录如下:<br>bID　　　　　bName<br>1　　　　　2006032401<br>2　　　　　2006032402<br>3　　　　　2006032403<br>4　　　　　2006032404<br>8　　　　　2006032408</p><p><strong>nature join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from A,B</span><br><span class="line">where A.aID &#x3D; B.bId</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>inner join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">innerjoin B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>left join</strong></p><img src="/2020/01/25/sql20questions/leftjoin.png" alt="leftjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">left join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL</p><p><strong>right join</strong></p><img src="/2020/01/25/sql20questions/rightjoin.png" alt="rightjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">right join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>NULL　　　　　NULL　　　　　8　　　　　2006032408</p><p><strong>full join</strong></p><img src="/2020/01/25/sql20questions/fulljoin.png" alt="fulljoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM A</span><br><span class="line">FULL OUTER JOIN B</span><br><span class="line">ON A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL　　　　　NULL　　　　NULL　　　　　82006032408</p><p><strong>17 查询所有学生的学号、姓名、选课数、总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selecta.学号,a.姓名,count(b.课程号) as 选课数,sum(b.成绩) as 总成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号;</span><br></pre></td></tr></table></figure><p><strong>18 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select a.学号,a.姓名, avg(b.成绩) as 平均成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号</span><br><span class="line">having avg(b.成绩)&gt;85;</span><br></pre></td></tr></table></figure><p><strong>19 查询学生的选课情况：学号，姓名，课程号，课程名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.学号, a.姓名, c.课程号,c.课程名称</span><br><span class="line">from student a inner join score b on a.学号&#x3D;b.学号</span><br><span class="line">inner join course c on b.课程号&#x3D;c.课程号;</span><br></pre></td></tr></table></figure><p><strong>20 查询出每门课程的及格人数和不及格人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select 课程号,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 及格人数,</span><br><span class="line">sum(case when 成绩 &lt;  60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 不及格人数</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p>使用分段[100-85], [85-70], [70-60], [&lt;60]来统计各科成绩，分别统计：各分数段人数，课程号和课程名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select a.课程号,b.课程名称,</span><br><span class="line">sum(case when 成绩 between 85 and 100 </span><br><span class="line"> then 1 else 0 end) as &#39;[100-85]&#39;,</span><br><span class="line">sum(case when 成绩 &gt;&#x3D;70 and 成绩&lt;85 </span><br><span class="line"> then 1 else 0 end) as &#39;[85-70]&#39;,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 and 成绩&lt;70  </span><br><span class="line"> then 1 else 0 end) as &#39;[70-60]&#39;,</span><br><span class="line">sum(case when 成绩&lt;60 then 1 else 0 end) as &#39;[&lt;60]&#39;</span><br><span class="line">from score as a right join course as b </span><br><span class="line">on a.课程号&#x3D;b.课程号</span><br><span class="line">group by a.课程号,b.课程名称;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本语法&quot;&gt;基本语法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建表&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Interview/"/>
    
    
      <category term="sql" scheme="https://wuhewuhe.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>从零开始手把手教大家如何制作网站（进阶版）</title>
    <link href="https://wuhewuhe.github.io/2020/01/18/setupSiteImprove/"/>
    <id>https://wuhewuhe.github.io/2020/01/18/setupSiteImprove/</id>
    <published>2020-01-18T22:48:54.000Z</published>
    <updated>2020-01-19T21:28:12.134Z</updated>
    
    <content type="html"><![CDATA[<p>第一次知道hexo，next风格是在刷算法题时看一些回复，然后无意中看到了一个名为<a href="https://tding.top/" target="_blank" rel="noopener">小丁的博客</a>的网站，对比了一下他和我最初自己写blog网站，感觉自己的low爆了，于是就决定去重新做一个炫酷的</p><img src="/2020/01/18/setupSiteImprove/ding.png" alt="ding" style="zoom:33%; "><p>通过上一片文章，我们对hexo博客框架有了基本的认识，然而要想做出一些炫酷的效果，我们可以从这一篇文章中找到自己想要的摘取</p><h4 id="附加选项">附加选项</h4><p>1 动态背景</p><p>2 鼠标点击气球爆炸效果</p><p>3 右上角加加入github装横</p><p>4 RSS xml 全览</p><p>5 小图标链接</p><p>6 加入订阅 打赏功能</p><p>7 评论功能</p><p>8 个性化侧边栏</p><p>9 原创声明</p><p>10 网站访问量人数，次数，阅读数统计</p><h4 id="1-动态背景">1 动态背景</h4><p><strong>具体实现方法</strong></p><p>注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）<br>打开 /next/_config.yml, 在里面添加如下代码：(可以放在最后面)</p><p>打开 <code>/next/_config.yml</code> , 在里面添加如下代码：(可以放在最后面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># --------------------------------------------------------------</span><br><span class="line"># background settings</span><br><span class="line"># --------------------------------------------------------------</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https:&#x2F;&#x2F;github.com&#x2F;hustcc&#x2F;canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure><p><strong>实现效果图</strong></p><p><a href="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" alt="img"></a></p><p><strong>如果你感觉默认的线条太多的话 可以这么设置</strong></p><p>在上一步修改 <code>_layout.swig</code> 中，把刚才的这些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;</span><br><span class="line">color&#x3D;&quot;0,0,255&quot; opacity&#x3D;&#39;0.7&#39; zIndex&#x3D;&quot;-2&quot; count&#x3D;&quot;99&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>配置项说明</strong></p><ul><li><code>color</code> ：线条颜色, 默认: <code>'0,0,0'</code> ；三个数字分别为(R, G, B)</li><li><code>opacity</code> : 线条透明度（0~1）, 默认: <code>0.5</code></li><li><code>count</code> : 线条的总数量, 默认: <code>150</code></li><li><code>zIndex:</code> 背景的z-index属性，css属性用于控制所在层的位置, 默认: <code>-1</code></li></ul><h4 id="2-鼠标点击气球爆炸效果">2 鼠标点击气球爆炸效果</h4><img src="/2020/01/18/setupSiteImprove/ballon.png" alt="ballon" style="zoom:33%; "><p><strong>具体实现方法</strong></p><p>首先在 <code>themes/next/source/js/src</code> 里面建一个叫fireworks.js的文件，然后粘贴如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure><p>打开 <code>themes/next/layout/_layout.swig</code> , 在最底部的 <code>&lt;/body&gt;</code> 上面粘贴如下如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.fireworks %&#125;</span><br><span class="line">   &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>打开主题配置文件，在里面最后写下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Fireworks</span><br><span class="line">fireworks: true</span><br></pre></td></tr></table></figure><h4 id="3-右上角加加入github装横">3 右上角加加入github装横</h4><h4 id="img-src-hautdroite-png-alt-hautdroite-style-zoom-50"><img src="/2020/01/18/setupSiteImprove/hautdroite.png" alt="hautdroite" style="zoom:50%; "></h4><p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">这里</a>挑选自己喜欢的样式，然后复制代码：</p><p>我自己选择的是这个样式：</p><img src="/2020/01/18/setupSiteImprove/folkgithub.png" alt="folkgithub" style="zoom:50%; "><p>然后粘贴刚才复制的代码到 <code>themes/next/layout/_layout.swig</code> 文件中(放在<code> </code>的下面)，并把<code> href</code>改为你的github地址, 例如我的<em>github链接是</em>： <strong><a href="https://github.com/wuhewuhe" target="_blank" rel="noopener">https://github.com/wuhewuhe</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe&quot; class&#x3D;&quot;github-corner&quot; aria-label&#x3D;&quot;View source on GitHub&quot;&gt;&lt;svg width&#x3D;&quot;80&quot; height&#x3D;&quot;80&quot; viewBox&#x3D;&quot;0 0 250 250&quot; style&#x3D;&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;path d&#x3D;&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill&#x3D;&quot;currentColor&quot; style&#x3D;&quot;transform-origin: 130px 106px;&quot; class&#x3D;&quot;octo-arm&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill&#x3D;&quot;currentColor&quot; class&#x3D;&quot;octo-body&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;&#x2F;a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h4 id="4-RSS-xml-全览">4 RSS xml 全览</h4><img src="/2020/01/18/setupSiteImprove/rss.png" alt="rss" style="zoom:50%; "><p><strong>具体实现</strong></p><p>安装 Hexo 插件：(这个插件会放在 <code>node_modules</code> 这个文件夹里)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>进入根目录下的*_config.yml*, 修改如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line"></span><br><span class="line">## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line"></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p>然后打开next主题文件夹里面的 <code>_config.yml</code> , 在里面配置为如下样子：(就是在 <code>rss:</code> 的后面加上 <code>/atom.xml</code> , <strong>注意</strong>在冒号后面要加一个空格)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&#39;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure><p>配置完之后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>重新生成一次，你会在 <code>./public</code> 文件夹中看到 <code>atom.xml</code> 文件</p><h4 id="5-小图标链接">5 小图标链接</h4><img src="/2020/01/18/setupSiteImprove/icon.png" alt="icon" style="zoom:50%; "><p><strong>具体实现</strong></p><p>编辑Next主题下的_config.yml文件，next主题对应四种不同的布局Muse是紧凑型，Mist的默认sidebar在上面，Pisces和Gemini除了sidebar位置没发现特别大的区别。我习惯把菜单栏放在左边，所以用了Gemini的sechema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><p>然后找到下面的<em>social link</em>选项，进行如下格式编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe || github</span><br><span class="line">  E-Mail: mailto:dachichiwuhe@gmail.com || envelope</span><br><span class="line">  Linkedin: https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;he-wu-15321b137&#x2F; ||  linkedin</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100013356700523 || facebook</span><br><span class="line">  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  YouTube: https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC3brgfzjExkGq-qkp3vNNrw || youtube</span><br><span class="line">  Instagram: https:&#x2F;&#x2F;www.instagram.com&#x2F;wu.6971&#x2F; || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><p>||的意思是前面为对应链接，后面为图标</p><p>最后设置下面的social icon</p><p>social_icons:<br>enable: true<br>icons_only: false<br>transition: false</p><h4 id="6-加入订阅打赏功能">6 加入订阅打赏功能</h4><img src="/2020/01/18/setupSiteImprove/donate.png" alt="donate" style="zoom:33%;"><p>如果大家使用的next主题5.1版本之上的的话，那么编辑next下的_config.yml文件如下：</p><h1>Wechat Subscriber</h1><p>wechat_subscriber:<br>enabled: true<br>qcode: /images/wechat-qrcode.png<br>description: subscribe to my blog by scanning my public wechat account</p><h1>Reward</h1><p>reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！<br>wechatpay: /images/wechat.jpeg<br>alipay: /images/ali.jpeg<br>#bitcoin: /images/bitcoin.png</p><p>添加自己微信二维码照片到next下的images文件下，然后修改相应的提示语</p><img src="/2020/01/18/setupSiteImprove/images.png" alt="images" style="zoom:33%;"><h4 id="7-评论功能">7 评论功能</h4><img src="/2020/01/18/setupSiteImprove/Comments.png" alt="Comments" style="zoom:33%;"><p>这个功能有不同的实现方法和插件，像valine，gitment，gitalk，那么以我为准，我就讲我的方法(<strong>很不幸的发现现在很久没人维护，不能使用了</strong>)</p><blockquote><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p></blockquote><p><strong>使用 <code>Gitment</code></strong></p><ul><li><p>首先要有github帐号</p></li><li><p>接着<a href="https://github.com/settings/profile" target="_blank" rel="noopener">注册 OAuth Application</a></p><img src="/2020/01/18/setupSiteImprove/ouath.png" alt="ouath" style="zoom:33%;"></li><li><p>要确保填入正确的 callback URL（一般是网站的域名，如 <a href="https://wuhewuhe.github.io/">https://wuhewuhe.github.io/</a>)</p></li><li><p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p></li><li><p>这个页面，你还可以知道application拥有者：owner</p></li></ul><p>打开Next主题的 <code>_config.yml</code> 文件, 在评论相关设置的区域添加下面的代码, 并根据 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment 文档</a>说明来添加相应的值</p><img src="/2020/01/18/setupSiteImprove/gitment.png" alt="gitment" style="zoom:33%;"><p>确认 <code>next/layout/_partials/comments.swig</code> 是否有如下代码：</p><img src="/2020/01/18/setupSiteImprove/comment.png" alt="comment" style="zoom:50%;"><h4 id="8-个性化侧边栏">8 个性化侧边栏</h4><img src="/2020/01/18/setupSiteImprove/sidebar.png" alt="sidebar" style="zoom:33%;"><p><strong>具体实现</strong></p><p>我们可以根据自己需要添加左侧menu，比如我自定义about，photo和commonweal三个界面</p><p>首先，编辑next主题下的_config.yml文件，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> </span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> </span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> </span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> </span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || /sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> </span><br><span class="line">  <span class="comment">#top: /top/ || signal</span></span><br><span class="line">  <span class="attr">photo:</span> <span class="string">/photo/</span></span><br></pre></td></tr></table></figure><p>然后分别生成三个文章，注意关掉评论，没有分类和标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n 404</span><br><span class="line">hexo n about</span><br><span class="line">hexo n photo</span><br></pre></td></tr></table></figure><h4 id="9-原创声明">9 原创声明</h4><img src="/2020/01/18/setupSiteImprove/invent.png" alt="invent" style="zoom:50%; "><p><strong>具体实现</strong></p><p>在目录 <code>next/layout/_macro/下</code> 添加 <code>my-copyright.swig</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-author&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.author&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; post.author | default(config.author) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.link&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.license_title&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; __(&#39;post.copyright.license_content&#39;, theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，post的预定义link是用的根目录下的url所以需要确定url对应的是自己的网站地址：如下图所示：</p><img src="/2020/01/18/setupSiteImprove/post_url.png" alt="post_url" style="zoom:50%; "><p>然后编辑next主题下的_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;3.0&#x2F;</span><br></pre></td></tr></table></figure><h4 id="10-网站访问量人数，次数，阅读数统计">10 网站访问量人数，次数，阅读数统计</h4><img src="/2020/01/18/setupSiteImprove/visit.png" alt="visit" style="zoom:45%; "><p><strong>具体实现</strong></p><p>关于网站访问人数这块我也是踩过很多的雷，出现了好几次改了之后没效果的情况，这里我为大家一一细说。</p><p><strong>改法1</strong> 使用next主题 5.1版本以上</p><p>打开主题的配置文件 <code>/theme/next/_config.yml</code> ，找到如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: false</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 的值由 <code>false</code> 改为 <code>true</code> ，便可以看到页脚出现访问量，上述配置表示：</p><ul><li><p><code>site_uv</code> 表示是否显示整个网站的UV数</p></li><li><p><code>site_pv</code> 表示是否显示整个网站的PV数</p></li><li><p><code>page_pv</code> 表示是否显示每个页面的PV数</p></li></ul><p>表示是否显示每个页面的PV数</p><p>当然，对于不蒜子的配置可以随意更改，一下附上本人的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: 访客数</span><br><span class="line">  site_uv_footer: 人</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: 总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;  阅读数</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>使用 <code>hexo s</code> 部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用 <code>localhost:4000</code> 进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p><p><strong>改法2</strong> 引用busuanzi脚本 同用法通用法</p><p>要使用不蒜子必须在页面中引入 <code>busuanzi.js</code> ，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>本人使用的是next主题，所以在 <code>themes/next/layout/_third-party/analytic/busuanzi-count.swig</code> 中添加上述脚本，也可以把脚本添加在footer或者header中，如果使用的是其他主题，大致也是一样的，不过可能后缀是ejs，没有影响。</p><figure class="highlight plain"><figcaption><span>*if* theme.busuanzi_count.site_uv %&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;span *class*&#x3D;&quot;site-uv&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125;</span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.site_pv %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;span *class*&#x3D;&quot;site-pv&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.page_pv %&#125;</span><br><span class="line"></span><br><span class="line">   &lt;span *class*&#x3D;&quot;page_pv&quot;&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>hexo确实是一个功能很强大，高度集成的框架，插件非常多，像我使用过的还有热度搜索，文章推荐，文章链接等，大家可以去<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>一一探索, 网站支持中文确实方便大家阅读。以上两篇文章是我自己的学习笔记，也同样是我对hexo的一点点小小见解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次知道hexo，next风格是在刷算法题时看一些回复，然后无意中看到了一个名为&lt;a href=&quot;https://tding.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小丁的博客&lt;/a&gt;的网站，对比了一下他和我最初自己写blog网站，感觉自
      
    
    </summary>
    
    
      <category term="Web" scheme="https://wuhewuhe.github.io/categories/Web/"/>
    
    
      <category term="blog" scheme="https://wuhewuhe.github.io/tags/blog/"/>
    
  </entry>
  
</feed>
