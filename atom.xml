<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>He WU</title>
  
  <subtitle>stay hungry, stay foolish, never give up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuhewuhe.github.io/"/>
  <updated>2020-02-16T19:42:38.718Z</updated>
  <id>https://wuhewuhe.github.io/</id>
  
  <author>
    <name>WU He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Exception处理</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/exceptionChec-k/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/exceptionChec-k/</id>
    <published>2020-02-16T19:40:25.000Z</published>
    <updated>2020-02-16T19:42:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。</p><p>error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。</p><p>exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题</p><ul><li>先来看看java中异常的体系结构图解</li></ul><img src="/2020/02/16/exceptionChec-k/../Desktop/屏幕快照 2020-02-16 20.07.13.png" alt="屏幕快照 2020-02-16 20.07.13" style="zoom:50%; "><p>首先说明一点，java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。</p><p><strong>运行时异常和非运行时异常</strong><br>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择在运行时捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>CheckedException成为编译时异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><p><strong>Java中异常处理机制的原理</strong></p><p>Java通过面向对象的方式对异常进行处理，Java把异常按照不同的类型进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它都是Throwable</p><p>或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java的</p><p>异常处理是通过5个关键词来实现的：try catch  throw throws finally。</p><p>一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws），我们可以通过它的类型来捕捉它，或最后由缺省处理器来处理它（finally）。</p><p>try：用来指定一块预防所有异常的程序</p><p>catch：紧跟在try后面，用来捕获异常</p><p>throw：用来明确的抛出一个异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; throw </span><br><span class="line">public class throwException &#123;</span><br><span class="line">static void checkAge(int age) &#123;</span><br><span class="line">if (age &lt; 18) &#123;</span><br><span class="line">throw new ArithmeticException(&quot;Access denied - You must be at least 18 years old.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Access granted - You are old enough!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">checkAge(15); &#x2F;&#x2F; Set age to 15 (which is below 18...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws：用来标明一个成员函数可能抛出的各种异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)throws InterruptedException </span><br><span class="line">    &#123; </span><br><span class="line">        Thread.sleep(100); </span><br><span class="line">        System.out.println(&quot;Hello Geeks&quot;); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</p><p><strong>final、finally、finalize的区别</strong></p><p>（1）、final用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承</p><p>（2）、finally是异常处理中的一个关键字，表示finally{}里面的代码一定要执行</p><p>（3）、finalize是Object类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</p><p><strong>try()里面有一个return语句，那么后面的finally{}里面的code会不会被执行，什么时候执行，是在return前还是return后？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">int a &#x3D; 1 &#x2F; 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3</p><p><strong>请写出你最常见的5个RuntimeException</strong></p><p>NullPointer;</p><p>ClassNotFound;</p><p>IndexOutOfBounds;</p><p>ClassCast; NoClassDef;</p><p>IllgealArgument;</p><p>NumberFormat;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。&lt;/p&gt;
&lt;p&gt;error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Ja
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Throwable" scheme="https://wuhewuhe.github.io/categories/Java/Throwable/"/>
    
    
      <category term="try catch finally" scheme="https://wuhewuhe.github.io/tags/try-catch-finally/"/>
    
      <category term="Error" scheme="https://wuhewuhe.github.io/tags/Error/"/>
    
      <category term="Exception" scheme="https://wuhewuhe.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>java 浅谈多线程的通讯方式</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/mutlithread/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/mutlithread/</id>
    <published>2020-02-16T15:56:46.000Z</published>
    <updated>2020-02-16T17:01:08.136Z</updated>
    
    <content type="html"><![CDATA[<p>今天在群里面看到一个很有意思的面试题：<br>“编写两个线程，一个线程打印1~25，另一个线程打印字母A~Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”</p><p>这是一道非常好的面试题，非常能彰显被面者关于多线程的功力，一下子就勾起了我的兴趣</p><p>首先我们先有一个helper类：含有两个固定的线程</p><p>此类单例模式生明一个instance</p><p>分别写两个简单的方法，一个生成数字从一到52，另一个生成字母从a到z</p><p>线程提交和终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package MultiThread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class Helper &#123;</span><br><span class="line"></span><br><span class="line">private Helper() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Helper helper &#x3D; new Helper();</span><br><span class="line"></span><br><span class="line">public static Helper getInstance() &#123;</span><br><span class="line">return helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final ExecutorService tPool &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">public static String[] buildNoArr(int max) &#123;</span><br><span class="line">String[] noArr &#x3D; new String[max];</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">noArr[i] &#x3D; Integer.toString(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">return noArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String[] buildCharArr(int max) &#123;</span><br><span class="line">String[] charArr &#x3D; new String[max];</span><br><span class="line">int tmp &#x3D; 65;</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">charArr[i] &#x3D; String.valueOf((char) (tmp + i));</span><br><span class="line">&#125;</span><br><span class="line">return charArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print(String... input) &#123;</span><br><span class="line">if (input &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">for (String each : input) &#123;</span><br><span class="line">System.out.print(each);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(Runnable r) &#123;</span><br><span class="line">tPool.submit(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">tPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法1-一个变量threadToGo-value共享控制">解法1 一个变量threadToGo.value共享控制</h4><p>创建一个final类 , 包含一个变量value，首先启动线程A，给threadgo加上一个同步锁，打印数字，然后发送notice给threadB，此时value值为2，暂停threadA，输出字母，value值恢复为1，周而复始知道达到threadA和B的终止条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class ThreadToGo &#123;</span><br><span class="line">int value &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 2)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">threadToGo.value &#x3D; 2;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 1)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">threadToGo.value &#x3D; 1;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二-利用-Lock-和-Condition-：">解法二 利用 <code>Lock</code> 和 <code>Condition</code> ：</h4><p>整体来讲与解法1相同, 共享一个变量value，新建一个lock和condition，通过try catch finally 给value上锁然后完成线程之间的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line">private Condition condition &#x3D; lock.newCondition();</span><br><span class="line">private static int value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 2)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">value &#x3D; 2;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 1)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">value &#x3D; 1;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法三-volatile">解法三 volatile</h4><p><code>volatile</code> 能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。写法很是巧妙，需要我们理解volatile，是对在内存中的线程排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private volatile ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line">    class ThreadToGo &#123;</span><br><span class="line">        int value &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.value&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.value&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法四-利用-AtomicInteger-：">解法四 利用 <code>AtomicInteger</code> ：</h4><p>和volatile大致相同，利用起本身的同步特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger threadToGo &#x3D; new AtomicInteger(1);</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.set(2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.set(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法五-CyclicBarrier-API">解法五 <code>CyclicBarrier</code> API</h4><p><code>CyclicBarrier</code> 可以实现让一组线程在全部到达 <code>Barrier</code> 时(执行 <code>await()</code> )，再一起同时执行，并且所有线程释放后，还能复用它, 即为Cyclic。<br><code>CyclicBarrier</code> 类提供两个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure><p><strong>这里多说一点，这个API其实还是利用</strong><code>lock</code><strong>和</strong><code>condition</code><strong>，无非是多个线程去争抢</strong><code>CyclicBarrier</code><strong>的instance的lock罢了，最终barrierAction执行时，是在抢到</strong><code>CyclicBarrier</code><strong>instance的那个线程上执行的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private final CyclicBarrier barrier;</span><br><span class="line">private final List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">public MethodSix() &#123;</span><br><span class="line">list &#x3D; Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">barrier &#x3D; new CyclicBarrier(2, newBarrierAction());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">list.add(arr[i + 1]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Runnable newBarrierAction() &#123;</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">Collections.sort(list);</span><br><span class="line">list.forEach(c -&gt; System.out.print(c));</span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conclusion">conclusion</h4><p>多线程高并发是java语言中的一大特性，学生时代的我对其理解的太微不足道，也是通过工作后看到大神写的代码，改bug，还有兴趣的阅读才一点点发现其奥妙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在群里面看到一个很有意思的面试题：&lt;br&gt;
“编写两个线程，一个线程打印1~25，另一个线程打印字母A~Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”&lt;/p&gt;
&lt;p&gt;这是一道非常好的面试题，非常能彰显被面者关于多线程的功力，一下子就勾起了我的兴
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wuhewuhe.github.io/categories/JAVA/"/>
    
      <category term="Multithread" scheme="https://wuhewuhe.github.io/categories/JAVA/Multithread/"/>
    
    
      <category term="lock condition" scheme="https://wuhewuhe.github.io/tags/lock-condition/"/>
    
      <category term="sychronise wait" scheme="https://wuhewuhe.github.io/tags/sychronise-wait/"/>
    
      <category term="atomic" scheme="https://wuhewuhe.github.io/tags/atomic/"/>
    
      <category term="volatile" scheme="https://wuhewuhe.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>design_pattern</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/design-pattern/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/design-pattern/</id>
    <published>2020-02-16T15:43:40.000Z</published>
    <updated>2020-02-16T15:43:40.331Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单例模式 singlenton</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/singleton/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/singleton/</id>
    <published>2020-02-16T15:43:28.000Z</published>
    <updated>2020-02-16T17:36:12.001Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。既然即使是一个初级的程序员，也会使用单例模式了，为什么我们还要在这里特意地讨论它，并且作为第一个模式来分析呢？事实上在我看来，单例模式是很有“深度”的一个模式，要用好、用对它并不是一件简单的事</p><h5 id="定义">定义:</h5><p>确保这个类在内存中只会存在一个对象, 而且自行实例化并向整个系统提供这个实例;</p><h5 id="场景">场景:</h5><p>产生某对象会消耗过多的资源，为避免频繁地创建与销毁对象对资源的浪费</p><blockquote><p>对数据库的操作、访问 IO、线程池（threadpool）、网络请求等。</p></blockquote><p>某种类型的对象应该有且只有一个。如果制造出多个这样的实例，可能导致：程序行为异常、资源使用过量、结果不一致等问题。如果多人能同时操作一个文件，又不进行版本管理，必然会有的修改被覆盖</p><blockquote><p>一个系统只能有：一个窗口管理器或文件系统，计时工具或 ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。</p></blockquote><h5 id="步骤：">步骤：</h5><ul><li>仅自己可以创建，构造函数私有化</li><li>创建一个实例</li><li>getInstance 考虑加锁同步问题</li></ul><h4 id="单列模式的几种基本写法">单列模式的几种基本写法:</h4><h5 id="饿汉式">饿汉式</h5><p>不需要的时候就加载了, 造成资源浪费.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonHungry() &#123;</span><br><span class="line">System.out.println(&quot;hello Singlenton Hungry&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonHungry hungry;</span><br><span class="line"></span><br><span class="line">public static synchronized SinglentonHungry getInstanceHungry() &#123;</span><br><span class="line">if (hungry &#x3D;&#x3D; null) &#123;</span><br><span class="line">hungry &#x3D; new SinglentonHungry();</span><br><span class="line">&#125;</span><br><span class="line">return hungry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonHungry.getInstanceHungry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式">懒汉式</h5><p>懒汉式缺点: 效率低，第一次加载需要实例化，反应稍慢。每次调用getInstance方法都会进行同步，消耗不必要的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonLazy() &#123;</span><br><span class="line">System.out.println(&quot;hello lazy singlenton&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonLazy lazy &#x3D; new SinglentonLazy();</span><br><span class="line"></span><br><span class="line">public static SinglentonLazy getInstanceLazy() &#123;</span><br><span class="line">return lazy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonLazy ss &#x3D; SinglentonLazy.getInstanceLazy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的两种是最常见的, 顾名思义懒汉式和饿汉式, 一个是拿时间换空间, 一个是拿空间换时间, 懒汉式只有我需要他的时候才去加载它, 懒加载机制, 饿汉式不管需不需要我先加载了再说, 先在内存中开辟一块空间, 占用一块地方, 等用到了直接就拿来用. 这两种是最基本的单列模式。</p><h5 id="双重检查单列-double-check-locking">双重检查单列 double check locking</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonDCL &#123;</span><br><span class="line"></span><br><span class="line">private SinglentonDCL() &#123;</span><br><span class="line">System.out.println(&quot;hello singlenton dcl&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile static SinglentonDCL dcl;</span><br><span class="line"></span><br><span class="line">public static SinglentonDCL getInstanceDcl() &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized (SinglentonDCL.class) &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">dcl &#x3D; new SinglentonDCL();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dcl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonDCL.getInstanceDcl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法估计是我们在开发中最常用的, 这次代码的亮点是是在getInstance()方法中进行了双重的判断, 第一层判断的主要避免了不必要的同步, 第二层判断是为了在null的情况下再去创建实例; 举个简单的列子: 假如现在有多个线程同时触发这个方法: 线程A执行到nstance = new Singleton(), 它大致的做了三件事:<br>(1): 给Singleton实例分配内存, 将函数压栈, 并且申明变量类型;<br>(2): 初始化构造函数以及里面的字段, 在堆内存开辟空间;<br>(3): 将instance对象指向分配的内存空间;</p><p><strong>这种写法也并不是保证完全100%的可靠, 由于java编译器允许执行无序</strong></p><h5 id="静态内部内实现单列">静态内部内实现单列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonStaticInner &#123;</span><br><span class="line">private SinglentonStaticInner() &#123;</span><br><span class="line">System.out.println(&quot;hello singleton inner&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final SinglentonStaticInner getInstanceInner() &#123;</span><br><span class="line">return SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonHolder &#123;</span><br><span class="line">private static final SinglentonStaticInner INSTANCE &#x3D; new SinglentonStaticInner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonStaticInner.getInstanceInner();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举实现单列">枚举实现单列</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点: 相对于其他单列来说枚举写法最简单, 并且任何情况下都是单列的</p><h5 id="使用容器单">使用容器单</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; objMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private SingletonManager() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void putObject(String key, Object instance)&#123;</span><br><span class="line">        if(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getObject(String key)&#123;</span><br><span class="line">        return objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序开始的时候将单列类型注入到一个容器之中, 也就是单列ManagerClass, 在使用的时候再根据key值获取对应的实例, 这种方式可以使我们很方便的管理很多单列对象, 也对用户隐藏了具体实现类, 降低了耦合度; 但是为了避免造成内存泄漏, 所以我们一般在生命周期销毁的时候也要去销毁它</p><h4 id="总结">总结</h4><p>单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式都不会有太大的影响。即使如此，出于效率考虑，推荐使用DCL单例（双重检查锁定）和静态内部类单例模式。</p><p>优点：</p><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>单例模式可以避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。</li><li>单例对象如果持有Context，那么很容易引发内存泄露。此时需要注意传递给单例对象的Context最好是Application Context。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式（Singleton Pattern）一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。既然即使是一个初级的程序员，也会使用单例模式了，为什么我们还要在这里特意地讨论它，并且作为第一个模式来分析呢？事实上在我看来，单例
      
    
    </summary>
    
    
      <category term="Design pattern" scheme="https://wuhewuhe.github.io/categories/Design-pattern/"/>
    
    
      <category term="singlenton" scheme="https://wuhewuhe.github.io/tags/singlenton/"/>
    
      <category term="lazy" scheme="https://wuhewuhe.github.io/tags/lazy/"/>
    
      <category term="hungry" scheme="https://wuhewuhe.github.io/tags/hungry/"/>
    
      <category term="double check locking" scheme="https://wuhewuhe.github.io/tags/double-check-locking/"/>
    
      <category term="static inner class" scheme="https://wuhewuhe.github.io/tags/static-inner-class/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/volatile/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/volatile/</id>
    <published>2020-02-16T15:43:16.000Z</published>
    <updated>2020-02-16T15:56:38.224Z</updated>
    
    <content type="html"><![CDATA[<h1>深入浅出java中volatile</h1><p>这周处理ticket的时候发现，我们经常会把数据加载到cache，然后去生明voltile，于是我就梳理了一下知识点，可能有点冷门，但是还是有其用到的地方</p><h3 id="volatile定义">volatile定义</h3><p>如果一个字段被声明为volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><h3 id="volatile的特性">volatile的特性</h3><p>从上面的官方定义我们可以看出 volatile实现了内存可见性<br>内存可见性：简单的讲也就是说一个线程对 声明了volatile的变量进行修改，java会保证其他线程也能看见修改，保证内存中的变量是最新的</p><p>原子性： volatile 能保证单个volatile的操作是原子性的 但不能保证 形如 i++这样的操作是原子性的 （下面会给出代码）</p><h3 id="volatile的使用">volatile的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>只要在变量前声明即可</p><p>volatile 无法保证复合性操作的原子性<br>我们可以通过代码实验来证明这一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title">AtomicTest</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span>    <span class="keyword">static</span>   <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ;k&lt;<span class="number">1000</span>;k++)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws InterruptedException</span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AtomicTest());</span><br><span class="line">            threads[c].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c =<span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c].<span class="keyword">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上， 执行上述代码你会发现每次输出的值都会小于我们所期待的最终值 10000 ，  也就 i++并不是原子性的。<br>所以我们并不建议 volatile使用在这种场景下，我们可以用volatile ：检查某个标记以来判断是否进行下一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(flag)&#123; </span><br><span class="line">      ........</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile的内存可见性">volatile的内存可见性</h3><p>volatile的内存可见性是通过java内存模型对volatile定义的特殊规则定义的。在jvm虚拟机的内存模型中 分为本地内存和主内存，每一个线程都有自己的本地内存，并且共享同一个主内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当写一个<span class="keyword">volatile</span>变量时， java内存模型会把该变量从线程的本地变量刷新到主内存</span><br><span class="line">当读一个<span class="keyword">volatile</span>变量时，java内存模型会去主内存取该变量，然后将本地内存中的值改变</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-2c36332ffe88609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/424/format/webp" alt="img"></p><p>2.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-bc40b98181cd7b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="img"></p><p>3.png</p><h3 id="java内存模型中的volatile-、">java内存模型中的volatile 、</h3><p>java内存模型为了保证volatile 的内存可见性 对volatile还有第二条语义：禁止指令重排序优化（关于重排序后面我也会整理我的心得分享给大家，简单的讲就是java会对没有数据依赖的操作进行指令重排 已达到提升性能的目的）。<br>那么为什么要禁止指令重排序呢？下面我们通过一个简单的代码来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map mapTest;</span><br><span class="line"><span class="keyword">char</span>[] configuration;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> init =<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//假设a线程执行writer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">mapTest =<span class="keyword">new</span> HashMap;</span><br><span class="line">configuration = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];<span class="comment">//读之前的准工作</span></span><br><span class="line">init =<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设b线程执行该代码</span></span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(init )&#123;</span><br><span class="line">  .......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的代码，如果init变量没有被定义为volatile的，那么 init=true 这段代码可能由于指令重排序的优化，导致其被提前执行，这样会导致配置b中使用a线程中的配置信息是出错，<br>volatile变量的赋值的汇编代码是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java代码 ： instance =new singleton（）</span><br><span class="line">汇编代码：  0x01a3de1d: movb <span class="variable">$0x0</span>,0x1104800(%esi);</span><br><span class="line">                     0x01a3de24: lock addl <span class="variable">$0x0</span>,(%esp);</span><br></pre></td></tr></table></figure><p>其中 lock addl $0x0, (%esp) 就相当于一个内存屏障  对于volatile变量来说 读写会具有不同的内存屏障.<br>具体会根据以下规则使用不同的内存屏障</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不&gt;&gt;能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><h3 id="结语">结语</h3><p>引用java并发编程实战中的一段话结束这篇文章<br>仅当volatile 变量能简化代码的实习以及对同步策略的验证时，才应该使用它们，如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期时间的发生（例如，初始化和关闭）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;深入浅出java中volatile&lt;/h1&gt;
&lt;p&gt;这周处理ticket的时候发现，我们经常会把数据加载到cache，然后去生明voltile，于是我就梳理了一下知识点，可能有点冷门，但是还是有其用到的地方&lt;/p&gt;
&lt;h3 id=&quot;volatile定义&quot;&gt;volatile
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Cache" scheme="https://wuhewuhe.github.io/categories/Java/Cache/"/>
    
    
      <category term="volatile" scheme="https://wuhewuhe.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>entry reflect</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/entry-reflect/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/entry-reflect/</id>
    <published>2020-02-16T09:53:19.000Z</published>
    <updated>2020-02-16T09:53:43.093Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分为堆和栈，易懂点吧！</p><p>假如你写了一段代码：Object o=new Object();</p><p>运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p><p>题主想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求哦要用到某个类，哎呀但没加载进jvm，是不是要停下来自己写段代码，new一下，哦启动一下服务器，（脑残）！</p><p>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="reflect" scheme="https://wuhewuhe.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>JVM Method area</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/mthod-area/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/mthod-area/</id>
    <published>2020-02-16T09:47:10.000Z</published>
    <updated>2020-02-16T09:47:51.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。</p></blockquote><h2 id="方法区">方法区</h2><p>方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><blockquote><p>注意：JDK 6 时，String等字符串常量的信息是置于方法区中的，但是到了JDK 7 时，已经移动到了Java堆。所以，方法区也好，Java堆也罢，到底详细的保存了什么，其实没有具体定论，要结合不同的JVM版本来分析。</p></blockquote><blockquote><h3 id="异常">异常</h3><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。<br>运行时常量池溢出：比如一直往常量池加入数据，就会引起OutOfMemoryError异常。</p></blockquote><h3 id="类信息">类信息</h3><blockquote><ol><li>类型全限定名。</li><li>类型的直接超类的全限定名（除非这个类型是java.lang. Object，它没有超类）。</li><li>类型是类类型还是接口类型。</li><li>类型的访问修饰符（public、abstract或final的某个子集）。</li><li>任何直接超接口的全限定名的有序列表。</li><li>类型的常量池。</li><li>字段信息。</li><li>方法信息。</li><li>除了常量意外的所有类（静态）变量。</li><li>一个到类ClassLoader的引用。</li><li>一个到Class类的引用。</li></ol></blockquote><h2 id="1-常量池">1 常量池</h2><h3 id="1-1-Class文件中的常量池">1.1 Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h3 id="1-2-运行时常量池">1.2 运行时常量池</h3><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="1-3-常量池的好处">1.3 常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><blockquote><p>双等号==的含义</p><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul></blockquote><h3 id="1-4-基本类型的包装类和常量池">1.4 基本类型的包装类和常量池</h3><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean。</p><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float, Double并没有实现常量池技术。</p><h4 id="Integer与常量池">Integer与常量池</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));  </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="解释：">解释：</h4><ul><li>(1)Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40); ，从而使用常量池中的对象。</li><li>(2)Integer i1 = new Integer(40); 这种情况下会创建新的对象。</li><li>(3)语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</li></ul><h4 id="String与常量池">String与常量池</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str1 = <span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="解释：-2">解释：</h4><ul><li><p>(1)new String(“abcd”)是在常量池中拿对象，&quot;abcd&quot;是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。</p></li><li><p>(2)连接表达式 +</p><p>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final String A; &#x2F;&#x2F; 常量A</span><br><span class="line">public static final String B;    &#x2F;&#x2F; 常量B</span><br><span class="line">static &#123;  </span><br><span class="line">   A &#x3D; &quot;ab&quot;;  </span><br><span class="line">   B &#x3D; &quot;cd&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">&#x2F;&#x2F; 将两个常量用+连接对s进行初始化  </span><br><span class="line">String s &#x3D; A + B;  </span><br><span class="line">String t &#x3D; &quot;abcd&quot;;  </span><br><span class="line">if (s &#x3D;&#x3D; t) &#123;  </span><br><span class="line">    System.out.println(&quot;s等于t，它们是同一个对象&quot;);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-3">解释：</h4><p>s不等于t，它们不是同一个对象。</p><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xyz"</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure><h4 id="解释：-4">解释：</h4><p>考虑类加载阶段和实际执行时。</p><ul><li>（1）类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li><li>（2）在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s1 持有。</li></ul><p>这条语句创建了2个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String s1 &#x3D; new String(&quot;计算机&quot;);</span><br><span class="line">String s2 &#x3D; s1.intern();</span><br><span class="line">String s3 &#x3D; &quot;计算机&quot;;</span><br><span class="line">System.out.println(&quot;s1 &#x3D;&#x3D; s2? &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">System.out.println(&quot;s3 &#x3D;&#x3D; s2? &quot; + (s3 &#x3D;&#x3D; s2));</span><br><span class="line">&#125;</span><br><span class="line">s1 &#x3D;&#x3D; s2? false</span><br><span class="line">s3 &#x3D;&#x3D; s2? true</span><br></pre></td></tr></table></figure><h4 id="解释：-5">解释：</h4><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串, 如果有则返回该字符串的引用, 如果没有则添加自己的字符串进入常量池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"> String hello = <span class="string">"Hello"</span>, lo = <span class="string">"lo"</span>;</span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == <span class="string">"Hello"</span>) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((other.Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+<span class="string">"lo"</span>)) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+lo)) + <span class="string">" "</span>); <span class="comment">//false</span></span><br><span class="line"> System.<span class="keyword">out</span>.println(hello == (<span class="string">"Hel"</span>+lo).intern()); <span class="comment">//true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">package other;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-6">解释：</h4><p>在同包同类下, 引用自同一String对象.</p><p>在同包不同类下, 引用自同一String对象.</p><p>在不同包不同类下, 依然引用自同一String对象.</p><p>在编译成.class时能够识别为同一字符串的, 自动优化成常量, 引用自同一String对象.</p><p>在运行时创建的字符串具有独立的内存地址, 所以不引用自同一String对象.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方法区&quot;&gt;方法区&lt;/h2&gt;
&lt;p&gt;方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://wuhewuhe.github.io/categories/Java/JVM/"/>
    
    
      <category term="method area" scheme="https://wuhewuhe.github.io/tags/method-area/"/>
    
  </entry>
  
  <entry>
    <title>reflect</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/reflect/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/reflect/</id>
    <published>2020-02-16T09:17:09.000Z</published>
    <updated>2020-02-16T09:39:08.251Z</updated>
    
    <content type="html"><![CDATA[<p>反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。</p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple &#x3D; new Apple(); &#x2F;&#x2F;直接初始化，「正射」</span><br><span class="line">apple.setPrice(4);</span><br></pre></td></tr></table></figure><p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p><p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p><p>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);</span><br><span class="line">Method method &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Object object &#x3D; constructor.newInstance();</span><br><span class="line">method.invoke(object, 4);</span><br></pre></td></tr></table></figure><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect. Apple）。</p><p>所以说什么是反射？</p><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p><h2 id="一个简单的例子">一个简单的例子</h2><p>上面提到的示例程序，其完整的程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Apple &#123;</span><br><span class="line"></span><br><span class="line">    private int price;</span><br><span class="line"></span><br><span class="line">    public int getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(int price) &#123;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;正常的调用</span><br><span class="line">        Apple apple &#x3D; new Apple();</span><br><span class="line">        apple.setPrice(5);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + apple.getPrice());</span><br><span class="line">        &#x2F;&#x2F;使用反射调用</span><br><span class="line">        Class clz &#x3D; Class.forName(&quot;com.chenshuyi.api.Apple&quot;);</span><br><span class="line">        Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">        Constructor appleConstructor &#x3D; clz.getConstructor();</span><br><span class="line">        Object appleObj &#x3D; appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, 14);</span><br><span class="line">        Method getPriceMethod &#x3D; clz.getMethod(&quot;getPrice&quot;);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple Price:5</span><br><span class="line">Apple Price:14</span><br></pre></td></tr></table></figure><p>从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</p><ul><li>获取类的 Class 对象实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.zhenai.api.Apple&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据 Class 对象实例获取 Constructor 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor &#x3D; clz.getConstructor();</span><br></pre></td></tr></table></figure><ul><li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj &#x3D; appleConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>而如果要调用某一个方法，则需要经过下面的步骤：</p><ul><li>获取方法的 Method 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br></pre></td></tr></table></figure><ul><li>利用 invoke 方法调用方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, 14);</span><br></pre></td></tr></table></figure><p>到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。</p><p>在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p><h2 id="反射常用API">反射常用API</h2><h3 id="获取反射中的Class对象">获取反射中的Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><p>**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p><strong>第二种，使用 .class 方法。</strong></p><p>这种方法只适合在编译前就知道操作的 Class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; String.class;</span><br></pre></td></tr></table></figure><p><strong>第三种，使用类对象的 getClass() 方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">Class clz &#x3D; str.getClass();</span><br></pre></td></tr></table></figure><h3 id="通过反射创建类对象">通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p>第一种：通过 Class 对象的 newInstance() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Apple apple &#x3D; (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure><p>第二种：通过 Constructor 对象的 newInstance() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure><h3 id="通过反射获取类属性、方法、构造器">通过反射获取类属性、方法、构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="img"></p><p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Delegate" scheme="https://wuhewuhe.github.io/categories/Java/Delegate/"/>
    
    
      <category term="reflect" scheme="https://wuhewuhe.github.io/tags/reflect/"/>
    
      <category term="invoke" scheme="https://wuhewuhe.github.io/tags/invoke/"/>
    
  </entry>
  
  <entry>
    <title>composite and aggrevgation</title>
    <link href="https://wuhewuhe.github.io/2020/02/16/composite-and-aggrevgation/"/>
    <id>https://wuhewuhe.github.io/2020/02/16/composite-and-aggrevgation/</id>
    <published>2020-02-16T09:05:49.000Z</published>
    <updated>2020-02-16T09:06:57.165Z</updated>
    
    <content type="html"><![CDATA[<ul><li>inheritance and delegate</li></ul><p>both of them are the reuse technique in java, and they are importance design in our daily coding, inheritance is represented by Lioskv, his operations and attributes are inherite by subclass from parent class in the context, which is called super class.</p><p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p><p>Delegation can be an alternative to inheritance.<br>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.<br>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.<br>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</p><ul><li>difference between delegate and inheritance?</li></ul><p>inheitance vise to class, bur delegate vise to object</p><ul><li>Why use delegate?</li></ul><p>it can be an alternative way of inheritance, but the primary advantage of delegate is that it’s flexible and change in run time, it doesn’t force you to accept all method of a super class, you just provide some mthod make you sense</p><ul><li>When to use inheritance?</li></ul><p>You want to express relationship (is-a) then you want to use Inheritance.</p><p>You want to be able to pass your class to an existing API expecting A’s then you need to use inheritance.</p><ul><li>when to use delegate?</li></ul><p>You want to enhance A, but A is final and can no further be sub-classed then you need to use <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/" target="_blank" rel="noopener">composition</a> and delegation.</p><p>In this example, there is an Institute which has no. of departments like CSE, EE. Every department has no. of students. So, we make a Institute class which has a reference to Object or no. of Objects (i.e. List of Objects) of the Department class. That means Institute class is associated with Department class through its Object(s). And Department class has also a reference to Object or Objects (i.e. List of Objects) of Student class means it is associated with Student class through its Object(s).<br>It represents a <strong>Has-A</strong> relationship.<br><a href="https://www.geeksforgeeks.org/media.geeksforgeeks.org/wp-content/uploads/Reference.png" target="_blank" rel="noopener"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Reference.png" alt="Aggregation_1"></a></p><p>Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.</p><ul><li>It represents <strong>part-of</strong> relationship.</li><li>In composition, both the entities are dependent on each other.</li><li>When there is a composition between two entities, the composed object <strong>cannot exist</strong> without the other entity.</li></ul><p>In above example a library can have no. of <strong>books</strong> on same or different subjects. So, If Library gets destroyed then All books within that particular library will be destroyed. i.e. book can not exist without library. That’s why it is composition.</p><p><strong>Aggregation vs Composition</strong></p><ol><li><strong>Dependency:</strong> Aggregation implies a relationship where the child <strong>can exist independently</strong> of the parent. For example, Bank and Employee, delete the Bank and the Employee still exist. whereas Composition implies a relationship where the child <strong>cannot exist independent</strong> of the parent. Example: Human and heart, heart don’t exist separate to a Human</li><li><strong>Type of Relationship:</strong> Aggregation relation is <strong>“has-a”</strong> and composition is <strong>“part-of”</strong> relation.</li><li><strong>Type of association:</strong> Composition is a <strong>strong</strong> Association whereas Aggregation is a <strong>weak</strong> Association.</li></ol><p>In case of aggregation, the Car also performs its functions through an Engine. but the Engine is not always an internal part of the Car. An engine can be swapped out or even can be removed from the car. That’ why we make The Engine type field non-final.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;inheritance and delegate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;both of them are the reuse technique in java, and they are importance design in our daily co
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Design pattern" scheme="https://wuhewuhe.github.io/categories/Java/Design-pattern/"/>
    
    
      <category term="deglate" scheme="https://wuhewuhe.github.io/tags/deglate/"/>
    
      <category term="inheritance" scheme="https://wuhewuhe.github.io/tags/inheritance/"/>
    
      <category term="comoposite" scheme="https://wuhewuhe.github.io/tags/comoposite/"/>
    
      <category term="aggrevgation" scheme="https://wuhewuhe.github.io/tags/aggrevgation/"/>
    
  </entry>
  
  <entry>
    <title>SOLID Object Orient Programming pinciples</title>
    <link href="https://wuhewuhe.github.io/2020/02/15/solid/"/>
    <id>https://wuhewuhe.github.io/2020/02/15/solid/</id>
    <published>2020-02-15T17:41:04.000Z</published>
    <updated>2020-02-15T17:45:22.884Z</updated>
    
    <content type="html"><![CDATA[<p>this is 5 pinciple of object-oriented programming</p><p>In object-oriented computer programming, <strong>SOLID</strong> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.</p><ul><li>s = single respoonsibilty principle</li></ul><p>a class should have a single responsibility, one part of software’s specification should be able to affect the specification of class</p><ul><li>open close principle</li></ul><p>Software class should be opened for extension but closed for modifications</p><ul><li>Liskov</li></ul><p>Object in a program should be replaced with instance of their subtype without correctness of that program</p><ul><li>interface segergation</li></ul><p>many client specific interface are better than one general purpose interface</p><ul><li>dependency inversion</li></ul><p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p><h4 id="single-responsibility">single responsibility</h4><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p><p><strong>example</strong></p><p>First, we create our shapes classes and have the constructors setup the required parameters. Next, we move on by creating the <strong>AreaCalculator</strong> class and then write up our logic to sum up the areas of all provided shapes.</p><p>To use the <strong>AreaCalculator</strong> class, we simply instantiate the class and pass in an array of shapes, and display the output at the bottom of the page.</p><p>All of that logic would be handled by the <strong>AreaCalculator</strong> class, this is what SRP frowns against; the <strong>AreaCalculator</strong> class should only sum the areas of provided shapes, it should not care whether the user wants json or HTML.</p><p>Now, whatever logic you need to output the data to the user is now handled by the <strong>SumCalculatorOutputter</strong> class.</p><h4 id="open-closed-principle">open-closed principle</h4><p>This simply means that a class should be easily extendable without modifying the class itself. Let’s take a look at the <strong>AreaCalculator</strong> class, especially it’s <strong>sum</strong> method.</p><p>If we wanted the <strong>sum</strong> method to be able to sum the areas of more shapes, we would have to add more <strong>if/else blocks</strong> and that goes against the Open-closed principle.</p><p>A way we can make this <strong>sum</strong> method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape’s class.</p><p>The same thing should be done for the <strong>Circle</strong> class, an <strong>area</strong> method should be added. Now, to calculate the sum of any shape provided should be as simple as:</p><p>Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the <strong>AreaCalculator</strong> is actually a shape or if the shape has a method named <strong>area</strong>?</p><p>Coding to an interface is an integral part of <strong>S. O. L. I. D</strong>, a quick example is we create an interface, that every shape implements:</p><p>In our <strong>AreaCalculator</strong> sum method we can check if the shapes provided are actually instances of the <strong>ShapeInterface</strong>, otherwise we throw an exception:</p><h4 id="Liskoc-substitution-principle">Liskoc substitution principle</h4><p>Next up on our list is Liskov substitution, which is arguably the most complex of the 5 principles. Simply put, <strong>if class *A* is a subtype of class *B*, then we should be able to replace *B* with *A* without disrupting the behavior of our program.</strong></p><h4 id="interface-segregation">interface segregation</h4><p><strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we can add another contract to the <strong>ShapeInterface</strong>:</p><p>Any shape we create must implement the <strong>volume</strong> method, but we know that squares are flat shapes and that they do not have volumes, so this interface would force the <strong>Square</strong> class to implement a method that it has no use of.</p><p><strong>ISP</strong> says no to this, instead you could create another interface called <strong>SolidShapeInterface</strong> that has the <strong>volume</strong> contract and solid shapes like cubes e.t.c can implement this interface:</p><p>This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead of using a <strong>ShapeInterface</strong> or a <strong>SolidShapeInterface</strong>.</p><p>You can create another interface, maybe <strong>ManageShapeInterface</strong>, and implement it on both the flat and solid shapes, this way you can easily see that it has a single API for managing the shapes. For example:</p><p>Now in <strong>AreaCalculator</strong> class, we can easily replace the call to the <strong>area</strong> method with <strong>calculate</strong> and also check if the object is an instance of the <strong>ManageShapeInterface</strong> and not the <strong>ShapeInterface</strong>.</p><h4 id="dependecy-inversion">dependecy inversion</h4><p><strong>The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.</strong></p><p>this principle realise the open-close displicine, which means that we don’t need to concentrate which is the shape type exactly, because each shape has his own area and we can call it by the abstraction class.</p><p><strong>in the last, you can find my code in attchement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square s &#x3D; new Square(&quot;square&quot;, 1);</span><br><span class="line">Circle c &#x3D; new Circle(&quot;circle&quot;, 1);</span><br><span class="line">Shapes[] ss &#x3D; &#123; s, c &#125;;</span><br><span class="line">CalculatorArea ca &#x3D; new CalculatorArea(ss);</span><br><span class="line">System.out.println(ca.sumShapes());</span><br><span class="line">FormatOutputter fo &#x3D; new FormatOutputter(formatter.HTML, ca);</span><br><span class="line">fo.transfer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class CalculatorArea &#123;</span><br><span class="line">private Shapes[] shapes;</span><br><span class="line"></span><br><span class="line">public CalculatorArea(Shapes[] shapes) &#123;</span><br><span class="line">this.shapes &#x3D; shapes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.area();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int volumeShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.volume();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shapes &#123;</span><br><span class="line">private int radius;</span><br><span class="line"></span><br><span class="line">public Circle(String name, int radius) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getRadius() &#123;</span><br><span class="line">return radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return (int) (Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) (Math.PI * radius * 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class FormatOutputter &#123;</span><br><span class="line">private CalculatorArea ca;</span><br><span class="line">private formatter format;</span><br><span class="line"></span><br><span class="line">public FormatOutputter(formatter format, CalculatorArea ca) &#123;</span><br><span class="line">this.format &#x3D; format;</span><br><span class="line">this.ca &#x3D; ca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer() &#123;</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case JSON:</span><br><span class="line">System.out.println(&quot;json transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case HTML:</span><br><span class="line">System.out.println(&quot;html transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case TXT:</span><br><span class="line">System.out.println(&quot;txt transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case XML:</span><br><span class="line">System.out.println(&quot;xml transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public enum formatter &#123;</span><br><span class="line">XML, JSON, TXT, HTML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeInterface &#123;</span><br><span class="line">int area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public abstract class Shapes implements ShapeInterface, ShapeVolumInterface &#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Shapes(String name) &#123;</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeVolumInterface &#123;</span><br><span class="line">int volume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Square extends Shapes &#123;</span><br><span class="line">private int length;</span><br><span class="line"></span><br><span class="line">public Square(String name, int length) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return length * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) Math.pow(length, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this is 5 pinciple of object-oriented programming&lt;/p&gt;
&lt;p&gt;In object-oriented computer programming, &lt;strong&gt;SOLID&lt;/strong&gt; is a mnemonic ac
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="solid" scheme="https://wuhewuhe.github.io/tags/solid/"/>
    
      <category term="oop" scheme="https://wuhewuhe.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>装*必备的linux命令</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/linux-command/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/linux-command/</id>
    <published>2020-02-12T18:56:25.000Z</published>
    <updated>2020-02-15T17:47:02.956Z</updated>
    
    <content type="html"><![CDATA[<p>当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演</p><h4 id="常规操作-小试牛刀">常规操作 小试牛刀</h4><p><strong>ls: 类似于dos下的dir命令</strong></p><p>ls最常用的参数有三个： -a -l -F。</p><p>ls –a</p><p>Linux上的文件以. 开头的文件被系统视为隐藏文件，仅用ls命令是看不到他们的，而用ls -a除了显示一般文件名外，连隐藏文件也会显示出来。</p><p>ls –l</p><p>该参数显示更详细的文件信息。</p><p>ls –F</p><p>使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。但是现在基本上所有的Linux发行版本的ls都已经内建了-F参数，也就是说，不用输入这个参数，我们也能看到各种分辨符号。</p><p><strong>cd: 用于切换用户当前工作目录</strong></p><p>cd aaa 进入aaa目录</p><p>cd 命令后不指定目录，会切换到当前用户的home 目录</p><p>cd ~ 作用同cd后不指定目录，切换到当前用户的home 目录</p><p>cd - 命令后跟一个减号，则会退回到切换前的目录</p><p>cd … 返回到当前目录下的上一级目录</p><p><strong>pwd：用于显示用户当前工作目录</strong></p><p><strong>mkdir 和 rmdir</strong></p><p>midir: 创建目录 rmdir: 删除目录</p><p>两个命令都支持-p参数，对于mkdir命令若指定路径的父目录不存在则一并创建，对于rmdir命令则删除指定路径的所有层次目录，如果文件夹里有内容，则不能用rmdir命令</p><p>如下：</p><p>mkdir -p 1/2/3</p><p>rmdir -p 1/2/3</p><p><strong>tar 打包压缩与解压缩</strong></p><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2</a>命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file&#x3D;&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br></pre></td></tr></table></figure><p><strong>将文件全部打包成tar包</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！ </span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure><p>在选项 <code>f</code> 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 <code>z</code> 选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加 <code>j</code> 选项，则以.tar.bz2来作为tar包名。</p><p><strong>查阅上述tar包内有哪些文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 <code>z</code> 这个选项了。</p><p><strong>将tar包解压缩</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;opt&#x2F;soft&#x2F;test&#x2F;log.tar.gz</span><br></pre></td></tr></table></figure><h4 id="文件操作-装-的核心操作">文件操作 装*的核心操作</h4><p><strong>touch</strong></p><p>inux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令&quot;touch&quot;修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure><p><strong>cp：复制命令</strong></p><p>复制一个文件到另一目录：cp 1.txt …/test2</p><p>复制一个文件到本目录并改名：cp 1.txt 2.txt</p><p>复制一个文件夹a并改名为b：cp -r a b</p><p><strong>mv：移动命令</strong></p><p>将一个文件移动到另一个目录：mv 1.txt …/test1</p><p>将一个文件在本目录改名：mv 1.txt 2.txt</p><p>将一个文件一定到另一个目录并改名：mv 1.txt …/test1/2.txt</p><p><strong>rm命令</strong></p><p>rm命令用于删除文件，与dos下的del/erase命令相似，rm命令常用的参数有三个：-i，-r，-f。</p><p>–i ：系统在删除文件之前会先询问确认，用户回车之后，文件才会真的被删除。需要注意，linux下删除的文件是不能恢复的，删除之前一定要谨慎确认。</p><p>–r：该参数支持目录删除，功能和rmdir命令相似。</p><p>–f：和-i参数相反，-f表示强制删除</p><p><strong>cat命令</strong></p><p>cat命令的功能是显示或连结一般的ascii文本文件。cat是concatenate的简写，类似于dos下面的type命令。用法如下：</p><p>cat file1 显示file1文件内容</p><p>cat file1 file2 依次显示file1, file2的内容</p><p>cat file1 file2 &gt; file3 把file1, file2的内容结合起来，再“重定向（&gt;）”到file3文件中。</p><p>&quot;&gt;“是右重定向符，表示将左边命令结果当成右边命令的输入，注意：如果右侧文件是一个已存在文件，其原有内容将会被清空，而变成左侧命令输出内容。如果希望以追加方式写入，请改用”&gt;&gt;&quot;重定向符。</p><p>如果&quot;&gt;&quot;左边没有指定文件，如： cat &gt;file1，将会等用户输入，输入完毕后再按[Ctrl]+[c]或[Ctrl]+[d]，就会将用户的输入内容写入file1。</p><p><strong>echo命令</strong></p><p>echo命令的使用频率不少于ls和cat，尤其是在shell脚本编写中。</p><p>语法：echo [-ne][字符串]</p><p>功能：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开， 并在最后加上换行符。</p><p>参数：</p><p>-n 显示字串时在最后自动换行</p><p>-e 支持以下格式的转义字符， -E 不支持以下格式的转义字符</p><p>/a 发出警告声；</p><p>/b 删除前一个字符；</p><p>/c 最后不加上换行符号；</p><p>/f 换行但光标仍旧停留在原来的位置；</p><p>/n 换行且光标移至行首；</p><p>/r 光标移至行首，但不换行；</p><p>/t 插入tab；</p><p>/v 与/f相同；</p><p>// 插入/字符；</p><p><strong>more，less，clear</strong></p><p>n more，less命令</p><p>这两个命令用于查看文件，如果一个文件太长，显示内容超出一个屏幕，用cat命令只能看到最后的内容，用more和less两个命令可以分页查看。more指令可以使超过一页的文件内容分页暂停显示，用户按键后才继续显示下一页。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，更方便浏览阅读。</p><p>less的常用动作命令：</p><p>回车键 向下移动一行；</p><p>y 向上移动一行；</p><p>空格键 向下滚动一屏；</p><p>b 向上滚动一屏；</p><p>d 向下滚动半屏；</p><p>h less的帮助；</p><p>u 向上洋动半屏；</p><p>w 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示；</p><p>g 跳到第一行；</p><p>G 跳到最后一行；</p><p>p n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示；</p><p>/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词；</p><p>v 调用vi编辑器；</p><p>q 退出less</p><p>!command 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</p><p>n clear命令</p><p>clear命令是用来清除当前屏幕显示的，不需任何参数，和dos下的cls命令功能相同。</p><h4 id="读写操作-装-境界更上一层楼">读写操作 装*境界更上一层楼</h4><p><strong>vim 高级文本编辑器</strong></p><p>Vim 经常被认为是 “程序员的编辑器”, 它在程序编写时非常有用，很多人认为它是一个完整的集成开发环境(IDE)。仅管如此，Vim并不只是程序员使用的。Vim可以用于多种文档编辑，从email排版到配置文件编写。</p><p><strong>编辑模式</strong>（Normal）：执行命令，也称为正常模式<br>**插入模式 **（Insert）：输入文本<br><strong>命令模式</strong>：执行 <strong>冒号</strong> 命令</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>按下键 i ，进入 <em>Insert</em> 模式（ 这时候，你可以输入文本）</li><li>按 ESC键，就可退回到<em>Normal</em> 模式下</li></ul><p>在Normal下基本命令操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">Insert</span> 模式，按 <span class="selector-tag">ESC</span>回到 <span class="selector-tag">Normal</span>模式。 <span class="selector-tag">x</span> 删当前光标所在的一个字符。<span class="selector-pseudo">:wq</span> 存盘+退出 (<span class="selector-pseudo">:w</span>存盘, <span class="selector-pseudo">:q</span>退出) （注<span class="selector-pseudo">:w</span> 后可以跟文件名）<span class="selector-pseudo">:q</span> ! 不保存退出 <span class="selector-tag">Shift</span>+<span class="selector-tag">ZZ</span> 退出本文档 <span class="selector-tag">dd</span> 删除当前行，并把删除的行存到剪贴板里 <span class="selector-tag">p</span> 粘贴剪贴板<span class="selector-pseudo">:help</span> 显示相关命令的帮助（<span class="selector-pseudo">:q</span> 退出帮助） 移动光标 <span class="selector-tag">hjkl</span> (←↓↑→)</span><br></pre></td></tr></table></figure><p>简单的光标移动命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       当前行第一列</span><br><span class="line">w       移到下一个单词</span><br><span class="line">^       移动到第一个非空白字符</span><br><span class="line">$       移动到最后一列</span><br><span class="line">g       移动到最后一个非空白字符</span><br><span class="line">%       匹配括号移动，包括 (, &#123;, [。 （把光标先移到括号上）</span><br><span class="line"></span><br><span class="line">*       移动光标到上一个匹配的单词</span><br><span class="line"></span><br><span class="line"><span class="comment">#       移动光标到下一个匹配的单词</span></span><br><span class="line">/pattern搜索   pattern的字符串（如果搜索出多个匹配，可按n键到下一个）</span><br></pre></td></tr></table></figure><p><strong>wc命令</strong></p><p>该命令用于统计指定文件中的字节数、字数、行数。该命令各选项含义如下：</p><p>-l 统计行数</p><p>-w 统计字数</p><p>-c 统计字节数</p><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。</p><p>行数、字数、字节数、文件名</p><p>如果命令行中没有文件名，则输出中不出现文件名。</p><p><strong>grep 命令</strong></p><p>grep是（global search regular expression(RE) and print out the line的缩写，用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被””引用，模板后的所有字符串被看作文件名。搜索结果送到屏幕，不影响原文件内容。</p><p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>示例：</p><p>$ ls -l | grep ‘^a’</p><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><p>$ grep ‘test’ d*</p><p>显示所有以d开头的文件中包含test的行。</p><p>$ grep ‘test’ aa bb cc</p><p>显示在aa，bb，cc文件中匹配test的行。</p><p>$ grep ‘[a-z]/{5/}’ aa</p><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><p>$ grep ‘w/(es/)t.*/1’ aa</p><p>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.<em>），这些字符后面紧跟着另外一个es（/1），找到就显示该行。如果用egrep或grep -E，就不用&quot;/&quot;号进行转义，直接写成’w(es)t.</em>/1’就可以了。</p><h4 id="进程操作-比肩程序员">进程操作 比肩程序员</h4><p><strong>nohup 挂起操作</strong></p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。</p><p>nohup command 或者 nohup command &amp;</p><p>这之间的差别是带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上）；</p><p><strong>tip: crl + z 可以切换当前进程到后台运行</strong></p><p><strong>ps 进程</strong></p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><ul><li>ps工具标识进程的5种状态码:</li></ul><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><ul><li>命令参数</li></ul><p>a 显示所有进程</p><p>-a 显示同一终端下的所有程序</p><p>-A 显示所有进程</p><p>c 显示进程的真实名称</p><p>-au 显示较详细的资讯</p><p>-aux 显示所有包含其他使用者的行程</p><ul><li>各相关信息的意义：</li></ul><p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p><p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p><p>UID 程序被该 UID 所拥有</p><p>PID 就是这个程序的 ID ！</p><p>PPID 则是其上级父程序的ID</p><p>C CPU 使用的资源百分比</p><p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p><p>SZ 使用掉的内存大小</p><p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p><p>TTY 登入者的终端机位置</p><p>TIME 使用掉的 CPU 时间。</p><p>CMD 所下达的指令为何</p><p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID</p><p><strong>kill</strong></p><p>Linux kill命令用于删除执行中的程序或工作。</p><p>彻底杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456(pid)</span><br></pre></td></tr></table></figure><p><strong>head，tail</strong></p><p>n head和tail命令 看log找错误改bug</p><p>都用于查看文本文件，区别在于： head显示文件的头n行，tail显示文件的尾n行，缺省情况n都为10行。可以通过-n方式指定行数，如：</p><p>head -100 file和tail -100 file分别表示显示文件头100行和尾100行内容。</p><p>n tail -f命令</p><p>可以实时查看文件新增内容。</p><h4 id="系统权限与磁盘管理操作-运维聊一聊">系统权限与磁盘管理操作 运维聊一聊</h4><p><strong>df disk free查看分区大小和占用情况</strong></p><p>-l 仅显示本地磁盘(默认）</p><p>-a 显示所有文件系统的磁盘使用情况，包含比如/proc/（查看包括0字节文件）</p><p>-h 以1024进制计算最合适的单位显示磁盘容量</p><p>-H 以1000进制计算最合适的单位显示磁盘容量</p><p>-T 显示磁盘分区类型（各个分区使用的文件系统）</p><p><strong>du disk usage统计磁盘上的文件大小</strong></p><p>-b 以byte为单位统计文件</p><p>-k 以KB为单位统计文件</p><p>-m 以MB为单位统计文件</p><p>-h 以1024进制计算最合适的单位统计文件</p><p>-H 以1000进制计算最合适的单位统计文件</p><p>-s 指定统计目标<br>第一 主分区和扩展分区总数不能超过4个<br>第二 扩展分区最多只能有一个<br>第三 扩展分区不能直接存取数据</p><p><strong>磁盘分区 fdisk</strong></p><ul><li>硬盘分区工具 &quot;fdisk&quot;命令</li></ul><p>使用fdisk分区需要跟一些参数</p><p>分区操作：</p><p>\0.fdisk -l 查看当前系统分区情况</p><p>1.fdisk /dev/sdb 进入分区模式 （fdisk 需要分区的磁盘设备名）</p><ol start="2"><li><p>输入 m 查看命令帮助信息</p></li><li><p>输入 n 添加分区</p></li></ol><p>p：主分区</p><p>e：扩展分区</p><p>l : 逻辑分区</p><p>设置起始和结束</p><p>大小 +数字[k, M, G]</p><p>\4. 输入 p 查看分配逻辑</p><p>\5. 输入 d 删除对应分区逻辑（删除是扩展分区的话，对应的逻辑分区也被删除）</p><p>\6. 输入 w 将分区逻辑实施并退出 fdisk命令</p><p>补充：在fdisk内部操作的分区操作，只是计划，只有当键入 w 时才会进行实际的分区</p><p><strong>chown</strong></p><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h4 id="计算机网络操作-神进化完成">计算机网络操作 *神进化完成</h4><p><strong>netstat 查看网络状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">    -t  列出TCP协议端口</span><br><span class="line">    -u  列出UDP协议端口</span><br><span class="line">    -n  不适用域名与服务名，而使用IP地址和端口号</span><br><span class="line">    -l  仅列出在监听状态网络服务</span><br><span class="line">    -a  列出所有的网络连接</span><br><span class="line">    -r  列出路由列表，功能和route命令一致</span><br><span class="line">    常用：-tuln –an –rn</span><br></pre></td></tr></table></figure><p><strong>route</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">route</span> –<span class="selector-tag">n</span> 查看路由列表（可以看到网关） <span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">default</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 临时设定网关</span><br></pre></td></tr></table></figure><p><strong>ifconfig 关闭与启动网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdown 网卡设备名</span><br><span class="line">    禁用该网卡设备</span><br><span class="line">ifup 网卡设备名</span><br><span class="line">    启用该网卡设备</span><br></pre></td></tr></table></figure><p><strong>nslookup 域名解析命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nslookup</span> <span class="selector-attr">[主机名或IP]</span> 进行域名与<span class="selector-tag">IP</span>地址解析 <span class="selector-tag">nslookup</span>&gt;<span class="selector-tag">server</span> 查看本机<span class="selector-tag">DNS</span>服务器</span><br></pre></td></tr></table></figure><p><strong>ping 网络测试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ping</span> <span class="selector-attr">[选项]</span> <span class="selector-tag">ip</span>或域名 探测指定<span class="selector-tag">IP</span>或域名的网络状况 <span class="selector-tag">-c</span> 次数：指定<span class="selector-tag">ping</span>报的次数</span><br></pre></td></tr></table></figure><p><strong>SSH 远程连接</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH命令</span><br><span class="line">    ssh 用户名<span class="meta">@ip</span></span><br><span class="line">        远程管理指定Linux服务器</span><br><span class="line">    scp [-r] 用户名<span class="meta">@ip</span>:文件路径 本地路径</span><br><span class="line">        下载文件到本地</span><br><span class="line">    scp [-r] 本地文件 用户名<span class="meta">@ip</span>:上传路径</span><br><span class="line">        上传文件到远程服务器</span><br></pre></td></tr></table></figure><p><strong>traceroute追踪</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-attr">[xuanxiang]</span> <span class="selector-tag">IP</span>或域名 路由跟踪命令 <span class="selector-tag">-n</span> 使用<span class="selector-tag">IP</span>，不使用域名，速度更快</span><br></pre></td></tr></table></figure><h4 id="curl-wget-必杀操作">curl wget 必杀操作</h4><p>当想要直接通过 [Linux] 命令行下载文件，马上就能想到两个工具：wget 和 cURL。它们有很多一样的特征，可以很轻易的完成一些相同的任务，虽然它们有一些相似的特征，但它们并不是完全一样。这两个程序适用与不同的场合，在特定场合下，都拥有各自的特性。</p><p>wget 和 cURL 都可以下载内容。它们的核心就是这么设计的。它们都可以向互联网发送请求并返回请求项。这可以是文件、图片或者是其他诸如网站的原始 HTML 之类。</p><p>这两个程序都可以进行 HTTP POST 请求。这意味着它们都可以向网站发送数据，比如说填充表单什么的。</p><p>由于这两者都是命令行工具，它们都被设计成可脚本化。wget 和 cURL 都可以写进你的 Bash 脚本 ，自动与新内容交互，下载所需内容。</p><p>wget 简单直接。这意味着你能享受它超凡的下载速度。wget 是一个独立的程序，无需额外的资源库，更不会做其范畴之外的事情。</p><p>wget 是专业的直接下载程序，支持递归下载。同时，它也允许你下载网页中或是 FTP 目录中的任何内容。</p><p>wget 拥有智能的默认设置。它规定了很多在常规浏览器里的事物处理方式，比如 cookies 和重定向，这都不需要额外的配置。可以说，wget 简直就是无需说明，开罐即食！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//soft.vpser.net/lnmp/lnmp1.1-full.tar.gz</span></span><br><span class="line">    下载命令</span><br></pre></td></tr></table></figure><p>cURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。</p><p>cURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。</p><p>cURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。</p><p>cURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。</p><p>cURL 同样支持让数据发送变得更容易的 gzip 压缩技术。</p><p>那你应该使用 cURL 还是使用 wget？这个比较得看实际用途。如果你想快速下载并且没有担心参数标识的需求，那你应该使用轻便有效的 wget。如果你想做一些更复杂的使用，直觉告诉你，你应该选择 cRUL。</p><p>cURL 支持你做很多事情。你可以把 cURL 想象成一个精简的命令行网页浏览器。它支持几乎你能想到的所有协议，可以交互访问几乎所有在线内容。唯一和浏览器不同的是，cURL 不会渲染接收到的相应信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演&lt;/p&gt;
&lt;h4 id=&quot;常规操作-小试牛刀&quot;&gt;常规操作 小试牛刀&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ls: 类似于dos下的dir命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ls最常用的参数有三个：
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://wuhewuhe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="https://wuhewuhe.github.io/tags/linux/"/>
    
      <category term="file" scheme="https://wuhewuhe.github.io/tags/file/"/>
    
      <category term="net" scheme="https://wuhewuhe.github.io/tags/net/"/>
    
      <category term="process" scheme="https://wuhewuhe.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>interface and class</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/interface-and-class/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/interface-and-class/</id>
    <published>2020-02-12T18:53:37.000Z</published>
    <updated>2020-02-12T18:55:50.013Z</updated>
    
    <content type="html"><![CDATA[<p>interface</p><p>contains parameter and method</p><p>method par default is public abstract, we can not concerate but since java 8, default</p><p>parameter par default is public static final</p><p>a interface can extends multi interface, but it should realise all of the parment methods</p><p>abstract class</p><p>abstract class can concentrate method and contains various type : public private static</p><p>abstract class can have static method</p><p>hériter only one class</p><p>1、抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。</p><p>2、当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</p><p>3、当注重代码的扩展性跟可维护性时，应当优先采用接口。①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活; ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;interface&lt;/p&gt;
&lt;p&gt;contains parameter and method&lt;/p&gt;
&lt;p&gt;method par default is public abstract, we can not concerate but since java 8, defau
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Java/Interview/"/>
    
    
      <category term="interface" scheme="https://wuhewuhe.github.io/tags/interface/"/>
    
      <category term="class" scheme="https://wuhewuhe.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>hashcode, equals区别与联系</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/hashcode-equal/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/hashcode-equal/</id>
    <published>2020-02-12T07:05:28.000Z</published>
    <updated>2020-02-15T17:44:59.644Z</updated>
    
    <content type="html"><![CDATA[<p>有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。下面我们一起来看一下，它们到底有什么区别，总结一波！</p><p>01、hashCode介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.hashCode());}</code></pre><p>}<br>通过调用hashCode()方法获取对象的hash值。</p><p>02、equals介绍<br>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.equals(obj));}</code></pre><p>}<br>03、hashCode() 和 equals() 有什么关系？<br>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我们梳理了一下 “hashCode() 和 equals()的关系”。我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><p>3.1、不会创建“类对应的散列表”<br>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</p><p>equals() 用来比较该类的两个对象是否相等，而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 举个例子</p><p>public class DemoNormalTest {</p><pre><code>public static void main(String[] args) {// 新建2个相同内容的Person对象，// 再用equals比较它们是否相等Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>p1.equals(p3) : false; p1(2018699554) p3(1735600054)<br>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><p>3.2、会创建“类对应的散列表”<br>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的:</p><p>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。<br>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。<br>举个例子</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，    Person p1 = new Person(&quot;eee&quot;, 100);    Person p2 = new Person(&quot;eee&quot;, 100);    Person p3 = new Person(&quot;aaa&quot;, 200);    // 新建HashSet对象     HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();    set.add(p1);    set.add(p2);    set.add(p3);    // 比较p1 和 p2， 并打印它们的hashCode()    System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());     // 打印set    System.out.printf(&quot;set:%s\n&quot;, set); }private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>set:[(eee, 100), (aaa, 200), (eee, 100)]<br>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>举个例子，我们同时覆盖equals() 和 hashCode()方法。</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);Person p4 = new Person(&quot;EEE&quot;, 100);// 新建HashSet对象HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();set.add(p1);set.add(p2);set.add(p3);set.add(p4);// 比较p1 和 p2， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());// 比较p1 和 p4， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());// 打印setSystem.out.printf(&quot;set:%s\n&quot;, set);}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot; + name + &quot;, &quot; + age + &quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}/** * 重写hashCode方法 */@Overridepublic int hashCode() {int nameHash = name.toUpperCase().hashCode();return nameHash ^ age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(68545) p2(68545)<br>p1.equals(p4) : false; p1(68545) p4(68545)<br>set:[(eee, 100), (EEE, 100), (aaa, 200)]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="hashcode" scheme="https://wuhewuhe.github.io/tags/hashcode/"/>
    
      <category term="equals" scheme="https://wuhewuhe.github.io/tags/equals/"/>
    
  </entry>
  
  <entry>
    <title>set家族的对比</title>
    <link href="https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/"/>
    <id>https://wuhewuhe.github.io/2020/02/12/set-hashset-treeset-linkedset/</id>
    <published>2020-02-12T06:57:33.000Z</published>
    <updated>2020-02-12T07:04:04.558Z</updated>
    
    <content type="html"><![CDATA[<p>Set接口<br>Set 接口与 List 接口相比没有那么多操作方法，比如：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><p>对比一下Set接口和Collection接口就知道，其实Set接口仅仅对Collection所有方法进行继承而已，而自己没有扩展任何方法，Set接口与Collection接口一样，都是15个方法。</p><img src="/2020/02/12/set-hashset-treeset-linkedset/set.jpg" alt="set" style="zoom:100%; ">Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。这里说的相同元素指的是用 equals() 方法比价后返回 true，当然了如果用 == 也返回true，那肯定也是相同的。一. HashSet特点：<ol><li><p>HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是无序的。</p></li><li><p>HashSet如何保证唯一性？</p></li></ol><p>1). HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2). 确保唯一性的两个方法：hashCode()和equals()方法。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>二. LinkedHashSet<br>特点：</p><ol><li><p>LinkedHashSet中不能有相同元素，可以有一个Null元素，元素严格按照放入的顺序排列。</p></li><li><p>LinkedHashSet如何保证有序和唯一性？</p></li></ol><p>1). 底层数据结构由哈希表和链表组成。</p><p>2). 链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>三. TreeSet<br>特点：</p><ol><li><p>TreeSet是中不能有相同元素，不可以有Null元素，根据元素的自然顺序进行排序。</p></li><li><p>TreeSet如何保证元素的排序和唯一性？</p></li></ol><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(log(n))</p></li><li><p>非线程安全</p></li></ol><p>四. 总结：<br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Set接口&lt;br&gt;
Set 接口与 List 接口相比没有那么多操作方法，比如：&lt;/p&gt;
&lt;p&gt;1、List 接口能直接设置或获取某个元素的值，而Set接口不能。&lt;/p&gt;
&lt;p&gt;2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。&lt;/p&gt;
&lt;p&gt;3、List
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
      <category term="Set" scheme="https://wuhewuhe.github.io/categories/Java/Collections/Set/"/>
    
    
      <category term="hashset" scheme="https://wuhewuhe.github.io/tags/hashset/"/>
    
      <category term="linkedhashset" scheme="https://wuhewuhe.github.io/tags/linkedhashset/"/>
    
      <category term="treeset" scheme="https://wuhewuhe.github.io/tags/treeset/"/>
    
  </entry>
  
  <entry>
    <title>讲清楚Vector vs ArrayList vs LinkedList</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/vector-arraylist-linkedlist/</id>
    <published>2020-02-11T20:10:29.000Z</published>
    <updated>2020-02-11T20:22:35.670Z</updated>
    
    <content type="html"><![CDATA[<p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></li><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></li><li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p></li><li><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p></li><li><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p></li><li><p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p></li><li><p>笼统来说：LinkedList：增删改快，ArrayList：查询快（有索引的存在）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ArrayLis
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Collections/"/>
    
    
      <category term="vector" scheme="https://wuhewuhe.github.io/tags/vector/"/>
    
      <category term="arraylist" scheme="https://wuhewuhe.github.io/tags/arraylist/"/>
    
      <category term="linkedlist" scheme="https://wuhewuhe.github.io/tags/linkedlist/"/>
    
  </entry>
  
  <entry>
    <title>面试高频HashMap VS HashTable</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/hashmapVsHashtable/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/hashmapVsHashtable/</id>
    <published>2020-02-11T20:05:27.000Z</published>
    <updated>2020-02-11T20:07:51.252Z</updated>
    
    <content type="html"><![CDATA[<p>在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一样的。·<br>在使用时一般是用ArrayList代替Vector，LinkedList代替Stack，HashMap代替HashTable，即使在多线程中需要同步，也是用同步包装类。<br>另外在使用上还有一些小的差异，比如：</p><ul><li><p>HashTable的key和value都不允许为null值，而HashMap的key和value则都是允许null值的。这个其实没有好坏之分，只是Sun为了统一Collection的操作特性而改进的。</p></li><li><p>HashTable有一个contains(Object value)方法，功能上与containsValue(Object value)一样，但是在实现上花销更大，现在已不推荐使用。而HashMap只有containsValue(Object value)方法。</p></li><li><p>HashTable使用Enumeration，HashMap使用Iterator。Iterator其实与Enmeration功能上很相似，只是多了删除的功能。用Iterator不过是在名字上变得更为贴切一些。模式的另外一个很重要的功用，就是能够形成一种交流的语言（或者说文化）。有时候，你说Enumeration大家都不明白，说Iterator就都明白了。</p></li></ul><p><strong>不同点</strong></p><h4 id="接口">接口</h4><p><img src="https://pic3.zhimg.com/80/v2-12c49eba132902bbea990a4d77ecce37_hd.jpg" alt="img" style="zoom:50%;"><img src="https://pic3.zhimg.com/80/v2-d7d5449c9638ec4955288a3aa2ba9f13_hd.jpg" alt="img"></p><p>HashMap和Hashtable不仅作者不同，而且连父类也是不一样的。HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口</p><p>Dictionary类是一个已经被废弃的类（见其源码中的注释）。父类都被废弃，自然而然也没人用它的子类Hashtable了。</p><h4 id="线程安全">线程安全</h4><p>线程安全性不同</p><p>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</p><p>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，</p><p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><h4 id="初始容量大小和每次扩充容量大小的不同">初始容量大小和每次扩充容量大小的不同</h4><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说Hashtable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。</p><h4 id="计算hash值的方法不同">计算hash值的方法不同</h4><p>为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p><p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><p><img src="https://pic4.zhimg.com/50/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"></p><p>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</p><p>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p><p>HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算</p><p>为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
      <category term="Interview" scheme="https://wuhewuhe.github.io/categories/Java/Interview/"/>
    
      <category term="Collections" scheme="https://wuhewuhe.github.io/categories/Java/Interview/Collections/"/>
    
    
      <category term="hashmap" scheme="https://wuhewuhe.github.io/tags/hashmap/"/>
    
      <category term="hashtable" scheme="https://wuhewuhe.github.io/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>2分钟说清楚shell和batch文件</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/shellandbatch/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/shellandbatch/</id>
    <published>2020-02-11T19:52:06.000Z</published>
    <updated>2020-02-11T19:54:35.748Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg" alt="Batch Programming (Dos Scripting) VS Shell Scripting" style="zoom:50%; ">Batch file</p><p>batch programming vs shell programming</p><p><img src="http://www.gonet.com.cn/~editor/eweditor/uploadfile/20171027141729471.png" alt="区别"></p><p>由于我们普通人接触UNIX的比较少，就不在多说。今天主要来说说WINDOWS系统和LINUX及苹果操作系统的区别。首先这三个系统设计上有本质的区别。最大的区别在于WINDOWS是一个成熟的商业操作系统，拿过来就能用，而LINUX不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。</p><img src="https://img-blog.csdn.net/20180619102423833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVfQXlt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表格" style="zoom:%; "><p>When I started my career in IT field, I have landed into windows world, as I know that no companies give chance to a fresher to work on production Linux/Unix servers. Its a good experience to work on <strong>DOS scripts(aka Batch programming).</strong> There are many <strong>similarities/differences/advantages/disadvantages</strong> between <strong>Batch programming</strong> and <strong>Shell scripting</strong>. Lets see what they are.</p><p><strong>Similarities</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Sequential execution of group commands in a batch file</td><td>Sequential execution of group command in shell scripts</td></tr><tr><td>2</td><td>Can read inputs from users</td><td>Can read inputs from users</td></tr><tr><td>3</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td></tr><tr><td>4</td><td>Supports advanced features such as Functions and Arrays</td><td>Supports advanced features such as Functions and Arrays</td></tr><tr><td>5</td><td>Supports regular expressions(using findstr)</td><td>Supports regular expressions</td></tr><tr><td>6</td><td>Can include other programming codes such as perl(ie…in middle of dos script we can include some other programming language code for effective scripting to get our desired output)</td><td>Can include other programming codes such as Perl, AWK, SED etc.</td></tr></tbody></table><p><strong>Differences</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Lack of richness of tools/commands</td><td>Have good number of tools(as of my knowledge there are more than 75000 commands in Linux/Unix)</td></tr><tr><td>2</td><td>Supports only one vendor(i.e.windows)</td><td>Supports for number of vendors such as Sun/apple/IBM AIX/HP-UX/GNU Linux etc.</td></tr><tr><td>3</td><td>No other variants for DOS</td><td>There are number of variants such as bash, ksh, csh, zsh etc…</td></tr><tr><td>4</td><td>Low capabilities of integrating with other programming code in batch scripting</td><td>Good capabilities of integrating other programming code in shell script</td></tr><tr><td>5</td><td>Cannot handle complex regular expressions</td><td>Can handle complex regular expressions.</td></tr><tr><td>6</td><td>A batch file should always end with .bat</td><td>There is no such concept like file extension, but a shell script file permission should be set to executable.</td></tr><tr><td>7</td><td>To execute a batch program just enter the file name at CLI</td><td>To execute a shell script, here are the ways to execute it 1)chmod +x <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a>; ./shellscript.sh 2)sh <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg&quot; alt=&quot;Batch Programming (Dos Scripting) VS Shell
      
    
    </summary>
    
    
      <category term="OS" scheme="https://wuhewuhe.github.io/categories/OS/"/>
    
    
      <category term="shell" scheme="https://wuhewuhe.github.io/tags/shell/"/>
    
      <category term="batch" scheme="https://wuhewuhe.github.io/tags/batch/"/>
    
  </entry>
  
  <entry>
    <title>由String浅谈Immutable不可变对象设计模式</title>
    <link href="https://wuhewuhe.github.io/2020/02/11/java-immutable/"/>
    <id>https://wuhewuhe.github.io/2020/02/11/java-immutable/</id>
    <published>2020-02-11T07:11:08.000Z</published>
    <updated>2020-02-11T07:31:30.180Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是Immutable</h1><p>Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而<strong>不用加锁实现线程安全</strong>，因为不可变对象一定是线程安全的，同时由于不需要用一些锁机制等保证内存一致性问题也减少了同步开销。<br>谈到Immutable Object会让很多Javaer联想到Java语言中的final关键字，final关键字可以修饰属性、方法和类。final的作用为</p><blockquote><p>final 修饰的 class 代表该类不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p></blockquote><p>那是不是被final修饰的对象就可以认为是Immutable Object呢？当然不是。请看下面的例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strList = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strList.add(<span class="string">"ONE"</span>);  <span class="comment">//ok</span></span><br><span class="line">strList.add(<span class="string">"TWO"</span>);  <span class="comment">//ok</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; unmodifiableStrList = Collections.unmodifiableList(strList);</span><br><span class="line">unmodifiableStrList.add(<span class="string">"THREE"</span>); <span class="comment">//throw UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p>这个例子中 <code>strList</code> 声明成final，只能说明strList变量指向的地址空间不能改变但是该地址空间指向的内容是可以修改的。</p><h1>如何定义Immutable Object</h1><p>Java 语言目前还没有原生的不可变对象的支持，但在<a href="https://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener">Java™ Tutorials</a>中给出的如何定义一个不可变对象的方法。</p><p>类中的属性不提供&quot;setter&quot;方法；</p><p>类中所有的属性声明成private和final类型；</p><p>类也声明成final的，以防止类被继承；</p><p>如果有属性是引用类型的，也要防止引用类型的属性被调用方修改了，如通过构造器初始化所有成员，尤其是引用对象要进行深拷贝(deep copy，符合copy-on-write 原则)；</p><p>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，也要深拷贝，创建私有的 copy。</p><p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name,String address)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getAddress() &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看上面示例中使用到的 <code>Collections.unmodifiableList()</code> 方法是如何将一个可变的对象变成不可变对象</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; unmodifiableList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的list是ArrayList，他是RandomAccess的实例</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(<span class="keyword">list</span>) :</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableList&lt;&gt;(<span class="keyword">list</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UnmodifiableRandomAccessList对象是Collections的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableRandomAccessList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    UnmodifiableRandomAccessList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnmodifiableList</code> 是 <code>UnmodifiableRandomAccessList</code> 的父类，它们两个都是 <code>Collections</code> 的静态内部类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;E&gt; <span class="title">extends</span> <span class="title">UnmodifiableCollection</span>&lt;E&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List</span>&lt;E&gt; &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;? extends E&gt; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    UnmodifiableList(List&lt;? extends E&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        super(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">list</span> = <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">list</span>.get(index);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List unmodifiableStrList = Collections.unmodifiableList(strList);</code> 语句执行之后unmodifiableStrList变量实际指向的类型会变成 <code>UnmodifiableList</code> 。然后再执行add方法的时候就会抛出 <code>UnsupportedOperationException</code> 异常。<br>除了 <code>unmodifiableList()</code> 方法之外， <code>Collections</code> 中还定义了将其他集合修饰成不可变对象的方法。</p><ul><li>Collections.unmodifiableCollection()</li><li>Collections.unmodifiableMap()</li><li>Collections.unmodifiableSortedMap()</li><li>Collections.unmodifiableSet()</li><li>Collections.unmodifiableSortedSet()</li></ul><p>其基本实现思路和 <code>unmodifiableList()</code> 方法是一样的，另外 <code>Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;);</code> 返回的List对象也是不可变的。</p><h1>String对象的不可变性</h1><p><code>String</code> 是典型的 Immutable 类，被声明成为 final class，它的属性基本都是 final 的。由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。下面是String源码的部分摘录，可以看到它是符合Immutable Object的定义规则的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D;</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 进行深拷贝来构造引用类型的成员变量 *&#x2F;</span><br><span class="line">    public String(char value[]) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public String(StringBuilder builder) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">    &#125;</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen &#x3D; str.length();</span><br><span class="line">        if (otherLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; value.length;</span><br><span class="line">        char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public char[] toCharArray() &#123;</span><br><span class="line">        &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">        char result[] &#x3D; new char[value.length];</span><br><span class="line">        System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可见，string是线程安全的，java中string对象需要慎用尤其是我们有大量的字符串拼接修改删除增加的操作时，这会造成大量的内存开销，由此我们可以考虑使用stringbuilder。如果需要同步，则可以使用stringbuffer</p><p>那就要分别看看它们的 <code>append()</code> 源码了；</p><p>StringBuilder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder中的append方法没有使用synchronized关键字，意味着多个线程可以同时访问这个方法。那么问题就来了额，如果两个线程同时访问到这个方法，那么AbstractStringBuilder中的count是不是就是相同的，所以这两个线程都是在底层char数组的count位置开始append添加，那么最终的结果肯定就是在后执行的那个线程append进去的数据会将前面一个覆盖掉。因此我们的控制台输出才会出现StringBuilder一直都是小于1000的。然而StringBuffer却不会发生这种情况。</p><h2 id="总结">总结</h2><ol><li>StringBuilder相比StringBuffer效率更高，但多线程不安全；</li><li>在单线程中字符串的频繁拼接使用StringBuilder效率更高，对于多线程使用StringBuffer则更安全；</li><li>字符串简单操作时没必要使用上述两者，还是用String类型提高速度；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;什么是Immutable&lt;/h1&gt;
&lt;p&gt;Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而&lt;s
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="string" scheme="https://wuhewuhe.github.io/tags/string/"/>
    
      <category term="immutable" scheme="https://wuhewuhe.github.io/tags/immutable/"/>
    
      <category term="stringbuilder" scheme="https://wuhewuhe.github.io/tags/stringbuilder/"/>
    
      <category term="stringbuffer" scheme="https://wuhewuhe.github.io/tags/stringbuffer/"/>
    
  </entry>
  
  <entry>
    <title>大白话说Serializable</title>
    <link href="https://wuhewuhe.github.io/2020/02/10/transient-java/"/>
    <id>https://wuhewuhe.github.io/2020/02/10/transient-java/</id>
    <published>2020-02-10T19:51:27.000Z</published>
    <updated>2020-02-10T21:02:35.531Z</updated>
    
    <content type="html"><![CDATA[<p>大白话定义：</p><p>序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.</p><p><strong>切记序列化不考虑static变量</strong></p><p>Java原生序列化方式是通过实现Serializable接口实现的. 不实现该接口会导致无法序列化, 抛出异常如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException</span><br></pre></td></tr></table></figure><p>序列化的应用场景：</p><blockquote><p>将对象转换为字节流, 用于网络传输, 例如用于RPC远程调用。</p><p>将对象保存到磁盘中</p></blockquote><p>Java原生序列化是通过IO包中的ObjectInputStream和ObjectOutputStream实现的。ObjectOutputStream类负责实现序列化, ObjectInputStream类负责实现反序列化。</p><h4 id="Java序列化反序列化实例">Java序列化反序列化实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Person [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class testPerson &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transient">transient</h4><p>出于安全问题，有时候不会把指定字段进行序列化保存，例如密码, 此处以Person对象的pwd字段为例, 为pwd字段添加transient修饰后，默认序列化机制会忽略它。</p><p>对比结果如下 尽管我们对pwd初始化为mdp，但是由于transient关键字，则pwd不被序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;);</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;null]</span><br></pre></td></tr></table></figure><p>如果transient修饰的字段也需要序列化和反序列化，可以使用readObject和writeObject方法。</p><p>我们只需要在当前 Person 类中添加 readObject() 和 writeObject() 方法，在 writeObject 方法中实现对 pwd 的字段赋值，就可以使pwd字段被序列化到字节流中；在 readObject 方法中实现对 pwd 字段读取，并赋值给Person对象即可。<br>添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private transient String pwd;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream s) throws Exception &#123;</span><br><span class="line">s.defaultReadObject();</span><br><span class="line">this.pwd &#x3D; (String) s.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream s) throws Exception &#123;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">this.pwd &#x3D; &quot;pwd&quot;;</span><br><span class="line">s.writeObject(this.pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPwd(String pwd) &#123;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readObject和writeObject在本文后段内容会讲解.</p><p>这里的defaultWriteObject方法作用是序列化非transient字段以及非静态字段; 这里的defaultReadObject方法作用是反序列化非transient字段以及非静态字段; 当类中含有非transient字段时, 一定要加上这两个方法.</p><p>如果被序列化的类中存在多个transient的字段, 序列化时需要如下操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class TransientPerson implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private transient Integer age;</span><br><span class="line">private transient String name;</span><br><span class="line">private transient Integer money;</span><br><span class="line"></span><br><span class="line">public TransientPerson(Integer age, String name, Integer money) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">this.age &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.money &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.name &#x3D; (String) stream.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeObject(this.age);</span><br><span class="line">stream.writeObject(this.money);</span><br><span class="line">stream.writeObject(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMoney(Integer money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;TransientPerson [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;transientperson.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">TransientPerson person &#x3D; new TransientPerson(3, &quot;abc&quot;, 123);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">TransientPerson newPerson &#x3D; (TransientPerson) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc, money &#x3D; 123]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><hr><p>这里writeObject和readObject的使用是有顺序的, 例如第一次writeObject是将age作为Object写入, 所以第一次调用readObject读到的对象就一定是age; 所以, 写入的顺序是age, money, name, 读取时候的顺序一定也要是age, money, name.</p><p>上面理论上会写入了四个对象, 第一个是defaultWriteObject写入的Person对象, 之后写入的是age(Integer对象), money(Integer), name(String).</p><p>当然这里defaultWriteObject没有写入, 因为所有成员字段都是transient修饰, 所以实际上只有三个对象(age, money, name). 换句话说, 当所有字段被transient修饰时, 可以不用defaultWriteObject和defaultReadObject.</p><h4 id="serialVersionUID">serialVersionUID</h4><p>当person对象被序列化保存到person.txt文件时, 在Person对象中添加新的属性address, 只执行反序列化代码, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">&#x2F;&#x2F;Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;, &quot;paris&quot;);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.writeObject(person);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">&#x2F;&#x2F;System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><p>输出结果依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;pwd, address&#x3D;null]</span><br></pre></td></tr></table></figure><p>但是我们删除serialVersionUID字段后再次执行, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line">private transient String pwd;</span><br><span class="line">private String address; &#x2F;&#x2F; 新添加的属性</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd, String address) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">this.address &#x3D; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: wotest.test.Person;  local class incompatible: stream classdesc serialVersionUID &#x3D; 1,  local class serialVersionUID &#x3D; 3229018537912438741</span><br></pre></td></tr></table></figure><p>原因:</p><blockquote><p>没有定义serialVersionUID值, 反序列化可能会出现 <code>local class incompatible</code> 异常, 是Java的安全机制.</p><p>当序列化对象时, 如果该对象所属类没有serialVersionUID, Java编译器会对jvm中该类的Class文件进行摘要算法生成一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; serialVersionUID(version1), 并保存在序列化结果中. </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当反序列化时, jvm会再次对jvm中Class文件摘要生成一个serialVersionUID(version2). 当且仅当version1=version2时, 才会将反序列化结果加载入jvm中, 否则jvm会判断为不安全, 拒绝载入并抛出 <code>local class incompatible</code> 异常.</p><p>这样存在的问题就是, 当对象被序列化后, 其所属类只要进行过类名称, 它所实现的接口的名称, 以及所有成员名称的修改, 会导致摘要算法算出的serialVersionUID变化.</p></blockquote><p>从而version1 != version2导致抛出异常.</p><blockquote><p>例如序列化对象存储在磁盘中后, jvm停止, 对其所属类进行修改. 再次启动jvm, 对该对象序列化时就会抛异常.</p></blockquote><p>由此可知, 反序列化时会通过比较serialVersionUID进行 <code>判断反序列化内容是否安全</code> , 所以添加如下声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 3229018537912438741L;</span><br></pre></td></tr></table></figure><p>将serialVersionUID值固定下来, 可以防止这种情况下的反序列化失败.</p><p><strong>另外, 如果 User 对象升级版本，修改了结构，而且不想兼容之前的版本，那么只需要修改下 serialVersionUID 的值就可以了。</strong></p><p>建议，每个需要序列化的对象，都要添加一个 serialVersionUID 字段。</p><p><strong>最后延伸一下，HashMap中重写的writeObject和readObject</strong></p><h5 id="HashMap序列化存在的问题">HashMap序列化存在的问题</h5><p>HashMap有必须重写它们的理由, 因为序列化会导致字节流在不同的jvm中传输, 而序列化基本要求就是反序列化后的对象与序列化之前的对象是一致的.</p><p>HashMap中，由于Entry的存放位置是根据Key的Hash值计算, 对于同一个Key，在不同的jvm中计算得出的Hash值可能是不同的.</p><p>Hash值不同导致HashMap对象反序列化的结果与序列化之前不一致. 有可能序列化之前Key=’name’的元素放在数组的第0个位置, 而反序列化后在数组第2个位置.</p><h5 id="HashMap的解决方式">HashMap的解决方式</h5><ul><li><p>将可能造成数据不一致的元素使用transient修饰，然后重写writeObject/readObject方法, 在该方法中操作这些敏感元素, 避免默认序列化方法的干扰。被transient修饰的元素有: Entry[] table, size, modCount。</p></li><li><p>首先，HashMap序列化的时候会屏蔽掉负载因子, 只把不为空的key和value进行序列化. 传送到新的jvm反序列化时, 根据新的jvm处的规则重新对key进行hash算法, 重新填充一个数组. 这样避免了对象的不一致.</p></li></ul><h5 id="HashMap源码">HashMap源码</h5><p>writeObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    int buckets &#x3D; capacity();</span><br><span class="line">    &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s); &#x2F;&#x2F; 将有效的键值对进行了序列化.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到writeObject中序列化了buckets和size, 之后又通过internalWriteEntries方法将有效的键值对进行了序列化.</p><p>之后在readObject方法中反序列化时也要按照这个顺序.</p></blockquote><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                &#x2F;&#x2F; Read and ignore number of buckets</span><br><span class="line">    int mappings &#x3D; s.readInt(); &#x2F;&#x2F; Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; &#x2F;&#x2F; (if zero, use defaults)</span><br><span class="line">        &#x2F;&#x2F; Size the table using given load factor only if within</span><br><span class="line">        &#x2F;&#x2F; range of 0.25...4.0</span><br><span class="line">        float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;</span><br><span class="line">        int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft &#x3D; (float)cap * lf;</span><br><span class="line">        threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table &#x3D; tab;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key &#x3D; (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value &#x3D; (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按照顺序依次读出了:</p><ul><li>对象中非transient以及非static字段(defaultReadObject方法);</li><li>buckets, 但是被忽略了(见注释: Read and ignore number of buckets);</li><li>size(int mappings = s.readInt());</li><li>根据size遍历读取键值对(for (int i = 0; i &lt; mappings; i++)).</li></ul></blockquote><p>遍历读取的键值对最终依据新的规则保存到了新的map中, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key &#x3D; (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value &#x3D; (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList重写writeObject和readObject">ArrayList重写writeObject和readObject</h4><p>值得注意的是, ArrayList重写writeObject和readObject. 是因为在ArrayList中的数组容量基本上都会比实际的元素的数大, 为了避免序列化没有元素的数组而重写.</p><ul><li>writeObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in capacity</span><br><span class="line">    s.readInt(); &#x2F;&#x2F; ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a &#x3D; elementData;</span><br><span class="line">        &#x2F;&#x2F; Read in all elements in the proper order.</span><br><span class="line">        for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大白话定义：&lt;/p&gt;
&lt;p&gt;序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切记序列化不考虑static变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java原生序列化方式是通过实现Serializable接口实现的.
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="serialisation" scheme="https://wuhewuhe.github.io/tags/serialisation/"/>
    
      <category term="deserialisation" scheme="https://wuhewuhe.github.io/tags/deserialisation/"/>
    
  </entry>
  
  <entry>
    <title>动态委托</title>
    <link href="https://wuhewuhe.github.io/2020/02/04/delegate-avance/"/>
    <id>https://wuhewuhe.github.io/2020/02/04/delegate-avance/</id>
    <published>2020-02-04T21:36:17.000Z</published>
    <updated>2020-02-04T21:59:21.759Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇的内容<br>大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;技术方法</span><br><span class="line">public interface OledTch &#123;</span><br><span class="line">&#x2F;&#x2F; 技术名称</span><br><span class="line">public void tchName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 色彩饱和度</span><br><span class="line">public void colorSaturation();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星</span><br><span class="line">public class Sumsung implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;98%NTSC - Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;华为</span><br><span class="line">public class Huawei implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;富士康</span><br><span class="line">public class Fotconn implements OledTch &#123;</span><br><span class="line">private OledTch oledMap; &#x2F;&#x2F;富土康的OLED生产图纸</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：甲方指定用哪家的图纸就用哪家的图纸</span><br><span class="line">public Fotconn(OledTch oledMap) &#123;</span><br><span class="line">this.oledMap &#x3D; oledMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：默认情况下，用华为的生产图纸</span><br><span class="line">public Fotconn() &#123;</span><br><span class="line">this.oledMap &#x3D; new Huawei();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">oledMap.tchName();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">                oledMap.colorSaturation();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class Xiaomi_Pipeline &#123;</span><br><span class="line"></span><br><span class="line">public void oled() &#123;</span><br><span class="line">Sumsung sumsung &#x3D; new Sumsung(); &#x2F;&#x2F; 确定使用三星的OLED技术</span><br><span class="line">Fotconn fotconn &#x3D; new Fotconn(sumsung);&#x2F;&#x2F; 告诉乙方 富土康：“我要三星图纸生产的OLED”</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小米正在生产: &quot;);</span><br><span class="line">fotconn.tchName();</span><br><span class="line">fotconn.colorSaturation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testXiaomi8() &#123;</span><br><span class="line">Xiaomi_Pipeline xiaomi8 &#x3D; new Xiaomi_Pipeline();</span><br><span class="line">xiaomi8.oled();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.39.03.png" alt="屏幕快照 2020-02-04 22.39.03" style="zoom:33%; "><p>我想讲一下我今天新学到的这个思路，就是动态代理，假象一个环境，我们用schduler来调控我们的任务，然后每一个任务对应不同的service，每个service我们有具体的实现方法，这时我们可以用到invoke的动态委托，我来画一个图。</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.04.13.png" alt="屏幕快照 2020-02-04 22.04.13" style="zoom:50%; "><h4 id="使用动态代理">使用动态代理</h4><h4 id="定义接口">定义接口</h4><p>下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下动态代理的简单实现，委托类和代理类都实现了Sell接口，Sell接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 委托类和代理类都实现了Sell接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Sell &#123; </span><br><span class="line">    void sell(); </span><br><span class="line">    void ad();</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler接口">InvocationHandler接口</h4><p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 调用处理程序</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface InvocationHandler &#123; </span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。</p><h4 id="委托类的定义">委托类的定义</h4><p>动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Vendor implements Sell &#123; </span><br><span class="line">    public void sell() &#123; </span><br><span class="line">        System.out.println(&quot;In sell method&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        System,out.println(&quot;ad method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中介类">中介类</h4><p>上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123; </span><br><span class="line">    &#x2F;&#x2F;obj为委托类对象; </span><br><span class="line">    private Object obj; </span><br><span class="line"> </span><br><span class="line">    public DynamicProxy(Object obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @Override </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span><br><span class="line">        System.out.println(&quot;before&quot;); </span><br><span class="line">        Object result &#x3D; method.invoke(obj, args); </span><br><span class="line">        System.out.println(&quot;after&quot;); </span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法</p><h3 id="动态生成代理类">动态生成代理类</h3><p>动态生成代理类的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123; </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建中介类实例 </span><br><span class="line">        DynamicProxy inter &#x3D; new DynamicProxy(new Vendor()); </span><br><span class="line">        &#x2F;&#x2F;加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取代理类实例sell </span><br><span class="line">        Sell sell &#x3D; (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter)); </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;通过代理类对象调用代理类方法，实际上会转到invoke方法调用 </span><br><span class="line">        sell.sell(); </span><br><span class="line">        sell.ad(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br></pre></td></tr></table></figure><p>复制代码方法的三个参数含义分别如下：<br>loader：定义了代理类的ClassLoder;<br>interfaces：代理类实现的接口列表<br>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例<br>我们运行一下，看看我们的动态代理是否能正常工作。我这里运行后的输出为</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cbbd27e07f9a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="代理模式">代理模式</h3><p>这个应该是设计模式中最简单的一个了，类图</p><p>代理模式最大的特点就是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作</p><p>Java动态代理其实内部也是通过Java反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后作一些相应的处理，这样说的比较笼统，举个简单的例子</p><p>比如我们在应用中有这样一个需求，在对某个类的一个方法的调用前和调用后都要做一下日志操作，</p><p>一个普通的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AppService &#123;  </span><br><span class="line">    public boolean createApp(String name);  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该接口的默认实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AppServiceImpl implements AppService &#123;  </span><br><span class="line">    public boolean createApp(String name) &#123;  </span><br><span class="line">        System.out.println(&quot;App[&quot;+name+&quot;] has been created.&quot;);  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>日志处理器（实质充当了中介类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 注意需实现Handler接口  </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LoggerInterceptor implements InvocationHandler &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;目标对象的引用，这里设计成Object类型，更具通用性  </span><br><span class="line">    public LoggerInterceptor(Object target)&#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] arg)  throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;Entered &quot;+target.getClass().getName()+&quot;-&quot;+method.getName()+&quot;,with arguments&#123;&quot;+arg[0]+&quot;&#125;&quot;);  </span><br><span class="line">        Object result &#x3D; method.invoke(target, arg);&#x2F;&#x2F;调用目标对象的方法  </span><br><span class="line">        System.out.println(&quot;Before return:&quot;+result);  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>外部调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AppService target &#x3D; new AppServiceImpl();&#x2F;&#x2F;生成目标对象  </span><br><span class="line">        &#x2F;&#x2F;接下来创建代理对象  </span><br><span class="line">        AppService proxy &#x3D; (AppService) Proxy.newProxyInstance(  </span><br><span class="line">                target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), new LoggerInterceptor(target));  </span><br><span class="line">        proxy.createApp(&quot;Kevin Test&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上一篇的内容&lt;br&gt;
大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wuhewuhe.github.io/categories/Java/"/>
    
    
      <category term="delegate" scheme="https://wuhewuhe.github.io/tags/delegate/"/>
    
      <category term="design pattern" scheme="https://wuhewuhe.github.io/tags/design-pattern/"/>
    
  </entry>
  
</feed>
