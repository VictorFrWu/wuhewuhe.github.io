<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>He WU</title>
  
  <subtitle>stay hungry, stay foolish, never give up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-05T17:25:20.986Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WU He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有路径问题浅谈动态规划</title>
    <link href="http://yoursite.com/2020/01/05/path-dp/"/>
    <id>http://yoursite.com/2020/01/05/path-dp/</id>
    <published>2020-01-05T16:32:11.000Z</published>
    <updated>2020-01-05T17:25:20.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是动态规划">什么是动态规划</h3><p>在网上找到一个很形象的例子，猿爸爸把 1+1+1+1+1+1+1+1 = 写在纸上，问小猿（咦）：<br>「它们加起来是多少哇？」</p><p>（数了一会…）「8 ！」</p><p>猿爸爸在左边又加了个 1+，再问一次小猿：<br>「现在呢？」</p><p>（迅速地）「9 ！」</p><p>「为什么小猿这么快就知道了呢？」</p><p>「因为你刚刚加了 1 啊~」</p><p>「所以只要记得之前的结果，就不用再计一次数啦。」</p><p>嗯，动态规划就是一种「先记住些事，方便后面节约时间」的神奇方法</p><hr><h3 id="定义">定义</h3><blockquote><p>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.</p></blockquote><p>以上GeeksforGeeks对动态规划的诠释，于我而言，我认为动态规划的核心思想就是如何将原有的问题拆分成字问题。<strong>如果这个问题我们要是可以用滴归来解决，那么我们一般可以通过动态规划的思路来降低时间复杂度。</strong></p><hr><h3 id="动态规划套路">动态规划套路</h3><p>我认为动态规划总体来讲可以分为三个步骤：</p><ul><li>设定状态</li><li>初始化</li><li>状态转移方程</li></ul><p>具体这三步指的是什么，我将通过路径问题来向大家逐一介绍。</p><p>网上有很多大神总结动态规划可以分为自下而上和自上而下，这一块我天资愚钝，没有领悟得很透彻，就不过多深入去说。</p><hr><h3 id="例题">例题</h3><p>本题是我从leetcode上的第62题，可以说是一道非常经典的动态规划入门题：</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 16.49.32.png" alt="Screenshot 2020-01-05 at 16.49.32" style="zoom:50%; "><p>题目让我们找到从图的左上角到右下角的所有路径，告诉我们只能向下或者向右走。</p><h3 id="题目分析">题目分析</h3><p>首先这个题是一个<strong>计数</strong>问题，提到计数这个关键词，那么很快我们就可以联想到程序猿爸爸让儿子1+1+1… .</p><ul><li>状态</li></ul><p>我们可以将这个题转化为一个m*n的矩阵，矩阵上的每一个格子的值就代表从左上到达该格子的所有路径总和。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.10.53.png" alt="Screenshot 2020-01-05 at 17.10.53" style="zoom:25%; "><p>如图所示，由A到B最多有两个路径： 1 右 下 2 下右。 所以B对应的状态为2，A对应的状态为1</p><ul><li><p>初始化</p><p>明确了状态之后，我们需要对矩阵初始化，为了题目给定了矩阵的长和宽，那么我们就可以创建一个对应的m*n的矩阵，然后我们知道初始位置是左上角，所以其初始值为1，然后最上面的一行和最左面的一行值也都为1。因为我们只有一种方式可以到达他们。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.17.33.png" alt="Screenshot 2020-01-05 at 17.17.33" style="zoom:25%; "></li><li><p>状态转换方程</p><p>回到图中，我们已经已知了初始值，那么我们如何求解到问号位置的值呢？<br><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.19.54.png" alt="Screenshot 2020-01-05 at 17.19.54" style="zoom:25%; "><br>我们发现到达？位置的路径总和就是等于到达？位置上方和左边的值相加。因为题目告诉我们只有两种移动方式。对应的方程就是 <code>res[i][j] = res[i - 1][j] + res[i][j - 1];</code></p></li></ul><h3 id="结果展示">结果展示</h3><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.26.00.png" alt="Screenshot 2020-01-05 at 17.26.00" style="zoom:50%; ">所以如果我们给出一个4*4的矩阵，那么一共存在20种走法从左上走到右下<h3 id="代码实现">代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">&#x2F;&#x2F;corner case</span><br><span class="line">if (m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line">if (m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1)</span><br><span class="line">return 1;</span><br><span class="line">&#x2F;&#x2F; init state </span><br><span class="line">int[][] res &#x3D; new int[m][n];</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">res[i][0] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">res[0][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; loop the matrix </span><br><span class="line">for (int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">for (int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">&#x2F;&#x2F; state change equation</span><br><span class="line">res[i][j] &#x3D; res[i - 1][j] + res[i][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是m<em>n, 空间复杂度也是m</em>n。 这里可以通过滚动数组将时间复杂度优化到n。</p><h3 id="follow-up">follow up</h3><p>为什么说动态规划是对递归的的一种优化，其实这个题，我们用深度优先搜索也可以做。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths2(int m, int n) &#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0 &amp;&amp; n&#x3D;&#x3D;0)</span><br><span class="line">        return 0;</span><br><span class="line">    return dfs(0,0,m,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int dfs(int i,int j,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&#x3D;&#x3D;m-1 &amp;&amp; j&#x3D;&#x3D;n-1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(i&gt;&#x3D;m || j&gt;&#x3D;n)</span><br><span class="line">        return 0;</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    sum+&#x3D;dfs(i,j+1,m,n)+dfs(i+1,j,m,n);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们会发现搜索是超过时间限制的，为什么因为搜索的时间复杂度是2^(m+n)。<br>因为搜索的数据结构就是二叉树，好比我们要想知道4<em>4矩阵的结果，就先把4</em>4拆分成对应的（3，4）与（4，3）相加，再将（3，4）拆分成（2，4）和（3，3）以此类推不停地拆分直到（0，0）的初始位置，然后我们发现这个过程中出现了很多重复的问题，并且每一个点都可以拆分成两个点。所以当m，n越大，起花费时间也越多。</p><h3 id="总结">总结</h3><p>动态规划和递归一直以来都是我算法的弱项，和平铺直叙的线性思维不同，递归和动态规划是通过对问题的拆分，很多时候是逆向思维。我发现此类问题都是代码量很小，但是需要想的很周全。之后，我会多通过练习来加深自己对其的认识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是动态规划&quot;&gt;什么是动态规划&lt;/h3&gt;
&lt;p&gt;在网上找到一个很形象的例子，猿爸爸把 1+1+1+1+1+1+1+1 = 写在纸上，问小猿（咦）：&lt;br&gt;
「它们加起来是多少哇？」&lt;/p&gt;
&lt;p&gt;（数了一会…）「8 ！」&lt;/p&gt;
&lt;p&gt;猿爸爸在左边又加了个 1+
      
    
    </summary>
    
    
      <category term="Algorithme" scheme="http://yoursite.com/categories/Algorithme/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="dynamic programming" scheme="http://yoursite.com/tags/dynamic-programming/"/>
    
      <category term="recursive" scheme="http://yoursite.com/tags/recursive/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2019/12/29/markdown/"/>
    <id>http://yoursite.com/2019/12/29/markdown/</id>
    <published>2019-12-29T22:30:28.000Z</published>
    <updated>2019-12-30T21:35:49.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅谈markdown语法">浅谈markdown语法</h2><p><strong>文章需要2分钟阅读 适用于每一个拥有电脑的你</strong><br>本期我将用最短的时间，向大家介绍一个码字的神奇，不用排版，只要记住几个symbol就能高效快捷的记录。</p><h4 id="介绍">介绍</h4><p>markdown 可能很多人听起来有点陌生，他就是类似于我们常使用的word或者wpf，是一种轻量级的标记语言。很多的网络作者，现代的编辑，还有程序猿背景的工作者大多数都青睐于此文本格式用于写作。向我们经常看到的论坛：简书，github，stackoverflow都是支持并推广markdown语法。</p><h4 id="起源">起源</h4><p>Markdown 由 John Gruber 在2004年创建，至今已经是12年的时间。关于Markdown最初的定义如下：</p><blockquote><p>a plain text formatting syntax<br>a software tool, written in Perl, that converts the plain text formatting to HTML</p></blockquote><p>指明markdown是一个纯文本语言，转化为html，html就是我们每天在各式各样网站上浏览看的文字图片对应的代码。</p><p>最初的设计理念：</p><blockquote><p>The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions.</p></blockquote><p>设计初衷就是markdown这种语法非常的简便易读，省去传统word大规模反锁的排版，而是然作者专注于内容的书写。</p><h4 id="常用的-markdown语法">常用的 markdown语法</h4><ul><li><p>标题</p><p><strong>语法</strong></p><img src="/2019/12/29/markdown/title.png" alt="title" style="zoom:50%; "><p><strong>效果</strong></p><img src="/2019/12/29/markdown/titleShow.png" alt="titleShow" style="zoom:50%; "></li><li><p>列表</p></li></ul><p><strong>语法</strong></p><img src="/2019/12/29/markdown/order.png" alt="order" style="zoom:50%; "><p>**效果 **</p><img src="/2019/12/29/markdown/orderShow.png" alt="orderShow" style="zoom:50%; "><ul><li><p>插入图片</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;MD.png&quot; alt&#x3D;&quot;MD&quot; style&#x3D;&quot;zoom:50%;&quot; &#x2F;&gt;</span><br><span class="line">or </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![MD](MD.png)</span><br></pre></td></tr></table></figure><pre><code>这里可以直接写绝对路径，但是大多数浏览器都是支持相对路径。如果不行的话肯定也有相应的插件支持。zoom代表图片的大小。使用topora这样的编译器可以直接拖拽图片到编辑区域。</code></pre><p><strong>效果</strong><br><img src="/2019/12/29/markdown/MD.png" alt="MD" style="zoom:50%; "></p><ul><li><p>链接</p><p><strong>语法</strong><br><code>`[baidu](https://www.baidu.com)`</code><br><strong>效果</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">baidu</a></p></li><li><p>引用</p><p><strong>语法</strong><br><img src="/2019/12/29/markdown/reference.png" alt="reference" style="zoom:50%;"></p></li></ul><p><strong>效果</strong></p><img src="/2019/12/29/markdown/Screenshot 2019-12-30 at 00.34.56.png" alt="Screenshot 2019-12-30 at 00.34.56" style="zoom:25%;"><ul><li>代码</li><li><ul><li><p>单行代码</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96; print(&quot;hello world&quot;);&#96;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><code>print(&quot;hello world&quot;);</code></p><ul><li><ul><li><p>代码块</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​```c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**效果**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>斜体 粗体</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜粗体***</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><em>斜体</em><br><strong>粗体</strong><br><em><strong>斜粗体</strong></em></p><ul><li><p>分隔符</p><p><strong>语法</strong><br><code>三个连续的+，*或者- </code><br><strong>效果</strong></p></li></ul><hr><ul><li><p>表格（不推荐）</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><h4 id="优缺点">优缺点</h4><h5 id="优点：">优点：</h5><p>说了这么多，markdown的优点我相信大家也都感受到了，比如</p><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开</li><li>让你专注于文字而不是排版</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等</li><li>Markdown 的标记语法有极好的可读性</li></ul><h5 id="缺点：">缺点：</h5><ul><li>没有完全统一的标准</li></ul><blockquote><p>这里可以说一则趣事，早些时候由tack Overflow 创始人和几个互联网巨头联合起来想制订一个统一的标准叫做Standard Markdown。结果这个事儿被创始人知道了，老爷子不开心，说你不能用standard这么官方的名字，因为我就没想让它统一。后来这个计划更名为Common Markdown。</p></blockquote><ul><li><p>作为一个中间语言，没有html丰富的功能</p><blockquote><p>html全称hypertext markup language，是一种超文本标记语言，他集成了很多的功能，是markdown语法所不具备的。比如其上传视频，改变布局… …</p></blockquote></li><li><p>对于一定的格式写法有些复杂</p></li></ul><blockquote><p>相信所有熟悉markdown写法的人都知道，markdown语法更改字体颜色，剧中右对齐是做不到的，需要插入html代码，虽然说排版已经违背了设计的初衷，但我们也不能一点都不修边幅。还有就是markdown始终对于插入表格是个硬伤，始终要注意index对其。</p></blockquote><h4 id="markdown-编译器">markdown 编译器</h4><p>如果你看了我的文章想尝试一下mardown语言，我在这里为大家列出一些当前比较流行的mardown编译器。</p><ul><li>typora  (良心安利，免费好用，实时预览，macos/window兼容)</li><li>Mou （功能强大，插件很多，<strong>但是收费</strong>）</li><li>印象笔记 （不错的选择，手机电脑可以通过云来同步）</li><li>sublime （书写方便，快捷，但是不能预览）</li><li>visualstudio （同理sublime）</li></ul><h4 id="总结">总结</h4><p>一个技术的存在可以达到hot or popular一定是有其的道理。markdown语言我认为非常适合写技术博客，经常码字追求流畅的文字工作者，<strong>如果一个东西能够大幅度的提升我们的工作效率，那么我们为什么不用它</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅谈markdown语法&quot;&gt;浅谈markdown语法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;文章需要2分钟阅读 适用于每一个拥有电脑的你&lt;/strong&gt;&lt;br&gt;
本期我将用最短的时间，向大家介绍一个码字的神奇，不用排版，只要记住几个symbol就能高效快捷的记录。&lt;/
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="writing skill" scheme="http://yoursite.com/tags/writing-skill/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="http://yoursite.com/2019/12/28/LRU/"/>
    <id>http://yoursite.com/2019/12/28/LRU/</id>
    <published>2019-12-28T19:54:40.000Z</published>
    <updated>2019-12-29T20:37:31.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LRU-Least-Recently-Used-页面置换算法">LRU(Least Recently Used) 页面置换算法</h2><p>本篇文章阅读时间 5 分钟， 技术实现 java， javascript。</p><h4 id="概述">概述</h4><p>这一周本来是想将Mario（马里奥）做完，但是周三晚上下班看了一眼React，于是一发不可收拾，之前是听同学，朋友，同事说react的香，一直没有感觉到，真是自己从头学了一下才感受到他火确实是有道理。因为自己的学习笔记还没有整理完，mario的进度推迟了。正巧在自己做网站的时候，看到react-router里面有一个封装好的内置类history，自己在写的时候遇到了浏览记录的问题。正巧室友说在国内面试时被问到这个问题。这期，临时决定写一写这个LRU页面置换算法。</p><h4 id="算法缘由">算法缘由</h4><p>第一次听到这个页面置换算法应该是大三的操作系统课，但是当时也就是考试复习随便瞟一眼，也没仔细看。字如其名，其本质就是选择调出用户想要的页面，好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。这是官方给出的解释，白话说，假如浏览器只能同时加载显示三个页面，那么我们应该通过一种最合理的方式显示出我们最常用的三个，而将不常用的替换掉。常见的置换算法像是OPT，FIFO，CLOCK，LRU。我自己认为LRU是最贴近现实生活，同时也是最常考到。</p><h4 id="例题展示">例题展示</h4><p>为了更好的讲述这个题，我就从leetcode上面直接拔下来一个题。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.24.22.png" alt="Screenshot 2019-12-22 at 21.24.22" style="zoom:25%; "><p>题目说的什么意思呢，就是让我们自己通过数据结构设计一个类并指定缓存的最大存储量，类表示的就是我们浏览器的缓存，类里面有两个方法，分别为get和put。get的意思就是，如果此时缓存记录里有我要找的东西，那么直接返回结果。没有就输出一个-1。put的意思就是，每次我们访问一个新的网页，将这个网页放入到我们的缓存中，如果该网页已经存在于缓存中，则对其内容进行替换。若不存在，加入到缓存中。</p><p>他这里有一个follow up：问我们怎么能够用常数的时间复杂度完成所有的操作。（就是优的解决方案）</p><h4 id="分析：">分析：</h4><p>首先读完这个题目，并结合我们的我们的生活常识，很快，我就想到根据我们需要用一个固定长度的数据结构去存储用户的访问记录。然后再看到put方法key，value键值对，我想到了hashtable。我们可以用hashtable的key设置为数字，代表用户的浏览记录标示；value作为内容。并且hashtable的查找时间复杂度为O（1）。再之后，我们会发现这个题单纯一个hashmap数据结构还不能满足我们的所有需求，比如从技术层面出发，我们知道hashmap的添加和删除操作都是o（logn）的时间复杂度。应用层面上，单纯只用hashmap，我们怎么做到对内容的更新与调度。于是，在这里我们可以在引入一个双向节点，这里有很多做法比如用deque，linkedlist。我是从题目本身出发，自己写了一个Node类，他有四个属性，分别是prev（前一个节点），next（下一个节点），key（页面表示），value（内容）。这样设计的好处就是，我们在执行添加和删除的操作时，只需要改变指针的方向不需要便利整个list到达了最优的时间复杂度。</p><p>这里，可能文字还是有些拗口，尤其是针对分计算机专业的童鞋们，我付上一个图片更能清晰直观的描述设计思路，以及运行过程。</p><p><strong>模型</strong></p><table><thead><tr><th><strong>Hash table - capacity</strong>**（<strong><strong>2</strong></strong>）****- head(0, 0)**</th></tr></thead><tbody><tr><td>Node 1 key = 1, value = 1, prev = head, next = Node2</td></tr><tr><td>Node 2 key = 1, value = 1, prev = Node1, next = tail</td></tr></tbody></table><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.45.19.png" alt="Screenshot 2019-12-22 at 21.45.19" style="zoom:25%; "><p>假设我们模拟执行 例题中给的几步</p><h5 id="Step-1-LRUCache-cache-new-LRUCache-2-cache-put-1-1">Step 1 : LRUCache cache = new LRUCache(2); cache.put(1, 1);</h5><p>首先我们初始化了一个缓存对象，并设置他的最大容量为2。</p><p>此时我们将第一个元素放进来。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.27.png" alt="Screenshot 2019-12-29 at 00.26.27" style="zoom:25%; "><h5 id="Step2-cache-put-2-2">Step2 : cache.put(2, 2);</h5><p>检测是否超过最大容量。再将第二元素放到队伍头节点</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.30.png" alt="Screenshot 2019-12-29 at 00.26.30" style="zoom:25%; "><h5 id="Step3-cache-get-1">Step3 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。发现有则返回value。并交换节点（2，2）和（1，1）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.34.png" alt="Screenshot 2019-12-29 at 00.26.34" style="zoom:25%; "><h5 id="Step4-cache-put-3-3">Step4 : cache.put(3, 3);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（2，2）删除，再把新的节点（3，3）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.38.png" alt="Screenshot 2019-12-29 at 00.26.38" style="zoom:25%; "><h5 id="Step5-cache-get-2">Step5 : cache.get(2);</h5><p>检测缓存中是否有id为2的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.41.png" alt="Screenshot 2019-12-29 at 00.26.41" style="zoom:25%; "><h5 id="Step6-cache-put-4-4">Step6 : cache.put(4, 4);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（1，1）删除，再把新的节点（4，4）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.44.png" alt="Screenshot 2019-12-29 at 00.26.44" style="zoom:25%; "><h5 id="Step7-cache-get-1">Step7 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.48.png" alt="Screenshot 2019-12-29 at 00.26.48" style="zoom:25%; "><h5 id="Step8-cache-get-3">Step8 :cache.get(3);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.52.png" alt="Screenshot 2019-12-29 at 00.26.52" style="zoom:25%; "><h5 id="Step9-cache-get-4">Step9 : cache.get(4);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value。并交换节点（4，4）和（3，3）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.55.png" alt="Screenshot 2019-12-29 at 00.26.55" style="zoom:25%; "><h4 id="代码实现">代码实现</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.04.26.png" alt="Screenshot 2019-12-22 at 22.04.26" style="zoom:25%; "><p>为了方便编程，避免空指针，便于调试。我自己设置了一个头节点和尾节点。在LRU里面自定义一个内部节点类。LRU的结构为hashmap套node。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.07.26.png" alt="Screenshot 2019-12-22 at 22.07.26" style="zoom:25%; "><p>添加到头部，因为是双向所以需要改变两次。这里要插入头部，所以先保存一下原有的头节点，再让原有的头节点与新添加节点做操作。1 新添加节点的下一个指向原有头节点。2 head的下一个指向新添加节点。3 原有头节点的上一个指向新添加节点。 4新添加节点的上一个指向head。 建议大家在做指针指向问题的时候画草图，并且想改变好一个方向再去改变另外的方向。</p><p>删除，也是把前一个节点的下一个节点指向要删除节点的下一个。再把删除节点下一个的前一个指向删除节点的前一个。<img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.15.39.png" alt="Screenshot 2019-12-22 at 22.15.39" style="zoom:25%; "></p><p>get 操作：检测hashmap是否含有key值。若存在，取出node节点，删除原有的node节点，再从新插入到头部。返回value。没有直接返回-1。</p><p>put操作 ：检测hashmap是否含有key值，若存在，取出node节点。取出node节点，删除原有的node节点，再从新插入到头部。若没有，先判断，hashmap是否达到自己的最大容量，若达到，删除队尾节点，在将新节点插入头部。如没达到容量直接插入。</p><h4 id="测试结果">测试结果</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.03.57.png" alt="Screenshot 2019-12-22 at 22.03.57" style="zoom:25%; "><h4 id="源码仓库：">源码仓库：</h4><p><a href="https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem" target="_blank" rel="noopener">https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem</a></p><h4 id="总结">总结</h4><p><strong>LRU</strong>最近最久未使用页面置换算法，无论是在面试中作为一个程序设计题的高频出现，还是其cache思想贴近实际生活都是我认为很重要的一个点。希望自己的见解都初学者有帮助，对非it领域算是一个扩展知识的文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LRU-Least-Recently-Used-页面置换算法&quot;&gt;LRU(Least Recently Used) 页面置换算法&lt;/h2&gt;
&lt;p&gt;本篇文章阅读时间 5 分钟， 技术实现 java， javascript。&lt;/p&gt;
&lt;h4 id=&quot;概述&quot;&gt;概述&lt;/h4
      
    
    </summary>
    
    
      <category term="Algorithme" scheme="http://yoursite.com/categories/Algorithme/"/>
    
    
      <category term="page replacement" scheme="http://yoursite.com/tags/page-replacement/"/>
    
      <category term="lru" scheme="http://yoursite.com/tags/lru/"/>
    
  </entry>
  
  <entry>
    <title>tetris</title>
    <link href="http://yoursite.com/2019/12/28/tetris/"/>
    <id>http://yoursite.com/2019/12/28/tetris/</id>
    <published>2019-12-28T19:54:27.000Z</published>
    <updated>2019-12-29T20:38:03.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="俄罗斯方块Tetris">俄罗斯方块Tetris</h2><h4 id="背景回顾">背景回顾:</h4><p>我觉俄罗斯方块在游戏领域的地位，有点像乔丹打篮球。为什么这么说，EA对过去30年的游戏评点，俄罗斯方块这样一个仅在当时老毛子开发出来做检测效率的东西，列在榜单首位。在那个遥远寒冷的西伯利亚，俄罗斯工程师发布这个名为Tetris后，在那个人口还没有爆炸增长，电脑还没普及的时候，先后有5亿人对此游戏下载。甚至毫不夸张的说，很多人第一次听到俄罗斯就是通过俄罗斯方块这个小游戏。时至今日，俄罗斯方块早已下架，但是以任然保持着9项吉尼斯世界纪录，同样也在影视，医疗领域做出了不小的贡献。</p><h4 id="程序界面设计-：">程序界面设计 ：</h4><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.31.12.png" alt="Screenshot 2019-12-25 at 17.31.12" style="zoom:25%; "><h4 id="程序开发设计：">程序开发设计：</h4><h5 id="创建主题窗口，设置游戏界面，画边框">创建主题窗口，设置游戏界面，画边框</h5><p>同其他类型小游戏一样，我们第一步要做的就是创建一个frame设置其大小，是否可见，相对位置。然后在主体frame中插入一个jpanel，实现游戏的所有逻辑细节。可能对于不同的游戏项目，我们可能需要上网找资源，但是俄罗斯方块我们可以直接用java自带的graphic包里面的drawRect方法来绘制正方体就足矣。因为之前已经写过如何设置推算调试窗体大小，这里就不过多赘述。</p><p>我设置每个小方框的边长为20pxl，主题窗口的宽为400pxl，高度为500pxl。游戏界面，容器的高度为21行，宽度为12行。其中第一列和最后一列还有最后一行是墙壁。唯一一点需要考虑的是用什么去存出游戏的地图，这里我看网上有的人有list，map，我更倾向于2位数组。原因很简单，长度固定，数组的访问修改快，通过一些边界条件，程序效率也高。因此在我的程序里，二维数组第一位代表列，就是对应二维坐标系的x；第二维代表行，就是二维坐标系的y。准备工作都做好后，我们初始化地图，设置边框。</p><p>来看一下第一步结束的效果图：</p><img src="/2019/12/28/tetris/Step1.png" alt="Step1" style="zoom:25%; "><h5 id="方块的绘制">方块的绘制:</h5><p>俄罗斯方块从字面意义上我们就知道方块是这游戏的操作的主体，所以我认为这一步也是整个游戏开发中最重要的环节。首先我们需要确定游戏中有多少种基本形状，这个我就上网google了一下。随后我们要确定用什么样的数据结构去存储和表示方块的形状。因为我们知道方块是可以旋转的；每次旋转完之后形状由于方向的改变，所以图形也变化。</p><p>这里我们首先先列出俄罗斯方块的7本基本形状，然后再去进行下一步的detail：</p><p>I字形</p><img src="/2019/12/28/tetris/shapei.png" alt="shapei" style="zoom:25%; "><p>田字形</p><img src="/2019/12/28/tetris/shapeSquare.png" alt="shapeSquare" style="zoom:25%; "><p>Z字形</p><img src="/2019/12/28/tetris/shapeZ.png" alt="shapeZ" style="zoom:25%; "><p>S字形</p><img src="/2019/12/28/tetris/shapes.png" alt="shapes" style="zoom:25%; "><p>T字形</p><img src="/2019/12/28/tetris/shapeT.png" alt="shapeT" style="zoom:25%; "><p>L字形<br><img src="/2019/12/28/tetris/shapeL.png" alt="shapeL" style="zoom:25%; "></p><p>J字形</p><img src="/2019/12/28/tetris/shapeJ.png" alt="shapeJ" style="zoom:25%; "><p>从图片中我们就可以观察到，I形状的长或宽等于四，是这里最长的。所以我们的目的是用一个数据结构表示所有的图形，因此我想到可以使用4<em>4的一个二维数组。0表示空闲，1表示填充，如果把二维数组平铺下来就是一个长度为16的一维数组。然后我们就要考虑到方块的旋转引起形状的变化，所以我们还需要分析，每个形状经过旋转好最多能产生几种不同的形状。举个例子，比如田字形无论怎么旋转都是同样的形状，但是L或者J字形就可以产生4种不同的状态，因此我们可以用4</em>16的数组代表每个图形的所有变化。</p><h5 id="举例-L">举例 L</h5><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.48.27.png" alt="Screenshot 2019-12-25 at 17.48.27" style="zoom:25%; "><p>而一种方块的所有变形体的信息可以用二维数组来存储，依旧拿L形方块举例，它的所有形态可以存储为</p><p>{</p><p>{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }</p><p>},</p><p>由于二维数组只能存储一种方块的所有变形体信息，故要存储七种方块的所有变体信息则要使用三维数组来进行存储。</p><h4 id="3方块-初始化-左右移动-旋转-下落-：">3方块 初始化-&gt;左右移动-&gt;旋转-&gt;下落 ：</h4><p>一提到移动，可以说完变不离其宗，对于java来讲就两个大方向thread或者timer，通过图形坐标的改变，其定时的刷新来重新绘制panel。可能两者存在细微差别，但是对我来讲可能就像是方法改个名字比如thread要重写runner方法。而timer是重写actionlistener。（这两个东西很重要，可能简单的也说不清楚，因为他不是文章的主题，我们就跳过了）。之前的falppy bird和小恐龙跳跃我都用的是thread。这一次俄罗斯方块我就使用timer方法。</p><p>我们的要在这一步实现的功能是方块自然下落，左右可以移动，并且下落过程中可以旋转。那么一步一步来，第一步方块的初始化。</p><h5 id="1-create-rectangle">1 create rectangle</h5><p>这里我先设置一个固定的x，y坐标代表每次当一个方块落地后，下一个方块就会从这里重新出现一个新的，我默认的是左上角就是x=1, y=0。然后设置2个随机数，取值范围为1-7和1-4，分别对应哪一个图形，和图形具体的哪一种状态。</p><h5 id="2-左右移动">2 左右移动</h5><p>因为这里用户可以通过键盘的左右键来操作图形的移动。每当表示每种行为状态的变化时，我们就要引入事件的监听。左右移动顾名思义就是在y轴坐标不变的条件下，移动x。向右移动x变大，向左移动x减小。最后再重新绘制图片。但是这里有我们需要写一个函数，来判断图形是否还可以继续移动，当图形向右移动到最右边触碰到墙壁的时候此时就不能再向右移动，反之亦然。因此我们可以用两个for循环对图像的每个点遍历，当有一个点碰到墙壁则返回false。</p><h5 id="3-旋转">3 旋转</h5><p>就是改变图形的状态，在已知图形的种类和初始状态的条件下，每点击一次按钮就旋转90度。这里我们还需要判定是否可以旋转，当图形已经碰到了另外的图形，则此时不能在放生状态改变。就是我们在绘制地图时，默认0为空，1为已填充图形，2为墙壁。同样还是对当前图形状态的每一个点做遍历，若图形已经碰到最底部的墙壁或者两个图形出现相重叠部分，那么也不能旋转。这两个条件，我也是借鉴了网上的代码。</p><h5 id="4-下落">4 下落</h5><p>默认如何图形可以移动，那么每次timer重新刷新界面y坐标就会自动加1。如何碰到地面或者两个图形重叠，那么下落停止。</p><h4 id="5-重绘界面-设置分数">5 重绘界面 设置分数</h4><p>首先我们设定一个全局变量反应当前游戏得分，每消除一行则加10分。我们设定timer线程每隔一段时间重新绘制界面，每次当一个方块落地后无法移动时。我们会将其加入到map地图中，就是对图形的x，y坐标对应到map中，将原来是0的地方填充为1。然后我们还需要检查是否出现方块填满一整行的情况。这里就是对map进行遍历，两层循环，外层遍历行（从最后一行开始），里层循环遍历列（从第一列开始），设置一个变量来记录每一行已填充的方块数量，如果填充的方块数量刚好等于，游戏容器的宽度减2（墙壁）。于是我们将此行上面的所有行向下移动一行。</p><p>做到这一步：我们游戏就已经见成效了，在这里做一个小的演示：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 18.44.12.png" alt="Screenshot 2019-12-25 at 18.44.12" style="zoom:25%; "><h4 id="6-完善游戏体验与调试">6 完善游戏体验与调试</h4><p>其实每次最后一步就对游戏进行一个简单的测试，检查是否出现bug。完善一些小功能，修改一下UI设计。</p><h5 id="游戏结束-分数记录-暂定-重新开始-下一个图形">游戏结束 分数记录 暂定 重新开始 下一个图形</h5><p>游戏结束条件就是我们的方块累计到达了顶部，这个我我们可以写一个方法，判断在最顶上一行是否出现填充的方块，如出现，游戏结束。然后我们需要对比当前得分与游戏最高得分做对比，若当前得分高于最高得分，则更新。</p><p>游戏重新开始，就是将分数清0，然后重新绘制地图，墙壁，初始化方块。</p><p>游戏暂停与继续，对timer线程调用api，start/stop。这里我们用JMenu做了一个分级菜单，菜单里我们可以退出，暂定，继续游戏。别切阅读游戏玩法提示。</p><p>下一个图形，这个玩过俄罗斯方块的都知道每当一个图形初始化后，右侧界面都会出现的下一次图形的提示。这里我们就是新建两个随机数，分别代表图形种类和状态。然后在每次每次初始化新图形，重新绘制面板时，在界面右侧绘制下一次将要出现的图形。</p><p>最后给大家看一个完整版的效果图：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-29 at 00.11.28.png" alt="Screenshot 2019-12-29 at 00.11.28" style="zoom:25%; "><h4 id="建议阅读时间-8分钟，-程序实现-java，-源代码">建议阅读时间 8分钟， 程序实现 java， 源代码:</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris</a></p><h4 id="总结：">总结：</h4><p>大概用了7个小时去进行程序整体设计，编程实现，调试，代码优化。然后4个小时去写文档。基本上完成俄罗斯方块的复刻，当然，还有细节做的不够好，比如背景音乐，方块颜色……</p><p>最后想说一说最近编程的一些感想，编程可能语言在不停的变，但是面向对象的思想没变，数据结构没变。我觉学习一门技术最重要的不是看概念，而是不停的实践，理论基础是在实践中总结出来才能记得更牢固。任何一个框架，技术都有自己的套路，当我们熟悉它之后，学会用计算机的思维方式去思考的时候，那么我们才能做到学以致用。（说远了，我也是差的还很远）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;俄罗斯方块Tetris&quot;&gt;俄罗斯方块Tetris&lt;/h2&gt;
&lt;h4 id=&quot;背景回顾&quot;&gt;背景回顾:&lt;/h4&gt;
&lt;p&gt;我觉俄罗斯方块在游戏领域的地位，有点像乔丹打篮球。为什么这么说，EA对过去30年的游戏评点，俄罗斯方块这样一个仅在当时老毛子开发出来做检测效率的东西
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="jframe" scheme="http://yoursite.com/tags/jframe/"/>
    
      <category term="game" scheme="http://yoursite.com/tags/game/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>flappy bird</title>
    <link href="http://yoursite.com/2019/12/28/flappy-bird/"/>
    <id>http://yoursite.com/2019/12/28/flappy-bird/</id>
    <published>2019-12-28T19:54:17.000Z</published>
    <updated>2019-12-29T20:38:35.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flappy-Bird-仿写">Flappy Bird 仿写</h2><p>通过之前做贪吃蛇和小恐龙跳跃，对jframe，swing和awt的基础已经回顾的差不多了，因此这篇文章就不再一一赘述我已经写过的细节。讲讲大体上实现思路，设计模式还有哪些点需要注意。惯例，还是把所有素材和源码放到github上。</p><p>Flappy bird这个游戏是2014年一个在美国工作的越南裔移动端游戏工程师（Dong Nguyen ）开发的，然后在apple商店推出后就瞬间爆火，然后其自己突然让游戏下架。我在youtube上看了一些视频，据说此事与dark net相关（也不知真的假的）。后来，过来一段时间，他又从新上架这这款游戏，可是已经没有了当时的人气。因为我也认识当事人，也不知道事情的来龙去脉，所以今天我只是从技术的角度去复习这款游戏。</p><h4 id="技术选用与涉及技术：">技术选用与涉及技术：</h4><p>java8， eclipse IDE, jframe，awt，swing，thread</p><h4 id="思路">思路:</h4><p>由于我从事的领域并不是游戏开发，这只能算是我的爱好也是对技术的温故知新，所以我只是讲讲我对其的认识。我发现市场很多游戏都是单页面应用，我所指的单页面就是玩家对于操作对象始终停留在一个窗口中，我们通过不停的变化背景，生成障碍物去让游戏继续。对于这些单页面的应用，我通常的实现步骤就是先创建一个叫app的class，此类包含main函数，就是程序的入口，在这里面预设一个固定大小的主窗口初始化，加入监听器，然后再新建一个gamepanel类，所有的逻辑都会在这个类中完成。并将此类在app中事例化。然后分别对此程序中涉及到的所有对象创建class，比如小鸟（bird），管道（pipe），线程（thread），游戏本身所有的规则（game）。我本人的开发习惯是喜欢单独建一个辅助类（helper），存放所有的辅助函数，比如想图片的读取，声音的播放之类的。这些大概的轮廓搞好后，然后我们开始写程序。</p><h4 id="1寻找素材-调整合适大小">1寻找素材 调整合适大小</h4><p>这里我听取网友的建议然后进行过测试</p><p>小鸟3张 翅膀平行，下落，上升  管道2张（朝上和朝下） 背景图片一站 陆地一张</p><p>小鸟尺寸为 45 * 32 pixel</p><p>管道为为 66*400 pixel</p><p>大地和背景都为 500*500 pixel</p><h4 id="2-绘制背景，管道-，小鸟">2 绘制背景，管道 ，小鸟</h4><p>首先绘制背景，分别加载两张背景图片，注意顺序，当图片累加时会有重叠的问题。</p><p>然后是小鸟，给小鸟一个初始化的位置，作为游戏的起点。最后是管道。管道分为朝上和朝下，管道的宽度是固定的，也是给定一个初始值。</p><p>完成这一步，效果就是大概这样的：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 01.23.53.png" alt="Screenshot 2019-12-15 at 01.23.53" style="zoom:25%; "><h4 id="3-让小鸟跳跃-移动-挥舞翅膀">3 让小鸟跳跃 移动 挥舞翅膀</h4><h5 id="Step1-小鸟移动">Step1 小鸟移动</h5><p>实现这个功能，我需要预设一个jump为小鸟的单次上升高度。还有一个gravity引力系数，常识由于有地心引力的存在下降速度总是比上升速度快，我预设一个0.5，就是在我这个游戏中下降速度是上升速度的两倍。这里还有一点需要注意就是按键，如果按了空格键，小鸟位置上升，不按空格键，小鸟则直接下降，通过不停的点击空格键是可以让小鸟的高度累加。为了更贴近现实，我加入了一个图片旋转的功能，就是上升时，小鸟的头部会向上倾斜，反之亦然。此时我们可以通过awt的内置类affinetransform对图片进行一定幅度的旋转。</p><h5 id="Step2-小鸟跳跃">Step2 小鸟跳跃</h5><p>与小恐龙制作相差无几，我们可以让背景以一定的速度从右向左移动就可以达到一种小鸟在移动的感觉。此时我们需要用到线程，每隔一定的时间，重新绘制背景。我预设一个25ms，每25ms线程就会更新一次小鸟以及背景的位置。然后对键盘键监听，按空格键则小鸟位置上升，松开空格键则位置下落。</p><h5 id="Step3-挥舞翅膀">Step3 挥舞翅膀</h5><p>找到三张不同的图片是小鸟翅膀的位置分别在上中下，然后每隔25ms，单线程调用时累加游戏时间除以100再对3取余数，就达到了每100ms小鸟的翅膀就移动一次位置。</p><h4 id="4-管道的出现-移动">4 管道的出现 移动</h4><p>因为我们每隔25ms线程会去重新刷新界面，所以我们给定管道一个初始速度3。每25ms，管道向左移动3pixel。然后取一个在50-200之间取一个随机值，代表在接下来的50-200pixel会出现下一个管道。对于管道的y坐标，需要多考虑一点，因为小鸟的高度是32pixel，然后管道的高度是400pixel所以管道只是在界面中显示一段，我对于游戏的设计就是朝上的管道和朝下的管道总是成对出现，然后为了保证小鸟可以顺利通过管道，我给两个管道中间预留了50-120的pixel，然后再去推理出朝上和朝下管道具体的y轴值。</p><p>完成这一步，游戏也就实现了60%，效果如下：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.02.16.png" alt="img" style="zoom:25%; "><h4 id="5-碰撞检测">5 碰撞检测</h4><p>首先先新建一个arraylist用于存放出现的管道。奇数代表朝下，偶数朝上。用一个i记录当前管道。与小恐龙撞仙人掌相同，如何判定小鸟是否可以通过管道，我们需要对小鸟进行碰撞检测。每一组碰撞检测可以分为四个方面，我用两张图片向大家更好的讲解。</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.03.46.png" alt="Screenshot 2019-12-15 at 02.03.46" style="zoom:25%; "><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-28 at 23.54.44.png" alt="Screenshot 2019-12-28 at 23.54.44" style="zoom:25%; "><p>我们取到小鸟的头部检测小鸟有没有碰到管道的两个前沿，以及小鸟分过管道后是否碰到管道的后沿。当然是存在一定可能小鸟会碰到管道的中间，但在我这个游戏中，我已经计算过，线程25ms刷新一次，如果小鸟在进入管道前没有撞到管道，小鸟在跳跃或者下降，因为宽度固定，所以小鸟已经走到管道外。因此我只需要检测管道的头和尾。与小鸟的头和尾即可。</p><p>当然，我们还需要检测小鸟的位置使其置于大地和天空之间，如果超出范围也是碰撞。</p><h4 id="6-游戏暂停-结束-重新开始">6 游戏暂停 结束 重新开始</h4><p>暂停：设置一个全局变量pause，初始值为false。点击p时则pause变为true，此时游戏暂停。在界面中写出提示语，点击p键继续游戏。我们需要暂时让线程停止工作，从而使画面不刷新。</p><p>结束：设置一个全局变量death，初始值为false。当小鸟碰到大地，天空，管道时，death为true。在界面给出提示语，游戏结束，点击R键从新开始游戏</p><p>重新开始 ： 从新初始化小鸟的位置，分数，清空管道的list。</p><h4 id="7-分数统计-记录">7 分数统计 记录</h4><p>在主窗体底下设置一个长矩形，分别代表当前得分和记录，没通过一对管道增加1分，当游戏结束时，比较当前得分与最高得分。若当前得分高则更新记录。</p><p>最后呈现一下最终效果：</p><h4 id="源代码：">源代码：</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird</a></p><h4 id="总结：">总结：</h4><p>通过此次的flappy bird的开发，相比于前两次无论是开发时间，思路，完成度从自己的角度出发都有了一定程度的提升。同时也学到了一些新的写法和awt的用法，比如图片旋转；把游戏逻辑单写成一个类来封装；对于按键监听的press，release双操作。下一次，我想复写一下马里奥（mario），以此结束Jframe这个模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flappy-Bird-仿写&quot;&gt;Flappy Bird 仿写&lt;/h2&gt;
&lt;p&gt;通过之前做贪吃蛇和小恐龙跳跃，对jframe，swing和awt的基础已经回顾的差不多了，因此这篇文章就不再一一赘述我已经写过的细节。讲讲大体上实现思路，设计模式还有哪些点需要注意。惯例
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="jframe" scheme="http://yoursite.com/tags/jframe/"/>
    
      <category term="game" scheme="http://yoursite.com/tags/game/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>trex up</title>
    <link href="http://yoursite.com/2019/12/28/trex-up/"/>
    <id>http://yoursite.com/2019/12/28/trex-up/</id>
    <published>2019-12-28T19:54:06.000Z</published>
    <updated>2019-12-29T20:40:36.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前情回顾：">前情回顾：</h4><p>不知道从那一年开始，这个不重要。 google 设计师在每次chrome断网时加入了一个彩蛋，此时此刻，将会出现一只萌萌的短腿霸王龙（Trex）开始原地踏步，然后点击space此时小恐龙向上蹦一下。然后接连出现仙人掌和小鸟，在我们灵力的操作下霸王龙躲避一个个障碍。隔一段时间，背景变为黑色，随着跨过障碍物越多，分数越高。</p><p>这个游戏操作简单，玩起来简单快捷。同时缓解了我们在断网时候的焦急，可以说这只萌萌的霸王龙可谓成为了网络萌宠，流量大咖。这篇文章我们来聊聊从0实现这个小恐龙，别小瞧这一个简单的游戏，在其背后google工程师也是写几千行的js代码, 其背后的逻辑以及设计确实有很多为人称赞之处。在看过源码之后，我用java还实现这个高仿版的小恐龙跳一跳，也是参考 学习google的思路。</p><p>此文章我通过以下六部分来具体讲述，可以说这个简单的小游戏结合了UI，窗口，监听器，面向对象非常适合我们用来练习。</p><h4 id="1背景绘制">1背景绘制</h4><p>首先我们需要明确窗口的概念，JFrame&gt;JPanel&gt;ContentPanel。因此我们从网上找到资源（大家可以直接上我github上下载，链接在文章底部），然后通过设置JFrame的setbounds内置方法来设定窗口的大小。这块有两点需要注意，首先如何更改查看图片的大小，我用的是Mac，通过预览可以直接查看，并且调整图片的大小。</p><p>这里我就不多赘述，我自己测试过很多次之后，在宽734高286pixel是可以达到不错的小显示效果。第二点，setbounds这个函数有四个参数，X，Y，width，height。宽和高就是图片的宽和高，X，Y和我们现实生活的坐标系有一点差别，屏幕的左上顶点就是（0，0）的位置，这个刚开始可能不大适应，写多了就习惯了。然后把屏幕放在剧中的的位置，设置可见，标题。这些都是由内置的函数，可以直接调用，最后给大家看一下效果。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><h4 id="2-绘制小恐龙-踏步-跳跃">2 绘制小恐龙 踏步 跳跃</h4><h5 id="第一步-绘制静态小恐龙">第一步 绘制静态小恐龙</h5><p>和绘制地面背景一样，先找到一个小恐龙的图片，然后根据我们的背景调整小恐龙的大小。然后我们需要调整恐龙的坐标，将其放在陆地上。这些坐标问题感觉让我们一下回到了中学，推敲一个个坐标的位置。然而实际的游戏的开发是有游戏引擎的，所以可以简化位置的摆放，java本身的设计也不是用来写游戏，据我所知游戏还是多用c++的开发，现在可能随着unity的不断更新，cSharp也是不错的选择。我没有引擎，我就通过在本地的画图推算，测试坐标。</p><p>然后我们看一下效果, 这里因为背景图片width 734pixel，height 286pixel。我设定的小恐龙位置在（50，200）x, y分别指的是距离左上定点的像素。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 15.19.14.png" alt="Screenshot 2019-12-08 at 15.19.14" style="zoom:25%; "><h5 id="第二部-如何原地踏步">第二部 如何原地踏步</h5><p>这里就要引入一个图片与视频的概念。其实我们平时所看到的视频，是由一个一个图片快速更替而成。比如常见的24帧，指的是一秒钟扫过24张图片此时我们就感觉图片在动，就是我们平日所看到的视频。所以如何让小恐龙给大家一种原地踏步的感觉，大概思路就是找到两张图片，一张图片左脚着地，另一张图片右脚着地，然后这两张图片不停的交替。所以要实现这个功能我们需要引入一个单独的线程，其实和贪吃蛇差不多，我们需要小恐龙线程每隔10ms就去重新绘制次图片。然后我预设每100ms短腿小恐龙换一次着地腿。每次增加10ms，每次执行时对2取余数，为0则选用左脚着地图片，反之亦然。</p><h5 id="第三步-按下space键-小恐龙跳跃">第三步 按下space键 小恐龙跳跃</h5><p>这里引入一个按键监听器，当我们键盘点击space时，我们将小恐龙设置为跳跃状态，并更换一张新的图片，其实跳跃就是改变小恐龙的y坐标，我也是经过测试后，设置短腿霸王龙的跳跃高度为100像素。这里有一点特别需要注意，小恐龙跳跃一次后需要落地才能进行，下一次跳跃。因此我们设置一个值，每次跳跃了则y坐标变化，让其与地面坐标对比，如果小于等于则说明小恐龙在空中则无法再跳跃，返回地面。如果在地面上则可以再次跳跃。</p><h5 id="3-小恐龙移动">3 小恐龙移动</h5><p>这是一个很关键的一步，实现不难，关键是思想的转化，在我们的认知中我们认为是小恐龙在动通过跳跃躲避障碍。因此我打开了google的trex up做了一个实验，我把鼠标放在小恐龙头上，从始至终小恐龙一直与我的鼠标的y轴成一条垂直地面的直线。这说明小恐龙没有动，那么谁动了呢？答案就是图片在不停的从右向左以一定的速度在变化。</p><p>然而怎么能够实现这个呢，我在这里画一个图片（有点简陋，不要见怪）</p><img src="/2019/12/28/trex-up/pictureloop.png" alt="pictureloop" style="zoom:25%; "><p>如图所示，我们找到两张大小尺寸背景一模一样的图片，然后分别让两个图片的x坐标连接在一起，并且让两张图片一样的速度从右向左移动，当图片2到达x坐标为0时，图片1到达-734，然后我我们再把图片一放到图片二的后面。以此类推，循环往复，我们让背景动，小恐龙在原地。于是就给我们一种小恐龙动起来的感觉。</p><p>然后同样的道理，我们可以设置云彩，月亮，白天黑夜。（这里就不详细说了，感兴趣的小伙伴可以私信我）</p><h5 id="4-障碍物设置">4 障碍物设置</h5><p>现在小恐龙可以动可以跳，可以动，背景可以交替，现在我们就要设置障碍物。首先还是一样找资源，就是找图片。google trex up用到的障碍物是仙人掌和小鸟，我也就去找了仙人掌和小鸟。其中仙人掌有稍高一点的稍矮一点的，三个在一起的单独的。小鸟出现的位置是在大地和天空之间，有一定的飞行速度。然后找到资源后，我们需要对仙人掌进行摆放的测试，或者简单来讲我们可以把仙人掌直接设置为与小恐龙的y坐标相同。小鸟的y坐标我们可以生成一个随机数在大地和天空之间。</p><p>这里有一个关键的问题移动，我自己在开放的时候，看了很久为什么障碍物总是不停的出现在相同的地方。debug，trace之后发现，我设置了图片以3pixel每10ms向左移动，但是仙人掌却一直在原地，因此我需要对仙人掌也设置一个同样的速度。小鸟的话就需要多考虑一点，小鸟的速度比图片走的快，所以我对小鸟的速度，预设的高一点。</p><p>做完这些之后，为了让小鸟出现震动翅膀飞翔的效果，我对小鸟做了和小恐龙原地踏步一样的操作。对于障碍物的出现概率，我使用了和贪吃蛇随机出现桃子，苹果，橙子一样的机制。对不同种类的仙人掌和小鸟做一个概率设计，然后用一个变量代表出现的障碍物是什么。出现不同的障碍物刷新时加载相对应的图像。</p><p>做到这里，程序已经完成了70%，我们看一下效果</p><p>![Screenshot 2019-12-08 at 18.54.45](Screenshot 2019-12-08 at 18.54.45.png)</p><h4 id="5-碰撞检测">5 碰撞检测</h4><p>出现障碍物，我们就要考虑如何让小恐龙通过跳跃的方式躲避障碍物。这里我们就可以将小恐龙和障碍物分别看成两个矩形，然后取交集，如果不为空，则说明撞击了，game over，否则游戏继续。当然在这里，最简单的做法是，我们直接让对两个矩形求重合，这样可行，但对于游戏忠实玩家来说，这样做确实降低了游戏的可玩性，既然做了，我就希望可以做的最好。因此我在这里讲一下，我的做法，当然我也参考了网上的文章。</p><p>首先我们考虑小恐龙撞击障碍物可以假设为头和脚撞击，因此我们可以对小恐龙图片以整数倍放大，然后截取其头部和尾部（尽可能精确）。正如图所示，分别记录下两个矩形到左上顶点的坐标，以及两个矩形的长度和宽。同理对小鸟也进行同样操作，记录小鸟头部的矩形和尾部的矩形。接着对仙人掌取到碰撞区域，然后每次小恐龙遇到障碍物时，我们通过检测其有无重叠从而知道是否成功跨过障碍物。这里在调试的时候，有一个小技巧，我们可以通过填充矩形的方式观察，我们制定的碰撞区域是否合理。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 19.13.52.png" alt="Screenshot 2019-12-08 at 19.13.52" style="zoom:25%; "><img src="/2019/12/28/trex-up/Screenshot 2019-12-28 at 22.45.29.png" alt="Screenshot 2019-12-28 at 22.45.29" style="zoom:25%; "><p>比如，我把小恐龙的头部填充去测试我的碰撞。这一步确实很考验人的耐心。当然在现实生活中的碰撞检测，是有游戏引擎的，他是一个多边形，是有很多物理公式包含在里面，可以精确到像素与像素的碰撞。确实很多游戏引擎也都是机密不公开的，就像任天堂Nintendo</p><h4 id="6-分数计算，-game-over，-重新开始，-游戏暂停">6 分数计算， game over， 重新开始， 游戏暂停</h4><p>最后，我们来对游戏进行一个补充完善。分手计算，我们的方法很多，可以是通过时间，通过障碍物的数量。我就是通过时间计算分数，每隔50ms，增加一次小恐龙的分数。game over就是小恐龙碰撞到障碍物，我们对矩形取交集。如果不为空，则关闭线程，提示给玩家game over。重新开始，还是需要注意一点，就是移除所有旧的组建，新建新组建然后从新开始游戏。暂停，停止刷新游戏界面。分数显示，设置两个5位数，一个是记录，另一个是当前游戏的分数，游戏结束时从新结算，若打破游戏记录则更新。</p><p>到这里我们的小恐龙就做完了。通过这次的开发，除了温习旧知识，也学到了很多新的知识。也还有很多地方做的不够完美，比如没有加按键声音，昼夜交替做的不够平滑，小恐龙刷新的速度没有改变。总体来讲，完成了对于google 80%的仿写。</p><h4 id="源代码与素材均在我的github上">源代码与素材均在我的github上</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前情回顾：&quot;&gt;前情回顾：&lt;/h4&gt;
&lt;p&gt;不知道从那一年开始，这个不重要。 google 设计师在每次chrome断网时加入了一个彩蛋，此时此刻，将会出现一只萌萌的短腿霸王龙（Trex）开始原地踏步，然后点击space此时小恐龙向上蹦一下。然后接连出现仙人掌和小鸟
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="jframe" scheme="http://yoursite.com/tags/jframe/"/>
    
      <category term="game" scheme="http://yoursite.com/tags/game/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>greedy snake</title>
    <link href="http://yoursite.com/2019/12/28/greedy-snake/"/>
    <id>http://yoursite.com/2019/12/28/greedy-snake/</id>
    <published>2019-12-28T19:53:59.000Z</published>
    <updated>2019-12-29T20:40:45.940Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前情提要">前情提要:</h4><p>相信所有人的童年里都玩过贪吃蛇，在那个智能手机还不发达的时代，诺基亚和摩托罗拉还是市场的霸主，那个时候手机大概每款手机里都有个贪吃蛇的游戏。当然，我这个文章不是和大家怀旧，还是本着以技术为主，记录生活的本质。其次，我觉得贪吃蛇这个项目简单有意思，非常适合新手入门学习java。</p><h4 id="开发原因：">开发原因：</h4><p>本周在工作中遇到了Jframe和线程的bug，JFrame应该是一项很老的技术，上学的时候被作为一门教学语言，常常配合着AWT和SWING来用。当然，就目前来讲，桌面应用还是微软的天下（window操作系统），winforms，wpf， uwp这些成型的mvvm框架，开发简洁，尤其是其前端的UI拖拽绘制界面，nuget一键下载各种包确实比JFrame好用很多。当然要是IOS系统，那就是苹果全家桶了，再往下说就太多了。所以回归正题，jframe虽然有点过时，但是由于java仍然还是还是服务端的中流砥柱，其稳定高效跨平台的特点还是被大家所青睐，再加上很多公司java项目存在已久，像替换不是那么简单一句话的事。所以在此复习一下JFrame和线程操作，同时也来重温一下童年。</p><h4 id="开发流程与工具：">开发流程与工具：</h4><p>Eclipse ID<br>Java8， JFrame， Swing，Graphics，Timer线程</p><p>首先我设置了一个1200<em>720pixel的画板， 然后将（25，75） - （850，625）的区域设置为贪吃蛇游戏区域。并把这个区域等分成25</em>25的小格子，长度为34个小盒子，宽为24个小盒子。其中蛇每次可以移动一个小盒子</p><h4 id="第一步：初始化蛇">第一步：初始化蛇</h4><p>刚开始蛇的长度为3，其中蛇头1，蛇身2。蛇头需要考虑到上下左右四个方向，我就依次找到了四个图片代替。对于蛇具体化的实现，二维list，或者listnode都可以，为了简便开发，我就用数组其实主题的逻辑思维都是一样。二维数组分别代表蛇的每一部分在x, y轴对应坐标。我初始化蛇的方向向右，给定蛇的具体坐标。然后我这里调用JPanel自带的Graphic类复写paint方法。分别画出头和身体。<br><img src="/2019/12/28/greedy-snake/initSnake.png" alt="initSnake" style="zoom:25%; "></p><h4 id="第二步：蛇的移动">第二步：蛇的移动</h4><p>这里有一个小的问题，需要大家注意，就是每次移动我们需要先移动身体在移动头。这里有点与现实生活相反，为什么这么做，如果我们先移动头的话，那么头位置改变后，身体指向的位置本应该是原来头的位置，现在却指向现在头的位置从而造成蛇移动后有一条直线变成了一个点。<br>其次就是按键加上监听，上下左右代表移动。<br><img src="/2019/12/28/greedy-snake/snakeMove.png" alt="snakeMove" style="zoom:25%; "></p><h4 id="第三步：吃食物">第三步：吃食物</h4><p>我初始化了四种食物，分别为橙子，桃，苹果，分别代表1，2，3分。还有毒药，吃过吃了毒药则减10分。因为苹果，桃，橙子的分数不同，所以概率也不同。然后蛇每吃掉一个水果后就会更新一个新的水果，如果一定时间内没有碰到毒药毒药则消失，一段时间后再次出现。这里有三点需要注意。</p><h5 id="1">1</h5><p>如何生成概率不同的随机数？这里有个小技巧。生成从1个随机数范围是从1到100，然后如果其小于50则返回橙子1分，大于50小于80则返回桃子2分，大于80小于100则返回苹果3分。其概率分别对应50%，30%和20%</p><h5 id="2">2</h5><p>如何生成水果和毒药？我们需要水果和毒药的坐标，生成两个数字x, y范围分别在（1，34）和（1，24）之间，然后乘25就是对应x，y轴的位置。然后每次需要确认，毒药和水果的位置没有重合, 并且没有和蛇重合。<br>&lt;img src=‘eatFood.png’ alt=‘eatFood’ style:&quot;zoom:25%; &quot; /&gt;</p><h5 id="3">3</h5><p>如何刷新水果和毒药的坐标？当蛇头的x, y坐标等于水果的位置则证明水果被吃掉，此时从新生成新水果。如果毒药被吃掉，看一下分数，小于0则游戏结束，大于等于零则仍可以继续。这里我用到一个timer的线程，每隔1ms观察一次。然后我再建另外一个毒药的timer线程，每隔15s，去看一下毒药是否存在，如果存在则消失一段时间然后再重新刷新位置，如果被吃掉了则直接刷新位置。</p><h4 id="第四步：game-over，-暂停-和-重新开始">第四步：game over， 暂停 和 重新开始</h4><p>有三种可能性造成游戏结束，第一蛇头撞击墙壁，这就是每次移动后，我们取到蛇头的方向，然后分别判断其是否等于边界坐标，如果不等则游戏继续。第二点，蛇头撞击蛇身体，这里我们可以用一次for循环，遍历蛇头和蛇身体坐标，如出现一次蛇身体等于蛇头，则证明重合了游戏结束。最后就是吃了毒药分数小于0，加一个判断条件即可。<br>暂停和重新开始都是按space，预设两个个boolean类型值，分别代表暂停和游戏失败。每次一按spce，先判断是游戏失败还是暂定，如有失败，则重启游戏，若暂停，则游戏继续。这里需要注意，不能在暂停时候移动蛇头，所以要多写一个条件。</p><p>&lt;img src=‘gameover_stop.png’ alt=‘gameover_stop’ style:&quot;zoom:25%; &quot; /&gt;<br>最后，我设置了一个变量作为游戏记录，分数更新则刷新纪录。</p><h4 id="资源及源代码">资源及源代码</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake</a></p><h4 id="展示">展示</h4><p>放上一个视频，看一小效果^*^<br><img src="/2019/12/28/greedy-snake/show.png" alt="show" style="zoom:25%;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前情提要&quot;&gt;前情提要:&lt;/h4&gt;
&lt;p&gt;相信所有人的童年里都玩过贪吃蛇，在那个智能手机还不发达的时代，诺基亚和摩托罗拉还是市场的霸主，那个时候手机大概每款手机里都有个贪吃蛇的游戏。当然，我这个文章不是和大家怀旧，还是本着以技术为主，记录生活的本质。其次，我觉得贪吃
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="jframe" scheme="http://yoursite.com/tags/jframe/"/>
    
      <category term="game" scheme="http://yoursite.com/tags/game/"/>
    
      <category term="timer" scheme="http://yoursite.com/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>battle dev review</title>
    <link href="http://yoursite.com/2019/12/28/battle-dev-review/"/>
    <id>http://yoursite.com/2019/12/28/battle-dev-review/</id>
    <published>2019-12-28T19:53:24.000Z</published>
    <updated>2019-12-29T20:40:49.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前情回顾">前情回顾:</h4><p>周二晚上下班，感觉不是很累，于是颇有兴致的参加了一个叫battle dev的线上比赛，如果要是能拿到前三名，那奖励确实很丰厚，但是茫茫人海中，我也确实意识到自己还有很多待提高的方面。Ò<br>因此仅以下文，回顾并记录自己这次比赛中的收获。</p><h4 id="比赛形式：">比赛形式：</h4><p>时间两小时，题目五道题，难度逐渐增加，必须通过所有的test case测试，才能看到下一个题。编程语言不限定。</p><h4 id="第一题">第一题</h4><img src="/2019/12/28/battle-dev-review/question1.png" alt="question1" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question1.2.png" alt="question1.2" style="zoom:25%; "><p>眨眼一看，题目论述很长，其实是一道热身题，大概意思大家一起去出游，由于天气原因和突发状况，现在有一个人需要睡在没有帐篷的空地上。于是大家决定抽检，抽到最短的人去睡空地。<br>解法很多种，我就说一个我自己的解法。预设一个最小值，然后scanner不断扫描下一行，知道结束为止，如果发现有出现距离比预设值小，那么更换最小距离，并记录姓名，输出。<br>具体代码如下：<br><img src="/2019/12/28/battle-dev-review/solution1.png" alt="solution1" style="zoom:25%; "></p><h4 id="第二题">第二题</h4><img src="/2019/12/28/battle-dev-review/question2.png" alt="question2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question2.2.png" alt="question2.2" style="zoom:25%; "><p>同样也是论述很长，理解之后发现其问题也是不难，但很有意思，需要我们转化一下思维。因为当天我在做题时，也是犯了两次错误，才意识到他究竟想让我们求什么。题目大概说，为了庆祝奶奶的生日，某人决定用纸板去做装饰，告诉我们纸板可以重复使用，宽高都相同，只有长度不等。随机从纸箱中抽取四个纸板，可以对每个纸板裁剪成两半，让后我们保留自己用的一半，另一半扔掉，最后拼成最大一个正方形。问舍弃的面积<br>可以说这个题还是给我们挖了坑，我就是直直的往里跳，其实思路大概相同，四次取出的纸板长度总和再开平方得到的就是最大面积。我也是这么做的，相信第一次很多人和我的想法一样，然而这样做，我们就忽略了一个重要的条件，每次我们要将纸板分成两半，只能留一半。<br>所以需要我们换一个思维，反过来想，当我们舍弃的模板长度最小的时候，剩余的正方形面积则最大。我们每次最少舍弃多少木板，我们来抽象一个最坏的情况：</p><hr><p>First time : 5 cm<br>Second time : 4 cm  5 - &gt; 4.reject 1 cm<br>Third time : 3 cm.4 -&gt; 3  reject 1 cm * 2 + 1 cm<br>Fourth time 2 cm.3 -&gt; 2.reject 1 cm * 3 + 2 cm * 2 + 1 cm</p><hr><p>实际就是四次最小长度，剩下的就是最大正方形。 想到这里，那代码就很简单了，具体如下<br><img src="/2019/12/28/battle-dev-review/solution2.png" alt="solution2" style="zoom:25%; "></p><h4 id="第三题">第三题</h4><img src="/2019/12/28/battle-dev-review/question3.png" alt="question3" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.2.png" alt="question3.2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.3.png" alt="question3.3" style="zoom:25%; "><p>相比前两个题，第三题明显难度就提升了，实话说，当天我也是大概用掉40分钟才解决此问题。首先再读完题，由于之前在leetcode上碰到过一个与之相似问题，253 meeting room。leetcode问的是对于给出的时间表最少需要多少间教室。下一篇文章我会拿meeting room与这个题做对比，顺便复习总结一下优先队列。所以，读完题，我就已经想到要用priotity queue。<br>接下来说说这个题具体问什么，我们有n个电缆和m个request。每个request对应有起始时间和结束时间。问我们n个电缆是否满足m个request。如果满足，则输出电缆的使用顺序，反之亦然。<br>这个题有三点需要我们注意。第一，request是乱序的，所以我们需要用优先队列对其进行排序，用什么排序，按照题意，起始时间小的在前面，如果相同，则终止时间小的优先。第二，电缆数量不一定满足request的需求，所以需要我们在创建一个priority queue去记录电缆的时候用情况，如果有空闲电缆则可以直接使用。如没有则需要我们分类讨论，遍历正在使用的电缆，看看的当前电缆的开始时间前，是否有电缆可以使用完成。如果没有，则返回false，结束程序。第三点，也是最容易被忽视的一点，我也因为这个白白耗费15分钟，题目让我们输出的是电缆使用顺序，我们是要根据优先队列的弹出顺序决定电缆使用顺序，而不是自己顺序排列。<br>综上所述，我放上我自己的代码</p><p><img src="/2019/12/28/battle-dev-review/solution3.png" alt="solution3"></p><h4 id="第四题">第四题</h4><img src="/2019/12/28/battle-dev-review/question4.png" alt="question4" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question4.2.png" alt="question4.2" style="zoom:25%; "><p>当天我也是做到第四题，读题到写代码大概用了25分钟，然后就gg了。确实当时没有做出来，我在这里就说说题目的大概意思，以及我记得思路，这个题题目里给了提示联想背包问题。所以我们可以很快的想到用动态规划解决。但是相比于背包问题，这个题有点特殊，他的粉末可以按克买，所以还需要再去讨论。<br>题目，给出n种宝石，m种粉末，给出每种宝石的重量和价钱（不可拆分），给出每种粉末的价格，可以按照g来买。给定一个重量问怎么能获得对大利益？</p><hr><p>大致思路，二维dp数组dp[i+1][j+1], i代表种类，j代表数量。终止条件超出重量j<br>第一次列出，只用一种宝石的情况，最大的利润。<br>第二到N次，以此类推，max（dp[i][j-1]+Vi*Wi, dp[i][j])</p><hr><p>关键是粉末可以拆分成g，所以数据规模很大，我当时是将每个粉末拆分成g在此讨论可能是超时，没有通过，我会再修改修改更新文章与大家讨论。</p><h4 id="收获">收获:</h4><p>简短的来说，还是意识到自己的不足，第一语言方面，读题理解时间过长，每道题要白白消耗掉10分钟完全用于读题理解，说明语言还需要精进。第二，做不到学以致用，还是缺乏将实际应用问题段时间联想到已知技术。第三，动态规划和graph的问题一直都是自己的短板，需要专项提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾:&lt;/h4&gt;
&lt;p&gt;周二晚上下班，感觉不是很累，于是颇有兴致的参加了一个叫battle dev的线上比赛，如果要是能拿到前三名，那奖励确实很丰厚，但是茫茫人海中，我也确实意识到自己还有很多待提高的方面。Ò&lt;br&gt;
因此仅以下文，回顾并记录自己这
      
    
    </summary>
    
    
      <category term="Programming contest" scheme="http://yoursite.com/categories/Programming-contest/"/>
    
    
      <category term="priorityqueue" scheme="http://yoursite.com/tags/priorityqueue/"/>
    
      <category term="dynamique programming" scheme="http://yoursite.com/tags/dynamique-programming/"/>
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>sliding window1</title>
    <link href="http://yoursite.com/2019/12/28/sliding-window1/"/>
    <id>http://yoursite.com/2019/12/28/sliding-window1/</id>
    <published>2019-12-28T17:59:09.000Z</published>
    <updated>2019-12-29T18:44:14.944Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/12/28/sliding-window1/slidingwindow1.jpeg" alt="slidingwindow1"></p><p>sliding window直译为滑动窗口，大家可能直接会想到我们平时生活中的推拉窗户。在我们实际编程中，他也正是模拟这个生活中的场景，先去拉一个窗户，再去推另一个窗户。这个过程中我们分别用两个变量去代表这两个窗户，一快一慢，一左一右，这也是我们经常提到双指针问题。虽然在java，python，javascript，Csharp… … 等诸如此类的面向对象高级程序语言中，我们已经对指针弱化，将其变为对变量的引用，很大程度上简化了开发，但是指针的思想在我看来却仍然适用，而且加深对其的理解也有助于我们的编程。因此在思考了很久之后，我将sliding window这个主题作为我的第一篇文章。</p><h4 id="导语">导语:</h4><p>首先，sliding window，无论是我们熟知的🇨🇳大厂，百度，腾讯，阿里，头条… 或是美帝的google，amazon，fb，netflix… . 都十分青睐用此类型题目 去考察面试者。回过头想为什么，仅以我现在的知识我觉得，此类型问题本身并不复杂，问题的难点主要在两点 ：1 如何在面试中将问题理解，并能够想到用sliding window去解决这类问题 ，尤其是模拟实际生活的题，更是需要我们融会贯通。2 实现过程中有很多小的细节需要注意，例如窗口的滑动，触发一定的条件，左右指针不断的变化，导致结果随之变化，因此我们在实际手撕代码的过程中，经常出现bug。因此本文从算法分析，思路解析，再结合题目与代码去谈这个问题。。。废话不多说，进入正题。</p><h4 id="算法分">算法分</h4><p>滑动窗口大多数是用双指针求解，也有一些特殊的问题我们会结合一些特殊的数据结构，例如sorted_map（priority queue）或者的dequeue。对于此类特定的题型，我会在第二篇文章中讲述。本文主要讲述一般情况下的sliding window解决思路。</p><p>一般情况下的sliding window会给予我们一个特定数组或者字符串，让我们去找到满足一定条件的子数组或子字符串。比如：<br>找到最短字符串包含特定字符（有重复，无重复）<br>最长的子数组或字符串最多含有k个字符<br>最长的子数组或字符串只含有k个字符<br>一个特定的字符串在长字符串中出现的位置<br>……….</p><p>此类型题的大概时间复杂度为o(n)，需要遍历一次长字符串, 空间复杂度大多为常熟级别，近似于int[128]。之所以称为sliding window是由于，我们分别用快慢两个指针一前一后夹着字符串遍历，类似于一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。</p><h4 id="解题思路">解题思路</h4><p>这类型题的整体思路是设置两个快慢指针。快指针从左向右移动，目的是在每个快指针停留的位置，触发一定的条件，然后慢指针再随之移动，当其满足某种条件后，快指针再移动，周而复始，直到字符串遍历完毕，退出循环。<br>因此重点就在于，什么时候移动窗口，什么时候窗口保持不变。下面我写一个伪代码模版，给大家参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">sildingwindow</span><span class="params">(String [] strs. .. )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理边界条件  参数判断</span></span><br><span class="line">If( condition )</span><br><span class="line"> <span class="keyword">return</span> </span><br><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="comment">//left 代表窗口左边， 慢指针</span></span><br><span class="line"><span class="comment">//count 计数，用于判断何时触发条件</span></span><br><span class="line"><span class="comment">//result 记录结果</span></span><br><span class="line">Int left = <span class="number">0</span>, count = <span class="number">0</span> ,result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//申请一个hash数组, 也可用其他数据结构比如hashmap</span></span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> hash[<span class="number">128</span>]</span><br><span class="line"><span class="comment">//遍历数组，right代表窗口右侧，快指针</span></span><br><span class="line">For(<span class="keyword">int</span> right = <span class="number">0</span>; right&lt;strs.length;right++)&#123;</span><br><span class="line"><span class="comment">//每次移动一个格子后，更新hash</span></span><br><span class="line">Hash[strs[right]]++;</span><br><span class="line"><span class="comment">//更具窗口变更来改变条件</span></span><br><span class="line">If(Hash[strs[right]] = ..)</span><br><span class="line">&#123;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前条件不满足，移动左指针直至条件满足为止 </span></span><br><span class="line"><span class="keyword">while</span> (count &gt; ..) </span><br><span class="line">&#123; </span><br><span class="line">  …</span><br><span class="line">   <span class="keyword">if</span> (…)</span><br><span class="line">  &#123; </span><br><span class="line">​     count—; </span><br><span class="line">   &#125; </span><br><span class="line">   hash[A[l]]++;</span><br><span class="line">​    left++; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//条件根据具体题目要求确定返回结果</span></span><br><span class="line">res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典例题">经典例题</h4><p>leetcode 3 Longest Substring Without Repeating Characters<br>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><strong>Example 3:</strong><br><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is “wke”, with the length of 3.<br>​       Note that the answer must be a <strong>substring</strong>, “pwke” is a <em>subsequence</em> and not a substring.<br>题目很通俗易懂，给一个字符串，让我找到一个最长子字符串，要求其不包含重复元素。<br>解题思路：第一次看到这个题我们，会很快想到brute force解法，两个for循环遍历字符串，外层循环代表其实位置，内层循环代表终止位置，写一个函数判断字符串是否含有重复元素。为了对比出sliding window优势，我也写了此方法做对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = s.length(); </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (allUnique(s, i, j))</span><br><span class="line">ans = Math.max(ans, j - i); </span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">Character ch = s.charAt(i); </span><br><span class="line"><span class="keyword">if</span> (set.contains(ch))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">set.add(ch); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法时间复杂度为O(n^3) 三次遍历<br>但是如果我们要使用sliding window来解决此问题。我们不需要用n^2的时间复杂度去遍历字符串，假如我们已经验证从i - j不存在重复字符，那么我们可以把慢指针指向j，而不需要再从新遍历 i - j。然后通过对比result与快慢指针中间字符串的长度来得到最后结果。<br>以下，为代码示例，通常情况下提到检验重复，我们大多数会用到set。所以，我先写了一个set的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> n = s.length(); </span><br><span class="line">​    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">​    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">​    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">​      <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">​      <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">​        set.add(s.charAt(j++)); </span><br><span class="line">​        ans = Math.max(ans, j - i); </span><br><span class="line">​      &#125;</span><br><span class="line">​      <span class="keyword">else</span> &#123;</span><br><span class="line">​        set.remove(s.charAt(i++)); </span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此解法可以，但是其最坏时间复杂度为2n，就是快慢指针分别都把字符串从头到尾访问一遍。类似于“aabbcc”<br>以下，为通用的sliding window 解法，我们可以引入hashmap，key代表访问字符，value代表字符出现次数。当hashmap中某一个key的值大于1，于是我们尝试移动慢指针，在map中, 把慢指针指向的值的频率减1。在这里有个小技巧，我们可以用一个128长度的int数组来表示，ASCII table 65-92 对应 a-z， 97 - 122 对应A - Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">hash[c[i]]++; </span><br><span class="line"><span class="keyword">while</span> (hash[c[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">hash[c[left]]--; </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">map.put(c[i], map.getOrDefault(c[i], <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (map.get(c[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">map.put(c[left], map.get(c[left]) - <span class="number">1</span>); </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>之后我会陆续在写两篇关于sliding window的文章，列出所有我见过的有意思并且具有代表性的题，归类讲解。当然我不是大神，所以如果文章或者算法上哪里有问题还请各位轻喷多指点！！！<br>示例代码为了便于大家理解，我都写的java，当然我会把c++和python版本的代码放到我的github上。算法题主要是思路，所以语言上基本都是互通，如果大家有需要与其他的语言，Csharp, javascript…私信我，非常乐意把大家debug。</p><p>放上我自己的github：<a href="https://github.com/wuhewuhe/AlgorithmeSource" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/12/28/sliding-window1/slidingwindow1.jpeg&quot; alt=&quot;slidingwindow1&quot;&gt;&lt;/p&gt;
&lt;p&gt;sliding window直译为滑动窗口，大家可能直接会想到我们平时生活中的推拉窗户。在我们实际
      
    
    </summary>
    
    
      <category term="Algorithme" scheme="http://yoursite.com/categories/Algorithme/"/>
    
    
      <category term="two pointer" scheme="http://yoursite.com/tags/two-pointer/"/>
    
      <category term="sliding window" scheme="http://yoursite.com/tags/sliding-window/"/>
    
  </entry>
  
</feed>
