<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>zookeeper 集群</title>
      <link href="/2020/03/01/zookeeper/"/>
      <url>/2020/03/01/zookeeper/</url>
      
        <content type="html"><![CDATA[<p>How it works</p><p>It uses <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper</a> to coordinate which node in the cluster becomes the master. The elected master broker node starts and accepts client connections. The other nodes go into slave mode and connect the the master and synchronize their persistent state /w it. The slave nodes do not accept client connections. All persistent operations are replicated to the connected slaves. If the master dies, the slaves with the latest update gets promoted to become the master. The failed node can then be brought back online and it will go into slave mode.</p><p>All messaging operations which require a sync to disk will wait for the update to be replicated to a quorum of the nodes before completing. So if you configure the store with <code>replicas=&quot;3&quot;</code> then the quorum size is <code>(3/2+1)=2</code>. The master will store the update locally and wait for 1 other slave to store the update before reporting success. Another way to think about it is that store will do synchronous replication to a quorum of the replication nodes and asynchronous replication replication to any additional nodes.</p><p>When a new master is elected, you also need at least a quorum of nodes online to be able to find a node with the lastest updates. The node with the lastest updates will become the new master. Therefore, it’s recommend that you run with at least 3 replica nodes so that you can take one down without</p><hr><p>one master two slaves, when master is down, elected a new master</p><p>1 jdk, apache, linux</p><p>2 close firewall</p><p>3 zookeeper cluster : zk01,zk02,zk03</p><p>4 集群部署规划表</p><p>Hostname : 1361 1362 1363</p><p>Zookeeper port : 2191 2192 2193</p><p>Amq bind : 63631 63632 63633</p><p>amqtcp : 61616 61617 61618</p><p>Console port: 8161 8162 8163</p><p>5 设置节点</p><p>Node1 2 3， 修改配置对应的端口号</p><p>hostname reflect.</p><p>set brokername, 三个节点的持久化配置</p><p>6 修改 persistantadapter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line">    &lt;replicatedLevelDB</span><br><span class="line">      directory&#x3D;&quot;activemq-data&quot;</span><br><span class="line">      replicas&#x3D;&quot;3&quot;</span><br><span class="line">      bind&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:0&quot;</span><br><span class="line">      zkAddress&#x3D;&quot;zoo1.example.org:2181,zoo2.example.org:2181,zoo3.example.org:2181&quot;</span><br><span class="line">      zkPassword&#x3D;&quot;password&quot;</span><br><span class="line">      zkPath&#x3D;&quot;&#x2F;activemq&#x2F;leveldb-stores&quot;</span><br><span class="line">      hostname&#x3D;&quot;broker1.example.org&quot;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>7 批处理启动</p><p>Execute a bash script for starting booker machine with ordering</p><p><strong>Cluster failover and verification</strong></p><p>failover 多节点 主从集群 故障迁移</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
          <category> ActiveMq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> master </tag>
            
            <tag> failover </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 面试</title>
      <link href="/2020/03/01/io/"/>
      <url>/2020/03/01/io/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是比特(Bit), 什么是字节(Byte), 什么是字符(Char), 它们长度是多少, 各有什么区别</li></ol><p>答案</p><p>Bit最小的二进制单位 ，是计算机的操作部分 取值0或者1<br>Byte是计算机操作数据的最小单位由8位bit组成 取值（-128-127）<br>Char是用户的可读写的最小单位，在Java里面由16位bit组成 取值（0-65535）</p><p>Bit 是最小单位 计算机 只能认识 0或者1</p><p>8个字节 是给计算机看的<br>字符 是看到的东西  一个字符=二个字节</p><p>2. 什么是流, 按照传输的单位, 分成哪两种流, 并且他们的父类叫什么流是指数据的传输</p><p>答案</p><p>字节流，字符流 <br>字节流：InputStream OutputStream<br>字符流：Reader Writer</p><ol start="3"><li>流按照传输的方向可以分为哪两种, 分别举例说明</li></ol><p>答案</p><p>输入输出相对于程序<br>输入流InputStream<br>，输出流OutputStream</p><ol start="4"><li>按照实现功能分为哪两种, 分别举例说明</li></ol><p>答案</p><p>节点流，处理流<br>节点流：OutputStream<br>处理流： OutputStreamWriter</p><p>5. BufferedReader属于哪种流, 它主要是用来做什么的, 它里面有那些经典的方法</p><p>答案</p><p>属于处理流中的缓冲流，可以将读取的内容存在内存里面，有readLine（）方法</p><p>6. 什么是节点流, 什么是处理流, 它们各有什么用处, 处理流的创建有什么特征</p><p>答案</p><p>节点流 直接与数据源相连，用于输入或者输出<br>处理流：在节点流的基础上对之进行加工，进行一些功能的扩展<br>处理流的构造器必须要 传入节点流的子类</p><p>7. 如果我要对字节流进行大量的从硬盘读取, 要用那个流, 为什么</p><p>答案</p><p>BufferedInputStream 使用缓冲流能够减少对硬盘的损伤</p><p>8. 如果我要打印出不同类型的数据到数据源, 那么最适合的流是那个流, 为什么</p><p>答案</p><p>Printwriter 可以打印各种数据类型</p><p>9. 怎么样把我们控制台的输出改成输出到一个文件里面, 这个技术叫什么</p><p>答案</p><p>SetOut（printWriter, printStream）重定向</p><p>11. 怎么样把输出字节流转换成输出字符流, 说出它的步骤</p><p>答案</p><p>使用 转换处理流OutputStreamWriter 可以将字节流转为字符流<br>New OutputStreamWriter（new FileOutputStream（File file））;</p><p>12. 把包括基本类型在内的数据和字符串按顺序输出到数据源，或者按照顺序从数据源读入，一般用哪两个流</p><p>答案</p><p>DataInputStream DataOutputStream</p><p>13. 把一个对象写入数据源或者从一个数据源读出来, 用哪两个流</p><p>答案</p><p>ObjectInputStream ObjectOutputStream</p><p>14. 什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作</p><p>答案</p><p>对象序列化，将对象以二进制的形式保存在硬盘上<br>反序列化；将二进制的文件转化为对象读取<br>实现serializable接口</p><p>不想让字段放在硬盘上就加transient</p><p>15. 如果在对象序列化的时候不想给一个字段的数据保存在硬盘上面, 采用那个关键字?</p><p>答案</p><p>transient关键字</p><p>16. 在实现序列化接口是时候一般要生成一个serialVersionUID字段, 它叫做什么, 一般有什么用</p><p>答案</p><p>是版本号，要保持版本号的一致 来进行序列化</p><p>为了防止序列化出错</p><ol start="17"><li>InputStream里的read()返回的是什么, read(byte[] data)是什么意思, 返回的是什么值</li></ol><p>答案</p><p>返回的是所读取的字节的int型（范围0-255）<br>read（byte [ ] data）将读取的字节储存在这个数组<br>返回的就是传入数组参数个数</p><p>Read  字节读取字节  字符读取字符</p><p>18. OutputStream里面的write()是什么意思, write(byte b[], int off, int len)这个方法里面的三个参数分别是什么意思</p><p>答案</p><p>write将指定字节传入数据源<br>Byte b[ ]是byte数组<br>b[off]是传入的第一个字符<br>b[off+len-1]是传入的最后的一个字符 <br>len是实际长度</p><p>19. 流一般需要不需要关闭, 如果关闭的话在用什么方法, 一般要在那个代码块里面关闭比较好，处理流是怎么关闭的，如果有多个流互相调用传入是怎么关闭的？</p><p>答案</p><p>流一旦打开就必须关闭，使用close方法<br>放入finally语句块中（finally 语句一定会执行）<br>调用的处理流就关闭处理流<br>多个流互相调用只关闭最外层的流</p><p>20. Java中的所有的流可以分为几大类, 它们的名字是什么, 各代表什么</p><p>答案</p><p>分为 字节输入流 InputStream <br>字节输出流 OutputStream<br>字符输入流 Reader<br>字符输出流 Writer<br>所有流都是这四个流的子类</p><p>说下常用的io流</p><p>Icon<br>InputStream, OutputStream,<br>FileInputStream, FileOutputStream,<br>BufferedInputStream, BufferedOutputStream<br>Reader, Writer<br>BufferedReader, BufferedWriter</p><p>21 写一段代码读取一个序列化的对象一般使用哪种Stream？</p><p>Icon<br>A、InputStream B、FileReader C、DataInputStream D、ObjectStream</p><p>22 io流怎样读取文件的？</p><p>Icon<br>使用File对象获取文件路径，通过字符流Reader加入文件，使用字符缓存流BufferedReader处理Reader，再定义一个字符串，循环遍历出文件。代码如下：<br>File file = new File(“d:/spring.txt”);<br>try {<br>Reader reader = new FileReader(file);<br>BufferedReader buffered = new BufferedReader(reader);<br>String data = null;<br>while((data = buffered.readLine())!=null){<br>System.out.println(data);<br>}<br>} catch (FileNotFoundException e) {<br>e.printStackTrace();<br>} catch (IOException e) {<br>e.printStackTrace();<br>}</p><p>23 说说你对io流的理解</p><p>Icon<br>Io流主要是用来处理输入输出问题，常用的io流有InputStream，OutputStream，Reader，Writer等</p><p>24 JAVA的IO流和readLine方法</p><p>Icon<br>Java的io流用来处理输入输出问题，readLine是BufferedReader里的一个方法，用来读取一行。</p><p>25 用什么把对象动态的写入磁盘中，写入要实现什么接口。</p><p>Icon<br>ObjectInputStream，需要实现Serializable接口<br>26  FileInputStream 创建详情，就是怎样的创建不报错，它列出了几种形式!</p><p>Icon<br>FileInputStream是InputStream的子类，通过接口定义，子类实现创建FileInputStream,</p><p>27 用io流中的技术，指定一个文件夹的目录，获取此目录下的所有子文件夹路径</p><p>28 请问你在什么情况下会在你得java代码中使用可序列化？ 如何实现java序列化？</p><p>Icon<br>把一个对象写入数据源或者从一个数据源读出来，使用可序列化，需要实现Serializable接口</p><p>28 PrintStream、BufferedWriter、PrintWriter的比较? <br>PrintStream类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成PrintStream后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStream<br>BufferedWriter: 将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过write()方法可以将获取到的字符输出，然后通过newLine()进行换行操作。BufferedWriter中的字符流必须通过调用flush方法才能将其刷出去。并且BufferedWriter只能对字符流进行操作。如果要对字节流操作，则使用BufferedInputStream。<br> PrintWriter的println方法自动添加换行，不会抛异常，若关心异常，需要调用checkError方法看是否有异常发生，PrintWriter构造方法可指定参数，实现自动刷新缓存（autoflush）；</p>]]></content>
      
      
      <categories>
          
          <category> InputStream </category>
          
      </categories>
      
      
        <tags>
            
            <tag> byteinputstream </tag>
            
            <tag> filterinput </tag>
            
            <tag> datainputstream </tag>
            
            <tag> bufferinputstream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据持久话</title>
      <link href="/2020/03/01/persistance/"/>
      <url>/2020/03/01/persistance/</url>
      
        <content type="html"><![CDATA[<p>MQ realibiltity and high available</p><p>1 transaction</p><p>2 persistance     -&gt;. Mq 自身携带</p><p>3 acknowledge</p><p>4 可持久化</p><p>mq服务器和数据库服务器不在同一个机器，但是我们可以将mq的数据备份存储到一个特定的db</p><p>实现： jdbc，kahadb in default， jdbc message store with activemq journal</p><p>activemq将消息发送出去后，首先保存在本地数据文件，内存数据库，远程数据库，再试图将消息发送给接收者，否者存储中删除，失败继续尝试发送</p><p>消息中心启动后，首先要检查存储位置。</p><h4 id="kahadb-基于日志的存储">kahadb 基于日志的存储</h4><p>KahaDB is a file based persistence database that is local to the message broker that is using it. It has been optimized for fast persistence. It is the the default storage mechanism since <strong>ActiveMQ 5.4</strong>. KahaDB uses less file descriptors and provides faster recovery than its predecessor, the <a href="https://activemq.apache.org/amq-message-store" target="_blank" rel="noopener">AMQ Message Store</a>.</p><h2 id="Configuration">Configuration</h2><p>To use KahaDB as the broker’s persistence adapter configure ActiveMQ as follows (example):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;broker brokerName&#x3D;&quot;broker&quot;&gt;</span><br><span class="line">   &lt;persistenceAdapter&gt;</span><br><span class="line">     &lt;kahaDB directory&#x3D;&quot;activemq-data&quot; journalMaxFileLength&#x3D;&quot;32mb&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">&lt;&#x2F;broker&gt;</span><br></pre></td></tr></table></figure><p><strong>kahadb 存储原理</strong></p><p>数据存储在datalog文件中，数据不需要时删除或者归档</p><p>事务日志和索引</p><p>1 db-number.log存储消息记录到文件中，当到达32mb时创建一个新的文件</p><p>binary tree index。 redo用于恢复索引 lock写读</p><h4 id="JDBC-消息存储">JDBC 消息存储</h4><p>1 mq+mysql</p><p>2 lib + jdbc driver</p><p>3 configuration of jdbc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt; </span><br><span class="line">  &lt;jdbcPersistenceAdapter dataSource&#x3D;&quot;#my-ds&quot;createTableOnStartup &#x3D;true&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>4 database pool configuration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;mysql-ds&quot; class&#x3D;&quot;org.apache.commons.dbcp.Basi cDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activemq?relaxAutoCommit&#x3D;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;156324_Julien&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>5 建仓库建table</p><p>create database activemq</p><p>Activemq_msgs:</p><p>Id, container, msgid_prod, msg_seq, expiration, msg, proprity</p><p>Activemq_acks</p><p>​activemq_ack, container, sub_dest, client_id, subname, selector, last_acked_id</p><p>Activemq_lock</p><p>​id, broker</p><p>6 代码运行验证</p><p>deliverymode.persistent</p><ul><li><p>queue : 开启持久化，否则不会写到数据库</p></li><li><p>Topic : 先启动consumer</p></li></ul><p>7 database</p><ul><li>queue</li></ul><p>Producer : activemq_msg stock to mysql</p><p>Consumer: activemq_msg release message</p><ul><li>topic</li></ul><p>Producer: active_mgs存储所有消息，不会释放</p><p>Consumer: 有一个人activer subscriber</p><p>8 开发注意</p><ul><li><p>jar包 数据库驱动</p></li><li><p>createTableOnStartup 启动时创建表</p></li><li><p>Java.lang.illegalStateException: beanfactory not initialed or already closed  can not contains _</p></li></ul><p>9 high perform journal</p><p>o achieve high performance of durable messaging in ActiveMQ V4.x we strongly recommend you use our high performance journal - which is enabled by default. This works rather like a database; messages (and transcation commits/rollbacks and message acknowledgements) are written to the journal as fast as is humanly possible - then at intervals we checkpoint the journal to the long term persistence storage (in this case JDBC).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; </span><br><span class="line">       xmlns:amq&#x3D;&quot;http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&quot; </span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; </span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-2.0.xsd </span><br><span class="line">                           http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core </span><br><span class="line">                           http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&#x2F;activemq-core.xsd&quot;&gt; </span><br><span class="line">  &lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&#x2F;&gt; </span><br><span class="line">  &lt;broker useJmx&#x3D;&quot;true&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&quot;&gt; </span><br><span class="line">    &lt;networkConnectors&gt; </span><br><span class="line">      &lt;!-- &lt;networkConnector uri&#x3D;&quot;multicast:&#x2F;&#x2F;default?initialReconnectDelay&#x3D;100&quot; &#x2F;&gt; &lt;networkConnector uri&#x3D;&quot;static:&#x2F;&#x2F;(tcp:&#x2F;&#x2F;localhost:61616)&quot; &#x2F;&gt; --&gt; </span><br><span class="line">    &lt;&#x2F;networkConnectors&gt; </span><br><span class="line">    &lt;persistenceFactory&gt;</span><br><span class="line">      &lt;journalPersistenceAdapterFactory journalLogFiles&#x3D;&quot;5&quot; dataDirectory&#x3D;&quot;$&#123;basedir&#125;&#x2F;target&quot; &#x2F;&gt; </span><br><span class="line">      &lt;!-- To use a different dataSource, use the following syntax : --&gt; </span><br><span class="line">      &lt;!-- &lt;journalPersistenceAdapterFactory journalLogFiles&#x3D;&quot;5&quot; dataDirectory&#x3D;&quot;$&#123;basedir&#125;&#x2F;activemq-data&quot; dataSource&#x3D;&quot;#mysql-ds&quot;&#x2F;&gt; --&gt; </span><br><span class="line">    &lt;&#x2F;persistenceFactory&gt; </span><br><span class="line">    &lt;transportConnectors&gt; </span><br><span class="line">      &lt;transportConnector uri&#x3D;&quot;tcp:&#x2F;&#x2F;localhost:61636&quot; &#x2F;&gt; </span><br><span class="line">    &lt;&#x2F;transportConnectors&gt; </span><br><span class="line">  &lt;&#x2F;broker&gt; </span><br><span class="line">  &lt;!-- MySql DataSource Sample Setup --&gt; </span><br><span class="line">  &lt;!-- </span><br><span class="line">  &lt;bean id&#x3D;&quot;mysql-ds&quot; class&#x3D;&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt; </span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; </span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;activemq?relaxAutoCommit&#x3D;true&quot;&#x2F;&gt; </span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;activemq&quot;&#x2F;&gt; </span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;activemq&quot;&#x2F;&gt; </span><br><span class="line">    &lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; </span><br><span class="line">  &lt;&#x2F;bean&gt; </span><br><span class="line">  --&gt; </span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>日志不会立刻同步到数据库中，如果1000条消息，消费900条，则日志仅仅同步剩余100条到数据库</p><h4 id="总结">总结</h4><p>持久化消息： when server is down, the message will not be losted</p><p>Mq : high perform journal, kahadb, levelDB + zookeeper可复制存储的集群方案</p>]]></content>
      
      
      <categories>
          
          <category> persistance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kahadb </tag>
            
            <tag> jdbc </tag>
            
            <tag> jounaling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMS protocol</title>
      <link href="/2020/03/01/jms-contract/"/>
      <url>/2020/03/01/jms-contract/</url>
      
        <content type="html"><![CDATA[<p>ActiveMQ is designed to support mutliple different <a href="https://activemq.apache.org/topologies" target="_blank" rel="noopener">topologies</a> and protocols. Which one you use depends on your messaging requirements, quality of service and network topology.</p><p>Protocol : TCP; NIO; UDP; SSL; Http(s); VM</p><p>传输协议不一样，配置和性能也不一样</p><p>1 how to modify</p><p>open activemq.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transportConnectors&gt;</span><br><span class="line">           &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span><br><span class="line">           &lt;transportConnector name&#x3D;&quot;openwire&quot; uri&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:61616?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;&#x2F;&gt;</span><br><span class="line">           &lt;transportConnector name&#x3D;&quot;amqp&quot; uri&#x3D;&quot;amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;&#x2F;&gt;</span><br><span class="line">           &lt;transportConnector name&#x3D;&quot;stomp&quot; uri&#x3D;&quot;stomp:&#x2F;&#x2F;0.0.0.0:61613?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;&#x2F;&gt;</span><br><span class="line">           &lt;transportConnector name&#x3D;&quot;mqtt&quot; uri&#x3D;&quot;mqtt:&#x2F;&#x2F;0.0.0.0:1883?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;&#x2F;&gt;</span><br><span class="line">           &lt;transportConnector name&#x3D;&quot;ws&quot; uri&#x3D;&quot;ws:&#x2F;&#x2F;0.0.0.0:61614?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;transportConnectors&gt;</span><br></pre></td></tr></table></figure><p>activemq in default is open write means tcp ip</p><p>and it has others protocol like amqp, stomp, ws</p><ul><li>transmission control protocol</li></ul><p>默认broker配置，监听端口号61616，在网络传输数据前必须要序列化数据，消息是通过一个write ptotocol来序列化成字节流</p><p>url like tcp://hostanme; port?key=value&amp;value=value</p><ul><li>NIO new io protocol</li></ul><p>Which may have better performance</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transportConnectors&gt;</span><br><span class="line">    &lt;transportConnector name&#x3D;&quot;nio&quot; uri&#x3D;&quot;nio:&#x2F;&#x2F;0.0.0.0:61616&quot;&#x2F;&gt;  </span><br><span class="line">  &lt;&#x2F;&lt;transportConnectors&gt;</span><br></pre></td></tr></table></figure><p>Trying to use nio transport url on the client side will instantiate the regular TCP transport</p><p>he difference is that it is implemented using NIO API which can help with performance and scalability. NIO is a server side transport option only. Trying to use it on the client side will instantiate the regular TCP transport.</p><ul><li>modify activemq.xml</li></ul><p>backup modify transport protocol</p><ul><li>modify producer and consumer code</li></ul><p>NIO 61618</p><ul><li>Nio 增强</li></ul><p>One of the main advantages of using NIO instead of the regular versions of the transport is that it can scale better and support larger number of connections. The main limit in this scenario is the number of threads the system in using. In blocking implementations of the transports, one thread is used per connection. In the NIO implementation, there’s a shared pool of threads that will take the load, so that number of connections are not directly related to the number of threads used in the system.</p><p>Origin is BIO + TCP = NIO + TCP</p><p><strong>如何让nio支持所有的协议？</strong></p><p>enable : auto</p><ul><li>AMPQ advance message queue protocol</li><li>stmop streaming text orient messaging protocol</li><li>mqtt IBM message queue templating transport</li></ul>]]></content>
      
      
      <categories>
          
          <category> Transport </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nio </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Broker Spring and Springboot 整合</title>
      <link href="/2020/03/01/broker/"/>
      <url>/2020/03/01/broker/</url>
      
        <content type="html"><![CDATA[<p>Broker</p><p>用代码的形式启动activemq，将mq嵌入到代码里，以便随时的启动，在用的时候启动节省资源，保证可靠性</p><p>instance a server activemq in java</p><p>嵌入式broker</p><p>BrokerService brokerservice = new BrokerService :</p><p>brokerservice.setUseJms(true);</p><p>brokerservice.addConnector(buildadress “tcp/ip//localhost:61616”)</p><p>brokerservice.start()</p><p>Spring整合activemq</p><p>1 Add dependency to spring pom.xml</p><p>2 modify applicationContext.xml: configuarion producer,</p><ul><li><p><strong>property</strong> url</p></li><li><p>Destination : queue</p></li><li><p>jms template</p></li></ul><p>3  queue</p><p>spring producer</p><p>@service</p><p>@AutoWired jmstemplate</p><p>getbean(spring_producer)</p><p>Produce.jmsTemplate.send(Messagecreator{</p><p>Session -&gt; text message = session.createTextmessage(“sss”);</p><p>})</p><p>spring consumer</p><p>@Service</p><p>@AutoWired jmstemplate</p><p>getbean(spring_consumer)</p><p>Consumer.jmstemplate.receiveAndConvert()</p><p>4 topic</p><p>change destination from queue to topic</p><p>start consumer then start producer</p><p>5 listener</p><p>Modify configuration : add jmscontainer bean who has propertity message listener, connectionfactory and destination</p><p>on message try catch</p><p>Add component</p><p>消费者不启动直接通过配置监听完成</p><p>springboot 如何整合activemq</p><ul><li>queue</li></ul><p><strong>Producer</strong></p><p>1 new maven project</p><p>2 add dependency to pom.xml  2.1.5 springboot, activemq</p><p>3 application.yml</p><p>server port;</p><p>spring: activemq: broker-url, user, password,</p><p>Jms pub-sub-domain: false = queue true = topic</p><p>My queue : customize name</p><p>4 configuration bean</p><p>Component.instance myqueue</p><p>5 queue produce</p><p>@Component</p><p>@EnableJMS</p><p>@autowired</p><p>jmstemplate, queue</p><p>producemsg{</p><p>Jmstemplate.convertandsend(queue, “text”)}</p><p>6 main app</p><p>@springbootapplication</p><p>7 test unit</p><p>@SpringbootTest(class = main app_produce.calss)</p><p>@runwith(springJunit4Classrunner.class)</p><p>@webappConfiguration</p><p>Produce_msg()</p><p><strong>springboot producer 隔定投</strong></p><p>每间隔三秒钟，往mq发送一条消息</p><p>@schduled(fixedDelay = 3000)</p><p>@enableschduling</p><p>start main app</p><p><strong>consumer</strong></p><p>同理可见producer</p><p>1 queue Consume</p><p>@Component</p><p>@jmslistener destination (queue)</p><p>@receive sychrono</p><ul><li>topic</li></ul><p>modify</p><p>pub-sub-domain: true</p><p>1 topic bean</p><p>@Component</p><p>@vlalue(my topic)</p><p>@Bean</p><p>new activemqTopic(topic name)</p><p>2 topic</p><ul><li>producer</li></ul><p>@component</p><p>@autowired</p><p>@jmstemplate</p><p>@schduled(fixdelay = 3000)</p><p>Jmstemplate.convertandsend(&quot;&quot;)</p><p>3 main app</p><ul><li>consumer</li></ul><p>consumer topic</p><p>@component</p><p>@jmslistener (topic)</p><p>Receive();</p><p>2 simulate 2 subscriber</p><p>mainapp 5555 5566</p>]]></content>
      
      
      <categories>
          
          <category> Broker </category>
          
          <category> Spring </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bean </tag>
            
            <tag> queue </tag>
            
            <tag> topic </tag>
            
            <tag> producer </tag>
            
            <tag> consumer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/03/01/redis/"/>
      <url>/2020/03/01/redis/</url>
      
        <content type="html"><![CDATA[<p>二者的区别<br>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</p><p>AOF 持久化以日志的形式记录服务器所处理的每一个增删改操作，以文本的方式记录，可以打开文件看到详细的操作记录</p><p>二者优缺点<br>RDB 优势<br>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式。比如，可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，可以非常容易的进行恢复。同时，可以将这种完整的数据文件压缩后发送到一些远程的安全存储上去。适合做冷备</p><p>直接基于 RDB 数据文件来重启和恢复 Redis 进程，恢复效率会更高</p><p>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化</p><p>RDB 劣势<br>如果想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</p><p>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟<br>一般不要让 RDB 的间隔太长，否则每次生成的 RDB 文件太大了，对 Redis 本身的性能也会有影响</p><p>AOF 优势<br>该机制可以带来更高的数据安全性。Redis 提供了 3 种同步策略：每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言</p><p>由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，在 Redis 下一次启动之前，可以通过 redis-check-aof 工具来帮助解决数据一致性的问题</p><p>如果日志过大，Redis 可以自动启用 rewrite 机制（后台重写，不影响客户端的读写）。即 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性</p><p>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据</p><p>AOF 劣势<br>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大，靠重写来弥补</p><p>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为要将命令写到 AOF 缓冲区。此外，还要定时 fsync 一次日志文件</p><p>通过回放 AOF 日志中的写入指令来重新构建整个数据集，数据恢复速度比较慢</p><p>定期的备份需要自己手写脚本去做，做冷备不太合适</p><p>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以，类似 AOF 这种较为复杂的基于命令日志回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多</p><p>二者选择的标准<br>不要仅仅使用 RDB，因为那样会导致丢失数据<br>也不要仅仅使用 AOF，因为那样有两个问题，第一，通过 AOF 做冷备，没有 RDB 做冷备，恢复速度快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug<br>综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>active mq tutorial</title>
      <link href="/2020/03/01/active-mq-tutorial/"/>
      <url>/2020/03/01/active-mq-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Activemq</p><p>connectionFactory -&gt; cinnection -&gt; session</p><p>message producer.msg. Message consumer</p><p>​         Destination : queue / topic</p><p>​msg : byte, stream, text, map, object</p><h3 id="消费message的方法">消费message的方法</h3><h4 id="receive">receive</h4><p>block and synchronous</p><h4 id="message-listener">message listener</h4><p>Asynchronous no block</p><h4 id="consumer-situation">consumer situation</h4><p>一共6条消息，先启动两个consumer， 再启动producer，两个人平均分配，like load balance</p><p>Topic</p><p>生产者消费者有时间上的关系，先订阅后发布，topic是无状态，不存储消息</p><p>一共6条消息，先启动两个consumer， 再启动producer，两个人分别收到6条</p><p>port 6116 queue   topic 8161</p><p>1 one to one , one to N</p><p>2 save in mq server, no stateless</p><p>3 not throw wait the consumer the message, throw to trash</p><h4 id="jms-structure">jms structure</h4><p>jms producer provider message consumer</p><h3 id="jms-message">jms message</h3><p>message header, body, attribute</p><p>message header : destination, delvierymode, expiration, <strong>messagID</strong> and priority.messageId is most important to ensure it not duplicate</p><p>Message body : text message, mapmessage</p><p>Property : setproperty  识别去重 重点标注</p><h4 id="jms三大特性：持久性，事物，签收">jms三大特性：持久性，事物，签收</h4><h5 id="persistance">persistance</h5><ul><li>Queue</li></ul><p>jms如何保证消息的可靠性</p><p>queue : jms setDeliveryMode (PERSISTENT) / NO-PERSISTENT</p><p>Par default : persistent</p><ul><li>topic</li></ul><p>Topic consumer setclientid,</p><p>session.createTopic,</p><p>top subscriber = session.createdurablesubscriber</p><p>connection.start</p><p>Message.receive</p><p>Topic 看在线和离线，关注多久 好比微信公众号</p><h5 id="transaction">transaction</h5><p>Acid, 隔离级别 事物偏向于生产者</p><ul><li>producer</li></ul><p>设置事物为true，session.commit提交</p><p>正常情况手动提交异常情况rollback， tolerance</p><ul><li>consumer</li></ul><p>transaction = false 直接收一次</p><p>transaction = true，没有commit，重复消费</p><h5 id="ack-签收">ack 签收</h5><p>ack偏向于consumer</p><p>非事物签收</p><p>1 Auto-acknowledge</p><p>2 client-acknowledge</p><p>如果用client调用ack签收</p><p>3 dups-ok</p><p>带副本，重复签收</p><p>sessiontransaction 事物签收</p><p>如果选择sessionmode，默认自动签收，第二个参数作用不大</p><p>切记用了事物 一定要用session.commit();</p><h3 id="queue-vs-topic">queue vs topic</h3><p>Queue asycho, send one time, persistance par deafult</p><p>Topic, first start consumer, active/offline subscribe, recover, 高可用</p>]]></content>
      
      
      <categories>
          
          <category> Activemq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> message </tag>
            
            <tag> persistance </tag>
            
            <tag> transaction </tag>
            
            <tag> acknowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>activemq 高级特性</title>
      <link href="/2020/03/01/activemq/"/>
      <url>/2020/03/01/activemq/</url>
      
        <content type="html"><![CDATA[<h2 id="Advanced-character">Advanced character</h2><h3 id="1-Deadetter">1 Deadetter</h3><p>1 Dead letter queue  catch</p><p>2 core queue.try</p><p>share deadletterqueue, individual dead queue 专门为重要的模块设置一个</p><p>配置：</p><ul><li>processExpired = false, delete dead letter</li><li>processNonPersisent = true, 不会把非持久的消息放进来</li></ul><h3 id="2-async-send">2 async send</h3><p>in most of case, active mq use async send the message</p><p>slow consumer : pool</p><p>no transaction but need persistant message, mq will use synchro send</p><p>提升性能，挤压broker，慢消费，不能有效的设置消息发送成功</p><p>connectionfactory设置异步send, activemqproducer : message.setJMSmessageid, and get messageID</p><p>Activemq.send() : onSuccess, onException</p><p><strong>如何确保发送成功</strong></p><p>消息丢失，挤压消息在broker</p><p>同步的话： send不阻塞，表示发送成功</p><p>异步的话：回执确保消息是否发送成功</p><h3 id="3repeat-message">3repeat message</h3><p>查看message ID， idematory</p><p>Create a map, save key and value.or we can use a tier app, like redis, who can help us to manage the message</p><h3 id="4-delivery-mode-：set-and-delay">4 delivery mode ：set and delay</h3><p>delay and schedule message delivery</p><p>Activemq : delay - long , period - int , repeat - int</p><p>XML properties : schduler support</p><p>create two new class : delayAndSchduleProducer and delayAndSchdulerConsumer</p><h3 id="5-retry-message-resend">5 retry  message resend</h3><p>1 client 用transaction 且在session中调用rollback</p><p>2 client用transaction, but not commit or close before commit</p><p>3 clien use client_ackonwledge delivery mode and call recover in session</p><p>Activemq : interval 1 s and resend 6 times</p><p>poison ack : redelivered pass 6 times, consumer will send poison ack to MQ, tell broker not resend, and send them to dead letter queue</p><p>two propertites: maximumdelivery and maimumintervaltime</p><p>Spring activemqRedeliveryPolicy</p>]]></content>
      
      
      
        <tags>
            
            <tag> dead letter queue </tag>
            
            <tag> asyc send </tag>
            
            <tag> delivery mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>commonMessageProbleme</title>
      <link href="/2020/02/29/commonMessageProbleme/"/>
      <url>/2020/02/29/commonMessageProbleme/</url>
      
        <content type="html"><![CDATA[<h2 id="保证-MQ-消息不丢">保证 MQ 消息不丢</h2><p>MQ 传递非常核心的消息，比如：广告计费系统，用户点击一次广告，扣费一块钱，如果扣费的时候消息丢了，则会不断少钱，积少成多，对公司是一个很大的损失。</p><h3 id="RabbitMQ可能存在的数据丢失问题">RabbitMQ可能存在的数据丢失问题</h3><p>Ack nack autoack</p><ol><li>生产者写消息的过程中，消息都没有到 rabbitmq，在网络传输过程中就丢了。或者消息到了 rabbitmq，但是人家内部出错了没保存下来。</li><li>RabbitMQ 接收到消息之后先暂存在主机的内存里，结果消费者还没来得及消费，RabbitMQ自己挂掉了，就导致暂存在内存里的数据给搞丢了。</li><li>消费者消费到了这个消费，但是还没来得及处理，自己就挂掉了，RabbitMQ 以为这个消费者已经处理完了。</li></ol><p>问题 1解决方案：事务机制：（一般不采用，同步的，生产者发送消息会同步阻塞卡住等待你是成功还是失败。会导致生产者发送消息的吞吐量降下来）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;发送消息</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    channel.txRollback;</span><br><span class="line">    &#x2F;&#x2F;再次重试发送这条消息</span><br><span class="line">&#125; </span><br><span class="line">    channel.txCommit;</span><br></pre></td></tr></table></figure><p>confirm机制：（一般采用这种机制，异步的模式，不会阻塞，吞吐量会比较高）</p><ol><li>先把 channel 设置成 confirm 模式</li><li>发送一个消息到 rabbitmq</li><li>发送完消息后就不用管了</li><li>rabbitmq 如果接收到了这条消息，就会回调你生产者本地的一个接口，通知你说这条消息我已经收到了</li><li>rabbitmq 如果在接收消息的时候报错了，就会回调你的接口，告诉你这个消息接收失败了，你可以再次重发。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void ack(String messageId)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void nack(String messageId)&#123;</span><br><span class="line">    &#x2F;&#x2F;再次重发一次这个消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题 2 解决方案：持久化到磁盘</p><ol><li><p>创建queue的时候将其设置为持久化的，这样就可以保证 rabbitmq持久化queue的元数据，但是不会持久化queue里的数据</p></li><li><p>发送消息的时候将 deliveryMode 设置为 2，将消息设置为持久化的，此时 rabbitmq就会将消息持久化到磁盘上去。必须同时设置 2 个持久化才行。</p></li><li><p>持久化可以跟生产者那边的 confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack了 ，所以哪怕是在持久化到磁盘之前 ，rabbitmq挂了，数据丢了，生产者收不到 ack，你也可以自己重发。</p><p>缺点：可能会有一点点丢失数据的可能，消息刚好写到了 rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧， rabbitmq挂了，会导致内存里的一点点数据会丢失。</p></li></ol><p>问题 3 解决方案：原因：消费者打开了 autoAck机制（消费到一条消息，还在处理中，还没处理完，此时消费者自动 autoAck了，通知 rabbitmq说这条消息已经消费了，此时不巧，消费者系统宕机了，那条消息丢失了，还没处理完，而且 rabbitmq还以为这个消息已经处理掉了）解决方案：关闭 autoAck, 自己处理完了一条消息后，再发送 ack给 rabbitmq, 如果此时还没处理完就宕机了，此时rabbitmq没收到你发的ack消息，然后 rabbitmq 就会将这条消息重新分配给其他的消费者去处理。</p><h2 id="消息队列重复数据">消息队列重复数据</h2><p>Idempotent</p><p>默认情况下就不会被重复消费，ack消息确认机制</p><pre><code>activemq会重试，重试6次1.你要保证调用方是幂等的。幂等：多次调用和一次调用结果一致（查询，更新2.程序不是幂等的，需要手动做一些操作：    1）维护一个map，在map中对消息进行记录，有内存泄露的风险    2）维护一张表（mysql,redis)：消息消费表        好处：即使你的 mq不可用，我也可以把源源不断发送过来的消息记录下来，等你的mq上线了，持续消费        来自于硬件的信息，接口文档中明确说明，接收信息后不能有太长的处理时间（解析，分类，存入数据库）        接收一条消息，立马发送到activemq进行后续处理        消息表记录每条消息的内容，消费状态    3）消息重试6次依然失败，会进入死信队列，等服务正常之后消费死信队列中的消息</code></pre><p>举例：例子哪里来呢？</p><pre><code>生产环境中会遇到的bug，异常情况</code></pre><h2 id="消息队列顺序性">消息队列顺序性</h2><p>背景：mysql binlog 同步的系统，在mysql里增删改一条数据，对应出来了增删改 3 条binlog，接着这 3 条binlog发送到 MQ 里面，到消费出来依次执行，起码是要保证顺序的吧，不然顺序变成了 删除、修改、增加。日同步数据达到上亿，mysql-&gt;mysql, 比如大数据 team，需要同步一个mysql库，来对公司的业务系统的数据做各种复杂的操作。场景：</p><ol><li>rabbitmq,一个queue,多个consumer，这不明显乱了</li></ol><h3 id="RabbitMQ-消息顺序错乱">RabbitMQ 消息顺序错乱</h3><p><img src="https://imgedu.lagou.com/dd26987914c5453eb08d6fa2bcb256bd.jpg" alt="img"></p><h3 id="如何保证消息顺序性">如何保证消息顺序性</h3><h4 id="activemq">activemq</h4><p>需要保证顺序的数据放到同一个queue里</p><p><img src="https://imgedu.lagou.com/e26e247047ab472597f70bd618de6b0f.jpg" alt="img"></p><p>1）通过高级特性consumer独有消费者（exclusive consumer）<br>queue = new ActiveMQQueue(“TEST. QUEUE?consumer.exclusive=true”);<br>consumer = session.createConsumer(queue);<br>上面的代码很明显是说如果是独占消费者，并且是循环里面的当前消费者，或者没有独占消费者。则循环里面的当前消费者即被选中能够消费该条消息。</p><p>2）利用Activemq的高级特性：messageGroups</p><p>Message Groups特性是一种负载均衡的机制。在一个消息被分发到consumer之前，broker首先检查消息JMSXGroupID属性。如果存在，那么broker会检查是否有某个consumer拥有这个message group。如果没有，那么broker会选择一个consumer，并将它关联到这个message group。此后，这个consumer会接收这个message group的所有消息，直到：</p><p>Consumer被关闭</p><p>Message group被关闭，通过发送一个消息，并设置这个消息的JMSXGroupSeq为-1</p><p>可以看到消费者实际上根据两个维度排序了，一个是消费者的Priority，即消费者的优先级。还有一个是消费者的指定的消息组的个数AssignedGroupCount。这个顺序直接影响到下一条小时是谁来接收。</p><h4 id="rabbitmq">rabbitmq</h4><p>首先我们可以确认的是，触发消息重复执行的条件会是很苛刻的！ 也就说 在大多数场景下不会触发该条件！！！ 一般出在任务超时，或者没有及时返回状态，引起任务重新入队列，重新消费！  在rabbtimq里连接的断开也会触发消息重新入队列。</p><p>消费任务类型最好要支持幂等性，这样的好处是 任务执行多少次都没关系，顶多消耗一些性能！ 如果不支持幂等，比如发送信息？ 那么需要构建一个map来记录任务的执行情况！ 不仅仅是成功和失败，还要有心跳！！！  这个map在消费端实现就可以了！！！   这里会出现一个问题，有两个消费者 c1, c2 ，一个任务有可能被c1消费，如果再来一次，被c2执行？ 那么如何得知任务的情况？ 任务派发！  任务做成hash，固定消费者！</p><p>坚决不要想方设法在mq扩展这个future。</p><p>一句话，要不保证消息幂等性，要不就用map记录任务状态.</p><blockquote><p>Section 4.7 of the AMQP 0-9-1 core specification explains the conditions under which ordering is guaranteed: messages published in one channel, passing through one exchange and one queue and one outgoing channel will be received in the same order that they were sent. RabbitMQ offers stronger guarantees since release 2.7.0.</p><p>Messages can be returned to the queue using AMQP methods that feature a requeue parameter (basic.recover, basic.reject and basic.nack), or due to a channel closing while holding unacknowledged messages. Any of these scenarios caused messages to be requeued at the back of the queue for RabbitMQ releases earlier than 2.7.0. From RabbitMQ release 2.7.0, messages are always held in the queue in publication order, <em>even in the presence of requeueing or channel closure.</em> (emphasis added)</p></blockquote><p>So, it is clear that RabbitMQ, from 2.7.0 onward, is making a rather drastic improvement over the original AMQP specification with regard to message ordering.</p><h1>MQ积压几百万条数据怎么办？</h1><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bde8fd9da7f56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复consumer的问题，让他恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p><p>一个消费者一秒是1000条，一秒3个消费者是3000条，一分钟是18万条，1000多万条</p><p>所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概1小时的时间才能恢复过来</p><p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：</p><ol><li>先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</li><li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</li><li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li></ol><p><strong>这里我们假设再来第二个坑</strong></p><p>假设你用的是rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在mq里，而是大量的数据会直接搞丢。</p><p>这个情况下，就不是说要增加consumer消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。</p><p>这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次</p><p><strong>然后我们再来假设第三个坑</strong></p><p>如果走的方式是消息积压在mq里，那么如果你很长时间都没处理掉，此时导致mq都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据！</p>]]></content>
      
      
      <categories>
          
          <category> ActiveMq </category>
          
          <category> RabbitMq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> repeat message </tag>
            
            <tag> lost messgae </tag>
            
            <tag> message order </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Message Queue Protocol</title>
      <link href="/2020/02/29/ampq/"/>
      <url>/2020/02/29/ampq/</url>
      
        <content type="html"><![CDATA[<p><strong>JMS：</strong></p><p>Java Message Service，Java消息服务应用程序接口，Java中定义的消息中间件服务的一个标准和API定义</p><p>JMS是Java平台上有关面向消息中间件（MOM）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。</p><p><strong>MQ：</strong></p><p>Message Queue，消息队列，是一种应用程序对应用程序的通信方法。</p><p>MQ是遵循AMQP协议的具体实现和产品。</p><p>生产者模型则是MQ的一个典型的代表，一端往消息队列中不断的写入消息，而另一端则可以读取或者订阅队列中的消息。</p><p><strong>JMS和MQ的关系：</strong></p><p>JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者，MQ的实现可以基于JMS，也可以基于其他规范或标准。</p><p><strong>What is ActiveMQ?</strong></p><p>Apache ActiveMQ is the most popular and powerful open source messaging and Integration Patterns server.</p><p>Apache ActiveMQ is fast, supports many Cross Language Clients and Protocols, comes with easy to use Enterprise Integration Patterns and many advanced features while fully supporting JMS 1.1 and J2EE 1.4. Apache ActiveMQ is released under the Apache 2.0 License</p><p><strong>What is RabbitMQ?</strong></p><p>·Robust messaging for applications</p><p>·Easy to use</p><p>·Runs on all major operating systems</p><p>·Supports a huge number of developer platforms</p><p>·Open source and commercially supported</p><h4 id="解耦">解耦</h4><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java0-1547173402.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java3-1547173402.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><p>面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p><h4 id="异步">异步</h4><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java10-1547173402.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p><p>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java9-1547173402.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><h4 id="削峰">削峰</h4><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java1-1547173402.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java8-1547173403.png" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><h3 id="消息队列有什么优缺点">消息队列有什么优缺点</h3><p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。</p><p>缺点有以下几个：</p><p>**1. 系统可用性降低<br>**系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？</p><p>**2. 系统复杂度提高<br>**硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p><p>**3. 一致性问题<br>**A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？">Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java10-1547173403.jpg" alt="面试题：Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；综上，各种对比之后，有如下建议：</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>]]></content>
      
      
      <categories>
          
          <category> ActiveMq </category>
          
          <category> RabbitMq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decoupling </tag>
            
            <tag> asynchronous </tag>
            
            <tag> Peak cliping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMS</title>
      <link href="/2020/02/29/jms/"/>
      <url>/2020/02/29/jms/</url>
      
        <content type="html"><![CDATA[<p><strong>JMS itself isn’t a message broker, just an API to an existing broker.</strong></p><p><img src="https://www.javatpoint.com/ejbpages/images/jms-publisher-subscriber-model.png" alt="jms point to point model"></p><p><img src="https://www.javatpoint.com/ejbpages/images/jms-point-to-point-model.png" alt="jms point to point model"></p><p><img src="https://www.javatpoint.com/ejbpages/images/jms-programming-model.png" alt="jms programming model"></p><ul><li>JMS</li></ul><p>JMS means Java Messaging Service. It is the new standard for inter client communication. It allows the J2EE application component to create, send, read and receive the messages.</p><ul><li><strong>What type of messaging is provided by JMS?</strong></li></ul><p>synchronous and asynchronous</p><ul><li><p><strong>What do you mean by Synchronous and Asynchronous type of messaging?</strong></p><p>Synchronous: In this type of messaging, client waits for the server to respond to a message. Ex: Telephone call, two way radio communication.</p><p>Asynchronous: In this type of messaging, client does not wait for a message from the server, but automatically an event is created to trigger a message from a server. Ex: email, text messaging, blog posting.</p></li><li><p><strong>How many types of messaging model do JMS provide for and what are they?</strong></p></li></ul><p>There are two types of messaging models that JMS provides –</p><p>Point to point queuing</p><p>Second one is publish and subscribe</p><ul><li><p><strong>Explain the difference between topic and queue?</strong></p><p>Queue technique is used for one to one messaging, and it supports point to point messaging. While topic is typically used for one to many messaging and it supports public subscribe model of messaging.</p></li><li><p><strong>What is the role of the JMS provider?</strong></p></li></ul><p>The JMS provider handles data conversion, security of the messages and the client triggering. It specifies the level of encryption, security level of the message and the best-data type for the non-JMS client.</p><ul><li><strong>What are the components of JMS?</strong></li></ul><p>JMS provide; client; Message:</p><ul><li><strong>Give an example of using point to point model in JMS?</strong></li></ul><p>Example for point to point model, would be a print out. When you select a print-out option, your system sends the message to the server, and once the print-out is taken out, again this server will send the message back to you. Point to point model is used, when the information is specific to a single client.</p><ul><li><p><strong>For JMS-enabled application, what are the core JMS-related objects required?</strong></p><ul><li>The core JMS-related objects that are required are –</li><li>The connection object</li><li>One or more sessions within a connection that provides a context for message sending and receiving.</li><li>A topic or queue object within a session representing the destination within the message broker.</li><li>Appropriate sender or publisher or receiver within a session.</li></ul></li><li><p><strong>What is JMS administered object?</strong></p><p>JMS administered object is a pre-configured JMS object that is created by an administrator for the use of JMS clients and placed in JNDI namespace</p></li><li><p><strong>What is the important part of JMS applications?</strong></p></li></ul><p>connection factory - &gt; connection -&gt; session -&gt; message , message producer, message consumer</p><ul><li><p><strong>What is JMS session?</strong></p><p>A JMS session is a single-threaded context for sending and receiving JMS messages. A JMS session could be a locally transacted, non-transacted or distributed transacted.</p></li><li><p><strong>Mention the difference between durable and non-durable subscription?</strong></p><p>Durable subscription gives a subscriber the freedom of receiving all messages from a topic, while a non-durable subscription does not make any guarantees about messages sent by others when a client get disconnected by others</p></li><li><p><strong>What is Byte Message?</strong></p></li></ul><p>Byte message is a stream of uninterrupted bytes. It contains an array of primitive bytes in its payload. For the transfer of data between two applications in their native format, byte message is used, which may be not possible with other message types.</p><ul><li><strong>Mention different types of messages available in JMS API?</strong></li></ul><p>The different types of messages available in JMS API are Message, TextMessage, BytesMessage, ObjectMessage and MapMessage.</p><ul><li><p><strong>What is the difference between the P2P (Peer to Peer) model and subscribe model?</strong></p><p>P2P model is highly reliable and it is used in a one-to-one situation, while subscribe model is used in one-to-many situation. It is very fast but less reliable.</p></li><li><p><strong>What is a JMS client?</strong></p><p>JMS client is a language program that sends or receives messages.</p></li><li><p><strong>Can we send e-mail messages using JMS?</strong></p><p>JMS has no inherent support for email operations.</p></li><li><p><strong>Explain how Application server handles the JMS Connection?</strong></p></li></ul><p>With the help of Application server, the server session is created and it stores them in a pool</p><p>To put messages in JMS session, connection consumer, uses the Server session</p><p>Server session is the one that creates the JMS session</p><p>Application written by Application programmers creates the message listener.</p><ul><li><strong>What is the difference between JMS and RPC (Remote Procedure Call)?</strong></li></ul><p>The basic difference between JMS and RPC lies in the way they message. JMS uses asynchronous messaging type while, RPC creates synchronous messaging type. The method invoker in RPC, waits for the method to finish execution and return back the control to the invoker. In JMS the message sender just sends the message to the destination and continues its own processing.</p><ul><li><p><strong>Explain how does the JMS work with the J2EE?</strong></p><p>The application client like enterprise JavaBeans components and web components can send or receive JMS message synchronously. In addition, the application clients can also receive message asynchronously. With the help of message-driven beans, JMS provider can optionally implement the processing of messages. Message-driven beans are a type of enterprise bean that enables the asynchronous consumption of messages.</p><p>The operation of sending and receiving message is carried out in distributed operation, which allows JMS operations and database accesses within a single transaction.</p></li><li><p><strong>What is MOM in reference to JMS?</strong></p><p>The MOM ( Message Oriented Middleware) is a software that works as an intermediate between two communicating components. It is placed between the client and server, MOM provides the facility of passing message by using the technique queuing. Until the client does not request to read the message, the messages will be stored in queue. By using this technique, the software component can work independently of time.</p></li><li><p><strong>How you can deliver a java message to a non-java client?</strong></p></li></ul><p>First of all, after receiving the message from Topic or Queue, the message has to be converted into a non-java client according to their specification. The message once converted to non-java client, it can be delivered.</p><ul><li><strong>For sending messages through JMS, what encryption options are there?</strong></li></ul><p>The encryption and decryption of the messages is handled by JMS provider and not JMS specifications. Sonic MQ by Progress Software is a leading JMS provider and they do encryption through encryption mechanisms called Quality of Protection.</p>]]></content>
      
      
      <categories>
          
          <category> JMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> queue </tag>
            
            <tag> topic </tag>
            
            <tag> asynchronous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File Reader</title>
      <link href="/2020/02/26/file-reader/"/>
      <url>/2020/02/26/file-reader/</url>
      
        <content type="html"><![CDATA[<p>Reader</p><p><code>Reader</code> 是Java的IO库提供的另一个输入流接口。和 <code>InputStream</code> 的区别是， <code>InputStream</code> 是一个字节流，即以 <code>byte</code> 为单位读取，而 <code>Reader</code> 是一个字符流，即以 <code>char</code> 为单位读取：</p><table><thead><tr><th style="text-align:left">InputStream</th><th style="text-align:left">Reader</th></tr></thead><tbody><tr><td style="text-align:left">字节流，以 <code>byte</code> 为单位</td><td style="text-align:left">字符流，以 <code>char</code> 为单位</td></tr><tr><td style="text-align:left">读取字节（-1，0~255）： <code>int read()</code></td><td style="text-align:left">读取字符（-1，0~65535）： <code>int read()</code></td></tr><tr><td style="text-align:left">读到字节数组： <code>int read(byte[] b)</code></td><td style="text-align:left">读到字符数组： <code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code> 是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int read() throws IOException;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的 <code>int</code> ，范围是 <code>0</code> ~ <code>65535</code> 。如果已读到末尾，返回 <code>-1</code> 。</p><p>FileReader</p><p><code>FileReader</code> 是 <code>Reader</code> 的一个子类，它可以打开文件并获取 <code>Reader</code> 。下面的代码演示了如何完整地读取一个 <code>FileReader</code> 的所有字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个FileReader对象:</span><br><span class="line">    Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;); &#x2F;&#x2F; 字符编码是???</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int n &#x3D; reader.read(); &#x2F;&#x2F; 反复调用read()方法，直到返回-1</span><br><span class="line">        if (n &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((char)n); &#x2F;&#x2F; 打印char</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); &#x2F;&#x2F; 关闭流</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为 <code>FileReader</code> 默认的编码与系统相关，例如，Windows系统的默认编码可能是 <code>GBK</code> ，打开一个 <code>UTF-8</code> 编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建 <code>FileReader</code> 时指定编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader &#x3D; new FileReader(&quot;src&#x2F;readme.txt&quot;, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> read </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图类算法入门</title>
      <link href="/2020/02/23/graph/"/>
      <url>/2020/02/23/graph/</url>
      
        <content type="html"><![CDATA[<p>在开始解析这道题之前，我们先对图的结构进行分类，在实际实现过程中，有以下几种基本的方式可以来表示图。</p><ul><li>邻接矩阵：对于较小或者中等规模的图的构造较为适用，因为需要V*V大小的空间。</li><li>邻接表数组, 较为常用，使用一个以顶点为索引的数组，数组每个元素都是和该顶点相邻的顶点列表，这种数组占空间相对于邻接矩阵少了很多，并且能很好的找到某个给定点的所有邻接点</li></ul><p>如下图所示</p><img src="/2020/02/23/graph/屏幕快照 2020-02-23 20.50.56.png" alt="屏幕快照 2020-02-23 20.50.56" style="zoom:50%; "><p>按照图中边的方向将图分成有向图和无向图：<br>1）无向图：图中的边没有方向。<br>2）有向图：图中的边有方向。</p><h4 id="图的遍历">图的遍历</h4><p>介绍两种基础且实用的图遍历算法，广度优先搜索和深度优先搜索。</p><h5 id="深度优先搜索">深度优先搜索</h5><p>这是一种典型的递归算法用来搜索图（遍历所有的顶点）；<br>思想：从图的某个顶点i开始，将顶点i标记为已访问顶点，并将访问顶点i的邻接列表中没有被标记的顶点j，将顶点j标记为已访问，并在访问顶点j的邻接列表中未被标记的顶点k依次深度遍历下去，直到某个点的所有邻接列表中的点都被标记为已访问后，返回上层。重复以上过程直到图中的所有顶点都被标记为已访问。</p><h5 id="广度优先搜索">广度优先搜索</h5><p>前面说过，深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示以及递归调用的性质，但是如果要求最短的路径（给定图G和起始点s寻找给定点v和s间是否存在路径，如果存在，找出最短的路径），那么使用前面的DFS算法并不能解决该问题，所以出现了广度优先搜索BFS来实现这个目的，广度优先搜索也是其他算法的基础。<br>在程序中，搜索一幅图的时候会遇到有很多条边都需要被遍历的情况，我们会选择其中一条并将其他边留到以后再继续搜索，在DFS中使用栈结构，使用LIFO的规则来描述，从有待搜索的通道中选取最晚遇到的那个通道，然而在BFS算法中，我们希望按照与起点的距离来遍历所有的顶点，使用FIFO（队列）来进行搜索，也就是搜索最先遇到的那个通道。<br>BFS: 使用一个队列来保存所有已经被标记过的但是其邻接点还未被检查过的顶点，现将顶点加入队列中，然后重复下面的操作，直至队列为空：<br>1）取队列中的下一个顶点v并标记它<br>2）将与v相邻的所有的未被标记的顶点加入队列中。</p><p>广度优先搜索类似于树的按层遍历</p><h4 id="例子">例子</h4><img src="/2020/02/23/graph/屏幕快照 2020-02-23 19.38.34.png" alt="屏幕快照 2020-02-23 19.38.34" style="zoom:50%; "><p>深度优先遍历结果是： A B E F C D G H I</p><blockquote><p>深度优先遍历尽可能优先往深层次进行搜索</p></blockquote><img src="/2020/02/23/graph/屏幕快照 2020-02-23 19.41.25.png" alt="屏幕快照 2020-02-23 19.41.25" style="zoom:50%; "><p>广度优先遍历结果是： A B C D E F G H I</p><blockquote><p>广度优先遍历按层次优先搜索最近的结点，一层一层往外搜索。</p></blockquote><p>通过以上的描述然后我们来找两道题练习实践一下这两个算法。我选了两个有代表性的题目，分别是leetcode200 island 和 207 course schedule。</p><h3 id="Leetcode-200-Island-题目描述">Leetcode 200 Island 题目描述</h3><p>Given a 2d grid map of '1’s (land) and '0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>Input:<br>11110<br>11010<br>11000<br>00000</p><p>Output: 1<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Example 2:</p><p>Input:<br>11000<br>11000<br>00100<br>00011</p><p>Output: 3</p><h3 id="题目概括">题目概括</h3><p>给了一个二维数组，其中0表示水，1表示陆地，问一共有几个小岛？小岛的意思就是横向和竖向是水，没有陆地</p><h4 id="解题思路">解题思路</h4><p>做法是，我们对每个有“1&quot;的位置进行dfs，把和它四联通的位置全部变成“0”，这样就能把一个点推广到一个岛。</p><p>所以，我们总的进行了dfs的次数，就是总过有多少个岛的数目。</p><p>注意理解dfs函数的意义：已知当前是1，把它周围相邻的所有1全部转成0.</p><h5 id="如何记录遍历过的点">如何记录遍历过的点</h5><p>这里大体上有两个方法，我们可以建一个boolean的二维数组，true代表访问过，false代表未访问。这样比较好想，而且保护了原有的数组，但是需要我们另外开辟空间。本题我们可以将访问过的点，直接设置为水，这样还可以省去不少的判断。</p><h5 id="实现点的移动">实现点的移动</h5><p>这里实现的方法有很多，核心思想就是以原点为中心向上下左右四个位置扩散，所以我是新建了一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final static int[][] dirs &#x3D; &#123; &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此即可让点一次以左上右下的顺序移动</p><h5 id="如何实现递归">如何实现递归</h5><p>dfs可以用迭代的方式用stack实现，但是递归写法更简便容易理解，与树相同，优先考虑递归。我写递归一般就是分为两部，第一步是corner case就是何时return，第二部就是base case 正常情况下的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int[] dir : dirs) &#123;</span><br><span class="line">int x &#x3D; dir[0] + i;</span><br><span class="line">int y &#x3D; dir[1] + j;</span><br><span class="line">dfs(grid, x, y, xrows, yrows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现">具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DFS</span><br><span class="line">final static int[][] dirs &#x3D; &#123; &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (grid &#x3D;&#x3D; null || grid.length &#x3D;&#x3D; 0 || grid[0].length &#x3D;&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">final int xrows &#x3D; grid.length;</span><br><span class="line">final int yrows &#x3D; grid[0].length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; grid.length; i++)</span><br><span class="line">for (int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">dfs(grid, i, j, xrows, yrows);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs(char[][] grid, int i, int j, int xrows, int yrows) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; xrows || j &gt;&#x3D; yrows || grid[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; base case</span><br><span class="line">grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">for (int[] dir : dirs) &#123;</span><br><span class="line">int x &#x3D; dir[0] + i;</span><br><span class="line">int y &#x3D; dir[1] + j;</span><br><span class="line">dfs(grid, x, y, xrows, yrows);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode-207-course-schedule-题目描述">Leetcode 207 course schedule 题目描述</h3><h4 id="题目描述：">题目描述：</h4><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0, 1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><h4 id="题目大意">题目大意</h4><p>课程表上有一些课，是必须有修学分的先后顺序的，必须要求在上完某些课的情况下才能上下一门。问是否有方案修完所有的课程？</p><h4 id="解题思路-2">解题思路</h4><p>这个题本质上是一个判断一张图是否为有向无环图（DAG）的题目Directed acyclic graph</p><p>如果一个有向图中从任意点出发都不能回到该点的话，这张图就是一个有向无环图<br>课程就表示图中的点，而前置课程的关系则表示了图中的有向边。需要特别注意的是，完成事件A才能继续完成事件B，这样的关系我们通常表示为<strong>A-&gt;B</strong>；但是在题目中，要先完成课程1才能完成课程0，这个关系被表示为了 <code>[0, 1]</code> ，所以在代码中构造图的信息时，需要留意。</p><h5 id="存储每门课程的先决条件">存储每门课程的先决条件</h5><p>对于这个一一对应的问题，很快我们可以想到用hashmap，key存储课程编号，value存储次课程需要的先决条件。但是hashmap本身已经是高级数据结构，这个题目我们可以采用一维数组就完全够了。对prerequisites遍历一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">pres[prerequisites[i][0]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分层遍历-bfs">分层遍历 bfs</h5><p>一提到分层，level traversal我们就可以想到队列了，先进先出，问题是我们需要先对队列进行初始化，就是把不需要预备课程的科目先加入到队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; pres.length; i++) &#123;</span><br><span class="line">if (pres[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何判断是否完成所有课程">如何判断是否完成所有课程</h5><p>这里就是一个循序渐尖的思想，首先我们先从队列中取出一个不需要预备课程的科目，记录下他的id，然后遍历所有的条件，若存在需要改课程的科目，则对其需要的预备课程数目-1，若结果为0，则说明已达标，可继续学习，否则继续遍历。看看最后能学习的课程数量与总课程数量是否相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 查看哪一个课程的必要条件是此刻课程</span><br><span class="line">if (prerequisites[i][1] &#x3D;&#x3D; top) &#123;</span><br><span class="line">pres[prerequisites[i][0]]--;</span><br><span class="line">if (pres[prerequisites[i][0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">numNoPre++;</span><br><span class="line">queue.add(prerequisites[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现-2">具体实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; method1 BFS</span><br><span class="line">public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">&#x2F;&#x2F; corner case</span><br><span class="line">if (prerequisites &#x3D;&#x3D; null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (numCourses &lt; 0 || prerequisites.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录每个course的prerequisites的数量</span><br><span class="line">int[] pres &#x3D; new int[numCourses];</span><br><span class="line">int len &#x3D; prerequisites.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">pres[prerequisites[i][0]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; record the direct course by queue</span><br><span class="line">Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; pres.length; i++) &#123;</span><br><span class="line">if (pres[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 取出队列的course，判断</span><br><span class="line">int numNoPre &#x3D; queue.size();</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">int top &#x3D; queue.poll();</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 查看哪一个课程的必要条件是此刻课程</span><br><span class="line">if (prerequisites[i][1] &#x3D;&#x3D; top) &#123;</span><br><span class="line">pres[prerequisites[i][0]]--;</span><br><span class="line">if (pres[prerequisites[i][0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">numNoPre++;</span><br><span class="line">queue.add(prerequisites[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断可完成课程书是否等于课程总数</span><br><span class="line">return numNoPre &#x3D;&#x3D; numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>树和图的题目，因为不是顺向思维，我天资愚钝，一直是我的弱项，所以最近在花时间读书和做题提高一下理解。可以说树和图实际上想通的，因为树本身就是一个有方向无环图。所以树的遍历算法和思想也可以应用到图上，之后会写一下深度优先遍历和树遍历inroder，preorder，postorder区别和联系</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat刨析</title>
      <link href="/2020/02/17/tomcat/"/>
      <url>/2020/02/17/tomcat/</url>
      
        <content type="html"><![CDATA[<p>Tomcat:</p><ul><li>1 modify tomcat port</li></ul><ol><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; </span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot; </span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>how many method to connect tomcats?</li></ul><p>bio blocking i/o 同步阻塞</p><p>nio <strong>同步阻塞或同步非阻塞IO</strong></p><p>aio(nio.2): <strong>JDK7开始支持，异步非阻塞IO</strong></p><p>apr(apache portable runtime): Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 <strong>提高Tomcat对静态文件的处理性能</strong></p><h2 id="Tomcat有几种部署方式">Tomcat有几种部署方式</h2><ol><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置``节点，设置相关的属性即可</li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ol><h2 id="Tomcat有几种部署方式-2">Tomcat有几种部署方式</h2><ol><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置``节点，设置相关的属性即可</li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ol><h2 id="部署方式第二点：">部署方式第二点：</h2><ul><li>在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-4bf007b65aa9ed8d5cb9508ee064674e_hd.jpg" alt="img"></p><ul><li>找到Tomcat目录下/conf/server.xml文件</li></ul><p><img src="https://pic3.zhimg.com/80/v2-44643fbf206dacfee7debbfdb24ce08a_hd.jpg" alt="img"></p><ul><li>在server.xml中的节点下添加如下代码。<strong>path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;web1&quot; docBase&#x3D;&quot;D:\web1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-660c2e9f1bf3f36736234a7e139e2543_hd.jpg" alt="img"></p><ul><li>访问配置好的web站点</li></ul><p><img src="https://pic3.zhimg.com/80/v2-b2a5a2a2af98b4057c818cc8b4ee711a_hd.jpg" alt="img"></p><h2 id="部署方式第三点：">部署方式第三点：</h2><ul><li>进入到conf\Catalina\localhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字。</strong></li></ul><p><img src="https://pic3.zhimg.com/80/v2-39eeec1d1d3a5109f6b746f62b357a12_hd.jpg" alt="img"></p><ul><li>xml文件的代码如下，<strong>docBase是你web站点的绝对路径</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;Context </span><br><span class="line">    docBase&#x3D;&quot;D:\web1&quot; </span><br><span class="line">    reloadable&#x3D;&quot;true&quot;&gt; </span><br><span class="line">&lt;&#x2F;Context&gt;</span><br></pre></td></tr></table></figure><ul><li>访问web站点下的html资源</li></ul><p><img src="https://pic1.zhimg.com/80/v2-31ff7b7871c2354b783043371075e07c_hd.jpg" alt="img"></p><h2 id="Servlet面试题">Servlet面试题</h2><h2 id="Servlet生命周期">Servlet生命周期</h2><blockquote><p>Servlet生命周期?</p></blockquote><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。</strong></li></ul><h2 id="get方式和post方式有何区别">get方式和post方式有何区别</h2><ul><li><p>GET方式一般用来获取数据</p></li><li><p>POST方式一般用来提交数据</p></li><li><ul><li>原因:</li></ul><ul><li><ul><li>首先是因为GET方式携带的数据量比较小，无法带过去很大的数量</li><li>POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决)</li><li>GET方式比POST方式要快</li></ul></li></ul></li></ul><h2 id="Servlet相关-API">Servlet相关 API</h2><blockquote><p>doGet与doPost方法的两个参数是什么</p></blockquote><ol><li>HttpServletRequest：封装了与请求相关的信息</li><li>HttpServletResponse：封装了与响应相关的信息</li></ol><blockquote><p>获取页面的元素的值有几种方式，分别说一下</p></blockquote><ol><li>request.getParameter() 返回客户端的请求参数的值</li><li>request.getParameterNames() 返回所有可用属性名的枚举</li><li>request.getParameterValues() 返回包含参数的所有值的数组</li></ol><blockquote><p>request.getAttribute()和request.getParameter()区别</p></blockquote><p>用途上:</p><ul><li>request.getAttribute()， <strong>一般用于获取request域对象的数据</strong>(在跳转之前把数据使用setAttribute来放到request对象上)</li><li>request.getParameter()， <strong>一般用于获取客户端提交的参数</strong></li></ul><p>存储数据上:</p><ul><li>request.getAttribute()可以获取Objcet对象</li><li>request.getParameter()只能获取字符串(这也是为什么它一般用于获取客户端提交的参数)</li></ul><h2 id="forward和redirect的区别">forward和redirect的区别</h2><blockquote><p>forward和redirect的区别</p></blockquote><p>forward is server</p><p>redirect is navigator</p><h2 id="tomcat容器是如何创建servlet类实例？用到了什么原理？">tomcat容器是如何创建servlet类实例？用到了什么原理？</h2><blockquote><p>tomcat容器是如何创建servlet类实例？用到了什么原理</p></blockquote><ol><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 <strong>xml文件进行解析，并读取servlet注册信息</strong>。然后，将每个应用中注册的servlet类都进行加载，并通过 <strong>反射的方式实例化</strong>。（有时候也是在第一次请求时实例化）</li><li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ol><h2 id="Servlet安全性问题">Servlet安全性问题</h2><p>由于Servlet是单例的，当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。</p><p>原则：</p><ol><li><p>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></p></li><li><p>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</p><h3 id="Tomcat顶层架构小结：">Tomcat顶层架构小结：</h3></li></ol><p>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；</p><p>（2） Server掌管着整个Tomcat的生死大权；</p><p>（4）Service 是对外提供服务的；</p><p>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；</p><p>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p><h3 id="connector-and-container">connector and container</h3><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议</p><h3 id="Connector架构分析">Connector架构分析</h3><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>我们可以把Connector分为四个方面进行理解：</p><p>（1）Connector如何接受请求的？</p><p>（2）如何将请求封装成Request和Response的？</p><p>（3）封装完之后的Request和Response如何交给Container进行处理的？</p><p>（4）Container处理完之后如何交给Connector并返回给客户端的？</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/03/java6-1553178913.png" alt="Tomcat相关面试题，看这篇就够了！"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><p>Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理</p><p>Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p><p>Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p><h3 id="Container架构分析">Container架构分析</h3><h3 id></h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/03/java1-1553178914.png" alt="Tomcat相关面试题，看这篇就够了！"></p><p>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p><p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p><p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</p><p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p>]]></content>
      
      
      <categories>
          
          <category> Webservice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> connector </tag>
            
            <tag> container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中BIO, NIO, AIO的理解</title>
      <link href="/2020/02/17/bionioaio/"/>
      <url>/2020/02/17/bionioaio/</url>
      
        <content type="html"><![CDATA[<p>在高能的IO体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下：</p><p>1 什么是同步？<br>2 什么是异步？<br>3 什么是阻塞？<br>4 什么是非阻塞？<br>5 什么是同步阻塞？<br>6 什么是同步非阻塞？<br>7 什么是异步阻塞？<br>8 什么是异步非阻塞？</p><p>先来举个实例生活中的例子：</p><p>如果你想吃一份宫保鸡丁盖饭：</p><p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！</p><p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！</p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。</p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><p>在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。</p><p>1, 同步和异步是针对应用程序和内核的交互而言的。</p><p>2, 阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p><p>由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。</p><ol><li>同步：指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。</li><li>异步：异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）</li><li>阻塞：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读, 或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）</li><li>非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。</li></ol><p>一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。</p><p>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。<br>阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p><p>同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br>所以, IO操作可以分为3类：同步阻塞（即早期的BIO操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。</p><p>同步阻塞(BIO)：<br>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。<br>同步非阻塞(NIO)：<br>在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。<br>异步非阻塞(AIO)：</p><p>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>同步阻塞IO（JAVA BIO）：<br>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>同步非阻塞IO(Java NIO)：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。</p><p>异步阻塞IO（Java NIO）：<br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！</p><p>（Java AIO(NIO.2)）异步非阻塞IO:<br>在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。</p><p>BIO、NIO、AIO适用场景分析:</p><pre><code>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Webservice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nio </tag>
            
            <tag> bio </tag>
            
            <tag> aio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JBoss 面试高频</title>
      <link href="/2020/02/17/jboss/"/>
      <url>/2020/02/17/jboss/</url>
      
        <content type="html"><![CDATA[<p><strong>Q1. What is JBOSS?</strong><br>JBoss is a popular open source application server based on JEE technology. Being JEE based, the JBoss supports cross-platform java applications. It was embedded with Apache Tomcat web server. It runs under any JVM of 1.3 or later versions. JBoss supports JNDI, Servlet/JSP (Tomcat or Jetty), EJB, JTS/JTA, JCA, JMS, Clustering (JavaGroups), Web Services (Axis), and IIOP integration (JacORB).</p><p><strong>What’s the difference between Standalone mode and Domain mode ?</strong><br>When configured in Standalone mode each distribution starts a single JVM process with its own configuration, management instruments and deployments. When configured in Domain mode, multiple servers are managed from a centralized point called Domain Controller which maintain the configuration and provisions applications for deployment on the single nodes which are part of the Domain</p><p><strong>What do you need to set-up a cluster with JBoss ?</strong><br>Basically starting JBoss with the “all” configuration contains everything needed for clustering:<br>It has all the libraries for clustering:<br>JGroups.jar, jboss-cache.jar<br>Clustered beans (cluster-service.xml)<br>HA-JNDI<br>HTTP session replications (tc5-cluster-service.xml)<br>Farming<br>HA-JMS</p><p><strong>. How do you monitor JBoss and detect the bottleneck of an application?</strong><br>Different components of the application are to be measured. This step is to find where the degradation is, whether it is external or internal and where is the appliciation spending all the time. Using Joss JMX agents and monitoring the deployed components to the application server involves in the first step.<br>After finding the most of the time spent by specific components or libraries or most of the resources, one can use Jprobe a specialized tool for examining the single object or the objects loaded in the memory.</p><p><strong>Does Seam run on other application servers besides JBoss ?</strong><br>Seam(jboss 3) runs beautifully on other application servers – just like everything else the Hibernate team does, this is not a JBoss-only thing.</p><p><strong>Which Hibernate object wraps the JDBC Connection?</strong><br>The Session interface wraps a JDBC Connection. This interface is a single threaded object which represents a single unit of work with application and persistent database. It’s retrieved by the SessionFactory’s openSession() method</p><p><strong>How can you start a JTA transaction from a Servlet deployed on JBoss?</strong><br>JBoss registers in the JNDI tree a JTA UserTransaction Object which can be user to manage a distributed transaction.</p><h3 id="What’s-the-default-port-to-access-Administration-Console-in-JBoss-7">What’s the default port to access Administration Console in JBoss 7?</h3><p>9990 is the default port. If it’s installed on <strong>server1</strong> then you need to access like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;server1:9990&#x2F;admin-console</span><br></pre></td></tr></table></figure><h3 id="Which-component-is-responsible-for-handling-clustering">Which component is responsible for handling clustering?</h3><p>JBoss clustering is on top of JGroups toolkit which helps to create, delete, membership detection, notification, <a href="http://etc.in" target="_blank" rel="noopener">etc.in</a> the cluster.</p><h3 id="What-is-difference-between-validate-on-match-and-background-validation">What is difference between <validate-on-match> and <background-validation>?</background-validation></validate-on-match></h3><p>&lt;<strong>validate-on-match</strong>&gt; validate the database connection every time, and if a connection is not valid, it will write a warning in the logs.</p><p>Having “validate-on-match” configured may have a little high load on the database as it may create lots of requests.</p><p>&lt;<strong>background-validation</strong>&gt; validate the connection periodically based on what frequency is configured for “background-validation-millis”. The default configuration is set to zero means disabled.</p><p>Having “ background-validation” set to true will create fewer database connections and it’s side-effects would be not detecting immediately if dead connections.</p><h3 id="What-are-the-file-types-you-can-deploy-in-JBoss">What are the file types you can deploy in JBoss?</h3><p>You can deploy almost any kind of Java/J2EE application, and it supports the following file format.</p><ul><li>WAR – Web application archive</li><li>SAR – Service archive</li><li>JAR – Java Archive</li><li>EAR – Enterprise application archive</li></ul><h3 id="How-can-you-deploy-an-application">How can you deploy an application?</h3><p>There are three possible ways to deploy an application in JBoss application server.</p><ol><li>Admin Console – you can deploy the necessary application files through the administration console.</li><li>Auto-deploy – leverage file system deployment scanner to auto deploy files from deployments folder.</li><li>Automation – use automation tool/ant/scripting to deploy an application.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Webservice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Serverlet </tag>
            
            <tag> Jboss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session，cookie和token究竟是什么</title>
      <link href="/2020/02/17/sessionCookieToken/"/>
      <url>/2020/02/17/sessionCookieToken/</url>
      
        <content type="html"><![CDATA[<h2 id="简述">简述</h2><p>我在写之前看了很多篇session，cookie的文章，有的人说先有了cookie，后有了session。也有人说先有session，后有cookie。感觉都没有讲的很清楚，泛泛而谈。希望本篇文章对大家有所帮助<br>注：本文需要读者有cookie，session，token的相关基础知识。</p><h2 id="http是一个无状态协议">http是一个无状态协议</h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把 <code>www.zhihu.com/login.html</code> 和 <code>www.zhihu.com/index.html</code> 关联起来，必须使用某些手段和工具</p><h2 id="cookie和session">cookie和session</h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">Cookie详解</a></li></ul><p><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></p><ul><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src="https://segmentfault.com/img/bVbmYbQ?w=400&amp;h=200" alt="请求流程"></p><h3 id="注意">注意</h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="小结">小结</h3><p><strong>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</strong></p><h2 id="oken">oken</h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><h3 id="组成">组成</h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放">存放</h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><h3 id="token认证流程">token认证流程</h3><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h2 id="token可以抵抗csrf-cross-site-request-forgrey-，cookie-session不行">token可以抵抗csrf(cross site request forgrey)，cookie+session不行</h2><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为 <code>http://www.bank.com/api/transfer</code> ，body为 <code>count=1000&amp;to=Tom</code> 。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了. 因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做[JWT(Json Web Token)](<a href="https://huanqiang.wang/2017/12/28/JWT" target="_blank" rel="noopener">https://huanqiang.wang/2017/12/28/JWT</a> 介绍/)</li></ul><h2 id="总结">总结</h2><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul>]]></content>
      
      
      <categories>
          
          <category> Webservice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exception处理</title>
      <link href="/2020/02/16/exceptionChec-k/"/>
      <url>/2020/02/16/exceptionChec-k/</url>
      
        <content type="html"><![CDATA[<p>Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。</p><p>error表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。</p><p>exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题</p><ul><li>先来看看java中异常的体系结构图解</li></ul><img src="/2020/02/16/exceptionChec-k/屏幕快照 2020-02-16 20.07.13.png" alt="屏幕快照 2020-02-16 20.07.13" style="zoom:50%; "><p>首先说明一点，java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。</p><p><strong>运行时异常和非运行时异常</strong><br>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择在运行时捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>CheckedException成为编译时异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><p><strong>Java中异常处理机制的原理</strong></p><p>Java通过面向对象的方式对异常进行处理，Java把异常按照不同的类型进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它都是Throwable</p><p>或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java的</p><p>异常处理是通过5个关键词来实现的：try catch  throw throws finally。</p><p>一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws），我们可以通过它的类型来捕捉它，或最后由缺省处理器来处理它（finally）。</p><p>try：用来指定一块预防所有异常的程序</p><p>catch：紧跟在try后面，用来捕获异常</p><p>throw：用来明确的抛出一个异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; throw </span><br><span class="line">public class throwException &#123;</span><br><span class="line">static void checkAge(int age) &#123;</span><br><span class="line">if (age &lt; 18) &#123;</span><br><span class="line">throw new ArithmeticException(&quot;Access denied - You must be at least 18 years old.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Access granted - You are old enough!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">checkAge(15); &#x2F;&#x2F; Set age to 15 (which is below 18...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws：用来标明一个成员函数可能抛出的各种异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)throws InterruptedException </span><br><span class="line">    &#123; </span><br><span class="line">        Thread.sleep(100); </span><br><span class="line">        System.out.println(&quot;Hello Geeks&quot;); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</p><p><strong>final、finally、finalize的区别</strong></p><p>（1）、final用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承</p><p>（2）、finally是异常处理中的一个关键字，表示finally{}里面的代码一定要执行</p><p>（3）、finalize是Object类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</p><p><strong>try()里面有一个return语句，那么后面的finally{}里面的code会不会被执行，什么时候执行，是在return前还是return后？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">int a &#x3D; 1 &#x2F; 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3</p><p><strong>请写出你最常见的5个RuntimeException</strong></p><p>NullPointer;</p><p>ClassNotFound;</p><p>IndexOutOfBounds;</p><p>ClassCast; NoClassDef;</p><p>IllgealArgument;</p><p>NumberFormat;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Throwable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> try catch finally </tag>
            
            <tag> Error </tag>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 浅谈多线程的通讯方式</title>
      <link href="/2020/02/16/mutlithread/"/>
      <url>/2020/02/16/mutlithread/</url>
      
        <content type="html"><![CDATA[<p>今天在群里面看到一个很有意思的面试题：<br>“编写两个线程，一个线程打印1~25，另一个线程打印字母A~Z，打印顺序为12A34B56C……5152Z，要求使用线程间的通信。”</p><p>这是一道非常好的面试题，非常能彰显被面者关于多线程的功力，一下子就勾起了我的兴趣</p><p>首先我们先有一个helper类：含有两个固定的线程</p><p>此类单例模式生明一个instance</p><p>分别写两个简单的方法，一个生成数字从一到52，另一个生成字母从a到z</p><p>线程提交和终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package MultiThread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class Helper &#123;</span><br><span class="line"></span><br><span class="line">private Helper() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Helper helper &#x3D; new Helper();</span><br><span class="line"></span><br><span class="line">public static Helper getInstance() &#123;</span><br><span class="line">return helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final ExecutorService tPool &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">public static String[] buildNoArr(int max) &#123;</span><br><span class="line">String[] noArr &#x3D; new String[max];</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">noArr[i] &#x3D; Integer.toString(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">return noArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String[] buildCharArr(int max) &#123;</span><br><span class="line">String[] charArr &#x3D; new String[max];</span><br><span class="line">int tmp &#x3D; 65;</span><br><span class="line">for (int i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">charArr[i] &#x3D; String.valueOf((char) (tmp + i));</span><br><span class="line">&#125;</span><br><span class="line">return charArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print(String... input) &#123;</span><br><span class="line">if (input &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">for (String each : input) &#123;</span><br><span class="line">System.out.print(each);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(Runnable r) &#123;</span><br><span class="line">tPool.submit(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">tPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法1-一个变量threadToGo-value共享控制">解法1 一个变量threadToGo.value共享控制</h4><p>创建一个final类 , 包含一个变量value，首先启动线程A，给threadgo加上一个同步锁，打印数字，然后发送notice给threadB，此时value值为2，暂停threadA，输出字母，value值恢复为1，周而复始知道达到threadA和B的终止条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class ThreadToGo &#123;</span><br><span class="line">int value &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 2)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">threadToGo.value &#x3D; 2;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">synchronized (threadToGo) &#123;</span><br><span class="line">while (threadToGo.value &#x3D;&#x3D; 1)</span><br><span class="line">threadToGo.wait();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">threadToGo.value &#x3D; 1;</span><br><span class="line">threadToGo.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">System.out.println(&quot;Oops...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二-利用-Lock-和-Condition-：">解法二 利用 <code>Lock</code> 和 <code>Condition</code> ：</h4><p>整体来讲与解法1相同, 共享一个变量value，新建一个lock和condition，通过try catch finally 给value上锁然后完成线程之间的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line">private Condition condition &#x3D; lock.newCondition();</span><br><span class="line">private static int value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 2)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">value &#x3D; 2;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">while (value &#x3D;&#x3D; 1)</span><br><span class="line">condition.await();</span><br><span class="line">Helper.print(arr[i]);</span><br><span class="line">value &#x3D; 1;</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法三-volatile">解法三 volatile</h4><p><code>volatile</code> 能保证所修饰的变量对于多个线程可见性，即只要被修改，其它线程读到的一定是最新的值。写法很是巧妙，需要我们理解volatile，是对在内存中的线程排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private volatile ThreadToGo threadToGo &#x3D; new ThreadToGo();</span><br><span class="line">    class ThreadToGo &#123;</span><br><span class="line">        int value &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.value&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.value&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.value&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法四-利用-AtomicInteger-：">解法四 利用 <code>AtomicInteger</code> ：</h4><p>和volatile大致相同，利用起本身的同步特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger threadToGo &#x3D; new AtomicInteger(1);</span><br><span class="line">    public Runnable newThreadOne() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i&#x3D;i+2) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;2)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i], arr[i + 1]);</span><br><span class="line">                    threadToGo.set(2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Runnable newThreadTwo() &#123;</span><br><span class="line">        final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">        return new Runnable() &#123;</span><br><span class="line">            private String[] arr &#x3D; inputArr;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    while(threadToGo.get()&#x3D;&#x3D;1)&#123;&#125;</span><br><span class="line">                    Helper.print(arr[i]);</span><br><span class="line">                    threadToGo.set(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法五-CyclicBarrier-API">解法五 <code>CyclicBarrier</code> API</h4><p><code>CyclicBarrier</code> 可以实现让一组线程在全部到达 <code>Barrier</code> 时(执行 <code>await()</code> )，再一起同时执行，并且所有线程释放后，还能复用它, 即为Cyclic。<br><code>CyclicBarrier</code> 类提供两个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure><p><strong>这里多说一点，这个API其实还是利用</strong><code>lock</code><strong>和</strong><code>condition</code><strong>，无非是多个线程去争抢</strong><code>CyclicBarrier</code><strong>的instance的lock罢了，最终barrierAction执行时，是在抢到</strong><code>CyclicBarrier</code><strong>instance的那个线程上执行的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private final CyclicBarrier barrier;</span><br><span class="line">private final List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">public MethodSix() &#123;</span><br><span class="line">list &#x3D; Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">barrier &#x3D; new CyclicBarrier(2, newBarrierAction());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadOne() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildNoArr(52);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i &#x3D; i + 2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">list.add(arr[i + 1]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Runnable newThreadTwo() &#123;</span><br><span class="line">final String[] inputArr &#x3D; Helper.buildCharArr(26);</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">private String[] arr &#x3D; inputArr;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">list.add(arr[i]);</span><br><span class="line">barrier.await();</span><br><span class="line">&#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Runnable newBarrierAction() &#123;</span><br><span class="line">return new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">Collections.sort(list);</span><br><span class="line">list.forEach(c -&gt; System.out.print(c));</span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conclusion">conclusion</h4><p>多线程高并发是java语言中的一大特性，学生时代的我对其理解的太微不足道，也是通过工作后看到大神写的代码，改bug，还有兴趣的阅读才一点点发现其奥妙。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> Multithread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lock condition </tag>
            
            <tag> sychronise wait </tag>
            
            <tag> atomic </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>design_pattern</title>
      <link href="/2020/02/16/design-pattern/"/>
      <url>/2020/02/16/design-pattern/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式 singlenton</title>
      <link href="/2020/02/16/singleton/"/>
      <url>/2020/02/16/singleton/</url>
      
        <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。既然即使是一个初级的程序员，也会使用单例模式了，为什么我们还要在这里特意地讨论它，并且作为第一个模式来分析呢？事实上在我看来，单例模式是很有“深度”的一个模式，要用好、用对它并不是一件简单的事</p><h5 id="定义">定义:</h5><p>确保这个类在内存中只会存在一个对象, 而且自行实例化并向整个系统提供这个实例;</p><h5 id="场景">场景:</h5><p>产生某对象会消耗过多的资源，为避免频繁地创建与销毁对象对资源的浪费</p><blockquote><p>对数据库的操作、访问 IO、线程池（threadpool）、网络请求等。</p></blockquote><p>某种类型的对象应该有且只有一个。如果制造出多个这样的实例，可能导致：程序行为异常、资源使用过量、结果不一致等问题。如果多人能同时操作一个文件，又不进行版本管理，必然会有的修改被覆盖</p><blockquote><p>一个系统只能有：一个窗口管理器或文件系统，计时工具或 ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。</p></blockquote><h5 id="步骤：">步骤：</h5><ul><li>仅自己可以创建，构造函数私有化</li><li>创建一个实例</li><li>getInstance 考虑加锁同步问题</li></ul><h4 id="单列模式的几种基本写法">单列模式的几种基本写法:</h4><h5 id="饿汉式">饿汉式</h5><p>不需要的时候就加载了, 造成资源浪费.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonHungry() &#123;</span><br><span class="line">System.out.println(&quot;hello Singlenton Hungry&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonHungry hungry;</span><br><span class="line"></span><br><span class="line">public static synchronized SinglentonHungry getInstanceHungry() &#123;</span><br><span class="line">if (hungry &#x3D;&#x3D; null) &#123;</span><br><span class="line">hungry &#x3D; new SinglentonHungry();</span><br><span class="line">&#125;</span><br><span class="line">return hungry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonHungry.getInstanceHungry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式">懒汉式</h5><p>懒汉式缺点: 效率低，第一次加载需要实例化，反应稍慢。每次调用getInstance方法都会进行同步，消耗不必要的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private SinglentonLazy() &#123;</span><br><span class="line">System.out.println(&quot;hello lazy singlenton&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SinglentonLazy lazy &#x3D; new SinglentonLazy();</span><br><span class="line"></span><br><span class="line">public static SinglentonLazy getInstanceLazy() &#123;</span><br><span class="line">return lazy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonLazy ss &#x3D; SinglentonLazy.getInstanceLazy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的两种是最常见的, 顾名思义懒汉式和饿汉式, 一个是拿时间换空间, 一个是拿空间换时间, 懒汉式只有我需要他的时候才去加载它, 懒加载机制, 饿汉式不管需不需要我先加载了再说, 先在内存中开辟一块空间, 占用一块地方, 等用到了直接就拿来用. 这两种是最基本的单列模式。</p><h5 id="双重检查单列-double-check-locking">双重检查单列 double check locking</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonDCL &#123;</span><br><span class="line"></span><br><span class="line">private SinglentonDCL() &#123;</span><br><span class="line">System.out.println(&quot;hello singlenton dcl&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile static SinglentonDCL dcl;</span><br><span class="line"></span><br><span class="line">public static SinglentonDCL getInstanceDcl() &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized (SinglentonDCL.class) &#123;</span><br><span class="line">if (dcl &#x3D;&#x3D; null) &#123;</span><br><span class="line">dcl &#x3D; new SinglentonDCL();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dcl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonDCL.getInstanceDcl();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法估计是我们在开发中最常用的, 这次代码的亮点是是在getInstance()方法中进行了双重的判断, 第一层判断的主要避免了不必要的同步, 第二层判断是为了在null的情况下再去创建实例; 举个简单的列子: 假如现在有多个线程同时触发这个方法: 线程A执行到nstance = new Singleton(), 它大致的做了三件事:<br>(1): 给Singleton实例分配内存, 将函数压栈, 并且申明变量类型;<br>(2): 初始化构造函数以及里面的字段, 在堆内存开辟空间;<br>(3): 将instance对象指向分配的内存空间;</p><p><strong>这种写法也并不是保证完全100%的可靠, 由于java编译器允许执行无序</strong></p><h5 id="静态内部内实现单列">静态内部内实现单列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SinglentonStaticInner &#123;</span><br><span class="line">private SinglentonStaticInner() &#123;</span><br><span class="line">System.out.println(&quot;hello singleton inner&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final SinglentonStaticInner getInstanceInner() &#123;</span><br><span class="line">return SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class SingletonHolder &#123;</span><br><span class="line">private static final SinglentonStaticInner INSTANCE &#x3D; new SinglentonStaticInner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SinglentonStaticInner.getInstanceInner();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举实现单列">枚举实现单列</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点: 相对于其他单列来说枚举写法最简单, 并且任何情况下都是单列的</p><h5 id="使用容器单">使用容器单</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; objMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private SingletonManager() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void putObject(String key, Object instance)&#123;</span><br><span class="line">        if(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getObject(String key)&#123;</span><br><span class="line">        return objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序开始的时候将单列类型注入到一个容器之中, 也就是单列ManagerClass, 在使用的时候再根据key值获取对应的实例, 这种方式可以使我们很方便的管理很多单列对象, 也对用户隐藏了具体实现类, 降低了耦合度; 但是为了避免造成内存泄漏, 所以我们一般在生命周期销毁的时候也要去销毁它</p><h4 id="总结">总结</h4><p>单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式都不会有太大的影响。即使如此，出于效率考虑，推荐使用DCL单例（双重检查锁定）和静态内部类单例模式。</p><p>优点：</p><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>单例模式可以避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。</li><li>单例对象如果持有Context，那么很容易引发内存泄露。此时需要注意传递给单例对象的Context最好是Application Context。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> singlenton </tag>
            
            <tag> lazy </tag>
            
            <tag> hungry </tag>
            
            <tag> double check locking </tag>
            
            <tag> static inner class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/2020/02/16/volatile/"/>
      <url>/2020/02/16/volatile/</url>
      
        <content type="html"><![CDATA[<h1>深入浅出java中volatile</h1><p>这周处理ticket的时候发现，我们经常会把数据加载到cache，然后去生明voltile，于是我就梳理了一下知识点，可能有点冷门，但是还是有其用到的地方</p><h3 id="volatile定义">volatile定义</h3><p>如果一个字段被声明为volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><h3 id="volatile的特性">volatile的特性</h3><p>从上面的官方定义我们可以看出 volatile实现了内存可见性<br>内存可见性：简单的讲也就是说一个线程对 声明了volatile的变量进行修改，java会保证其他线程也能看见修改，保证内存中的变量是最新的</p><p>原子性： volatile 能保证单个volatile的操作是原子性的 但不能保证 形如 i++这样的操作是原子性的 （下面会给出代码）</p><h3 id="volatile的使用">volatile的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>只要在变量前声明即可</p><p>volatile 无法保证复合性操作的原子性<br>我们可以通过代码实验来证明这一点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title">AtomicTest</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span>    <span class="keyword">static</span>   <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ;k&lt;<span class="number">1000</span>;k++)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws InterruptedException</span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AtomicTest());</span><br><span class="line">            threads[c].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c =<span class="number">0</span>;c&lt;<span class="number">10</span>;c++)&#123;</span><br><span class="line">            threads[c].<span class="keyword">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上， 执行上述代码你会发现每次输出的值都会小于我们所期待的最终值 10000 ，  也就 i++并不是原子性的。<br>所以我们并不建议 volatile使用在这种场景下，我们可以用volatile ：检查某个标记以来判断是否进行下一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span>  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; </span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(flag)&#123; </span><br><span class="line">      ........</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile的内存可见性">volatile的内存可见性</h3><p>volatile的内存可见性是通过java内存模型对volatile定义的特殊规则定义的。在jvm虚拟机的内存模型中 分为本地内存和主内存，每一个线程都有自己的本地内存，并且共享同一个主内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当写一个<span class="keyword">volatile</span>变量时， java内存模型会把该变量从线程的本地变量刷新到主内存</span><br><span class="line">当读一个<span class="keyword">volatile</span>变量时，java内存模型会去主内存取该变量，然后将本地内存中的值改变</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-2c36332ffe88609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/424/format/webp" alt="img"></p><p>2.png</p><p><img src="https:////upload-images.jianshu.io/upload_images/4385259-bc40b98181cd7b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="img"></p><p>3.png</p><h3 id="java内存模型中的volatile-、">java内存模型中的volatile 、</h3><p>java内存模型为了保证volatile 的内存可见性 对volatile还有第二条语义：禁止指令重排序优化（关于重排序后面我也会整理我的心得分享给大家，简单的讲就是java会对没有数据依赖的操作进行指令重排 已达到提升性能的目的）。<br>那么为什么要禁止指令重排序呢？下面我们通过一个简单的代码来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map mapTest;</span><br><span class="line"><span class="keyword">char</span>[] configuration;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> init =<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//假设a线程执行writer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">mapTest =<span class="keyword">new</span> HashMap;</span><br><span class="line">configuration = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];<span class="comment">//读之前的准工作</span></span><br><span class="line">init =<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设b线程执行该代码</span></span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(init )&#123;</span><br><span class="line">  .......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的代码，如果init变量没有被定义为volatile的，那么 init=true 这段代码可能由于指令重排序的优化，导致其被提前执行，这样会导致配置b中使用a线程中的配置信息是出错，<br>volatile变量的赋值的汇编代码是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java代码 ： instance =new singleton（）</span><br><span class="line">汇编代码：  0x01a3de1d: movb <span class="variable">$0x0</span>,0x1104800(%esi);</span><br><span class="line">                     0x01a3de24: lock addl <span class="variable">$0x0</span>,(%esp);</span><br></pre></td></tr></table></figure><p>其中 lock addl $0x0, (%esp) 就相当于一个内存屏障  对于volatile变量来说 读写会具有不同的内存屏障.<br>具体会根据以下规则使用不同的内存屏障</p><blockquote><p>当第二个操作是volatile写时，不管第一个操作是什么，都不&gt;&gt;能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。<br>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。<br>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></blockquote><h3 id="结语">结语</h3><p>引用java并发编程实战中的一段话结束这篇文章<br>仅当volatile 变量能简化代码的实习以及对同步策略的验证时，才应该使用它们，如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标示一些重要的程序生命周期时间的发生（例如，初始化和关闭）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>entry reflect</title>
      <link href="/2020/02/16/entry-reflect/"/>
      <url>/2020/02/16/entry-reflect/</url>
      
        <content type="html"><![CDATA[<p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分为堆和栈，易懂点吧！</p><p>假如你写了一段代码：Object o=new Object();</p><p>运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p><p>题主想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求哦要用到某个类，哎呀但没加载进jvm，是不是要停下来自己写段代码，new一下，哦启动一下服务器，（脑残）！</p><p>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Method area</title>
      <link href="/2020/02/16/mthod-area/"/>
      <url>/2020/02/16/mthod-area/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。</p></blockquote><h2 id="方法区">方法区</h2><p>方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><blockquote><p>注意：JDK 6 时，String等字符串常量的信息是置于方法区中的，但是到了JDK 7 时，已经移动到了Java堆。所以，方法区也好，Java堆也罢，到底详细的保存了什么，其实没有具体定论，要结合不同的JVM版本来分析。</p></blockquote><blockquote><h3 id="异常">异常</h3><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。<br>运行时常量池溢出：比如一直往常量池加入数据，就会引起OutOfMemoryError异常。</p></blockquote><h3 id="类信息">类信息</h3><blockquote><ol><li>类型全限定名。</li><li>类型的直接超类的全限定名（除非这个类型是java.lang. Object，它没有超类）。</li><li>类型是类类型还是接口类型。</li><li>类型的访问修饰符（public、abstract或final的某个子集）。</li><li>任何直接超接口的全限定名的有序列表。</li><li>类型的常量池。</li><li>字段信息。</li><li>方法信息。</li><li>除了常量意外的所有类（静态）变量。</li><li>一个到类ClassLoader的引用。</li><li>一个到Class类的引用。</li></ol></blockquote><h2 id="1-常量池">1 常量池</h2><h3 id="1-1-Class文件中的常量池">1.1 Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h3 id="1-2-运行时常量池">1.2 运行时常量池</h3><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="1-3-常量池的好处">1.3 常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><blockquote><p>双等号==的含义</p><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul></blockquote><h3 id="1-4-基本类型的包装类和常量池">1.4 基本类型的包装类和常量池</h3><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean。</p><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float, Double并没有实现常量池技术。</p><h4 id="Integer与常量池">Integer与常量池</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));  </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="解释：">解释：</h4><ul><li>(1)Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40); ，从而使用常量池中的对象。</li><li>(2)Integer i1 = new Integer(40); 这种情况下会创建新的对象。</li><li>(3)语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</li></ul><h4 id="String与常量池">String与常量池</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str1 = <span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="解释：-2">解释：</h4><ul><li><p>(1)new String(“abcd”)是在常量池中拿对象，&quot;abcd&quot;是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。</p></li><li><p>(2)连接表达式 +</p><p>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final String A; &#x2F;&#x2F; 常量A</span><br><span class="line">public static final String B;    &#x2F;&#x2F; 常量B</span><br><span class="line">static &#123;  </span><br><span class="line">   A &#x3D; &quot;ab&quot;;  </span><br><span class="line">   B &#x3D; &quot;cd&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">&#x2F;&#x2F; 将两个常量用+连接对s进行初始化  </span><br><span class="line">String s &#x3D; A + B;  </span><br><span class="line">String t &#x3D; &quot;abcd&quot;;  </span><br><span class="line">if (s &#x3D;&#x3D; t) &#123;  </span><br><span class="line">    System.out.println(&quot;s等于t，它们是同一个对象&quot;);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-3">解释：</h4><p>s不等于t，它们不是同一个对象。</p><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xyz"</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure><h4 id="解释：-4">解释：</h4><p>考虑类加载阶段和实际执行时。</p><ul><li>（1）类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li><li>（2）在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s1 持有。</li></ul><p>这条语句创建了2个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String s1 &#x3D; new String(&quot;计算机&quot;);</span><br><span class="line">String s2 &#x3D; s1.intern();</span><br><span class="line">String s3 &#x3D; &quot;计算机&quot;;</span><br><span class="line">System.out.println(&quot;s1 &#x3D;&#x3D; s2? &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">System.out.println(&quot;s3 &#x3D;&#x3D; s2? &quot; + (s3 &#x3D;&#x3D; s2));</span><br><span class="line">&#125;</span><br><span class="line">s1 &#x3D;&#x3D; s2? false</span><br><span class="line">s3 &#x3D;&#x3D; s2? true</span><br></pre></td></tr></table></figure><h4 id="解释：-5">解释：</h4><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串, 如果有则返回该字符串的引用, 如果没有则添加自己的字符串进入常量池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"> String hello = <span class="string">"Hello"</span>, lo = <span class="string">"lo"</span>;</span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == <span class="string">"Hello"</span>) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((other.Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+<span class="string">"lo"</span>)) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+lo)) + <span class="string">" "</span>); <span class="comment">//false</span></span><br><span class="line"> System.<span class="keyword">out</span>.println(hello == (<span class="string">"Hel"</span>+lo).intern()); <span class="comment">//true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">package other;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-6">解释：</h4><p>在同包同类下, 引用自同一String对象.</p><p>在同包不同类下, 引用自同一String对象.</p><p>在不同包不同类下, 依然引用自同一String对象.</p><p>在编译成.class时能够识别为同一字符串的, 自动优化成常量, 引用自同一String对象.</p><p>在运行时创建的字符串具有独立的内存地址, 所以不引用自同一String对象.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> method area </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reflect</title>
      <link href="/2020/02/16/reflect/"/>
      <url>/2020/02/16/reflect/</url>
      
        <content type="html"><![CDATA[<p>反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。</p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple &#x3D; new Apple(); &#x2F;&#x2F;直接初始化，「正射」</span><br><span class="line">apple.setPrice(4);</span><br></pre></td></tr></table></figure><p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p><p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p><p>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);</span><br><span class="line">Method method &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Object object &#x3D; constructor.newInstance();</span><br><span class="line">method.invoke(object, 4);</span><br></pre></td></tr></table></figure><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect. Apple）。</p><p>所以说什么是反射？</p><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p><h2 id="一个简单的例子">一个简单的例子</h2><p>上面提到的示例程序，其完整的程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Apple &#123;</span><br><span class="line"></span><br><span class="line">    private int price;</span><br><span class="line"></span><br><span class="line">    public int getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(int price) &#123;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;正常的调用</span><br><span class="line">        Apple apple &#x3D; new Apple();</span><br><span class="line">        apple.setPrice(5);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + apple.getPrice());</span><br><span class="line">        &#x2F;&#x2F;使用反射调用</span><br><span class="line">        Class clz &#x3D; Class.forName(&quot;com.chenshuyi.api.Apple&quot;);</span><br><span class="line">        Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">        Constructor appleConstructor &#x3D; clz.getConstructor();</span><br><span class="line">        Object appleObj &#x3D; appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, 14);</span><br><span class="line">        Method getPriceMethod &#x3D; clz.getMethod(&quot;getPrice&quot;);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple Price:5</span><br><span class="line">Apple Price:14</span><br></pre></td></tr></table></figure><p>从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</p><ul><li>获取类的 Class 对象实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.zhenai.api.Apple&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据 Class 对象实例获取 Constructor 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor &#x3D; clz.getConstructor();</span><br></pre></td></tr></table></figure><ul><li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj &#x3D; appleConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>而如果要调用某一个方法，则需要经过下面的步骤：</p><ul><li>获取方法的 Method 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br></pre></td></tr></table></figure><ul><li>利用 invoke 方法调用方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, 14);</span><br></pre></td></tr></table></figure><p>到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。</p><p>在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p><h2 id="反射常用API">反射常用API</h2><h3 id="获取反射中的Class对象">获取反射中的Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><p>**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p><strong>第二种，使用 .class 方法。</strong></p><p>这种方法只适合在编译前就知道操作的 Class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; String.class;</span><br></pre></td></tr></table></figure><p><strong>第三种，使用类对象的 getClass() 方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">Class clz &#x3D; str.getClass();</span><br></pre></td></tr></table></figure><h3 id="通过反射创建类对象">通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p>第一种：通过 Class 对象的 newInstance() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Apple apple &#x3D; (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure><p>第二种：通过 Constructor 对象的 newInstance() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure><h3 id="通过反射获取类属性、方法、构造器">通过反射获取类属性、方法、构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="img"></p><p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Delegate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
            <tag> invoke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composite and aggrevgation</title>
      <link href="/2020/02/16/composite-and-aggrevgation/"/>
      <url>/2020/02/16/composite-and-aggrevgation/</url>
      
        <content type="html"><![CDATA[<ul><li>inheritance and delegate</li></ul><p>both of them are the reuse technique in java, and they are importance design in our daily coding, inheritance is represented by Lioskv, his operations and attributes are inherite by subclass from parent class in the context, which is called super class.</p><p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p><p>Delegation can be an alternative to inheritance.<br>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.<br>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.<br>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</p><ul><li>difference between delegate and inheritance?</li></ul><p>inheitance vise to class, bur delegate vise to object</p><ul><li>Why use delegate?</li></ul><p>it can be an alternative way of inheritance, but the primary advantage of delegate is that it’s flexible and change in run time, it doesn’t force you to accept all method of a super class, you just provide some mthod make you sense</p><ul><li>When to use inheritance?</li></ul><p>You want to express relationship (is-a) then you want to use Inheritance.</p><p>You want to be able to pass your class to an existing API expecting A’s then you need to use inheritance.</p><ul><li>when to use delegate?</li></ul><p>You want to enhance A, but A is final and can no further be sub-classed then you need to use <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/" target="_blank" rel="noopener">composition</a> and delegation.</p><p>In this example, there is an Institute which has no. of departments like CSE, EE. Every department has no. of students. So, we make a Institute class which has a reference to Object or no. of Objects (i.e. List of Objects) of the Department class. That means Institute class is associated with Department class through its Object(s). And Department class has also a reference to Object or Objects (i.e. List of Objects) of Student class means it is associated with Student class through its Object(s).<br>It represents a <strong>Has-A</strong> relationship.<br><a href="https://www.geeksforgeeks.org/media.geeksforgeeks.org/wp-content/uploads/Reference.png" target="_blank" rel="noopener"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Reference.png" alt="Aggregation_1"></a></p><p>Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.</p><ul><li>It represents <strong>part-of</strong> relationship.</li><li>In composition, both the entities are dependent on each other.</li><li>When there is a composition between two entities, the composed object <strong>cannot exist</strong> without the other entity.</li></ul><p>In above example a library can have no. of <strong>books</strong> on same or different subjects. So, If Library gets destroyed then All books within that particular library will be destroyed. i.e. book can not exist without library. That’s why it is composition.</p><p><strong>Aggregation vs Composition</strong></p><ol><li><strong>Dependency:</strong> Aggregation implies a relationship where the child <strong>can exist independently</strong> of the parent. For example, Bank and Employee, delete the Bank and the Employee still exist. whereas Composition implies a relationship where the child <strong>cannot exist independent</strong> of the parent. Example: Human and heart, heart don’t exist separate to a Human</li><li><strong>Type of Relationship:</strong> Aggregation relation is <strong>“has-a”</strong> and composition is <strong>“part-of”</strong> relation.</li><li><strong>Type of association:</strong> Composition is a <strong>strong</strong> Association whereas Aggregation is a <strong>weak</strong> Association.</li></ol><p>In case of aggregation, the Car also performs its functions through an Engine. but the Engine is not always an internal part of the Car. An engine can be swapped out or even can be removed from the car. That’ why we make The Engine type field non-final.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deglate </tag>
            
            <tag> inheritance </tag>
            
            <tag> comoposite </tag>
            
            <tag> aggrevgation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID Object Orient Programming pinciples</title>
      <link href="/2020/02/15/solid/"/>
      <url>/2020/02/15/solid/</url>
      
        <content type="html"><![CDATA[<p>this is 5 pinciple of object-oriented programming</p><p>In object-oriented computer programming, <strong>SOLID</strong> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.</p><ul><li>s = single respoonsibilty principle</li></ul><p>a class should have a single responsibility, one part of software’s specification should be able to affect the specification of class</p><ul><li>open close principle</li></ul><p>Software class should be opened for extension but closed for modifications</p><ul><li>Liskov</li></ul><p>Object in a program should be replaced with instance of their subtype without correctness of that program</p><ul><li>interface segergation</li></ul><p>many client specific interface are better than one general purpose interface</p><ul><li>dependency inversion</li></ul><p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p><h4 id="single-responsibility">single responsibility</h4><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p><p><strong>example</strong></p><p>First, we create our shapes classes and have the constructors setup the required parameters. Next, we move on by creating the <strong>AreaCalculator</strong> class and then write up our logic to sum up the areas of all provided shapes.</p><p>To use the <strong>AreaCalculator</strong> class, we simply instantiate the class and pass in an array of shapes, and display the output at the bottom of the page.</p><p>All of that logic would be handled by the <strong>AreaCalculator</strong> class, this is what SRP frowns against; the <strong>AreaCalculator</strong> class should only sum the areas of provided shapes, it should not care whether the user wants json or HTML.</p><p>Now, whatever logic you need to output the data to the user is now handled by the <strong>SumCalculatorOutputter</strong> class.</p><h4 id="open-closed-principle">open-closed principle</h4><p>This simply means that a class should be easily extendable without modifying the class itself. Let’s take a look at the <strong>AreaCalculator</strong> class, especially it’s <strong>sum</strong> method.</p><p>If we wanted the <strong>sum</strong> method to be able to sum the areas of more shapes, we would have to add more <strong>if/else blocks</strong> and that goes against the Open-closed principle.</p><p>A way we can make this <strong>sum</strong> method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape’s class.</p><p>The same thing should be done for the <strong>Circle</strong> class, an <strong>area</strong> method should be added. Now, to calculate the sum of any shape provided should be as simple as:</p><p>Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the <strong>AreaCalculator</strong> is actually a shape or if the shape has a method named <strong>area</strong>?</p><p>Coding to an interface is an integral part of <strong>S. O. L. I. D</strong>, a quick example is we create an interface, that every shape implements:</p><p>In our <strong>AreaCalculator</strong> sum method we can check if the shapes provided are actually instances of the <strong>ShapeInterface</strong>, otherwise we throw an exception:</p><h4 id="Liskoc-substitution-principle">Liskoc substitution principle</h4><p>Next up on our list is Liskov substitution, which is arguably the most complex of the 5 principles. Simply put, <strong>if class *A* is a subtype of class *B*, then we should be able to replace *B* with *A* without disrupting the behavior of our program.</strong></p><h4 id="interface-segregation">interface segregation</h4><p><strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we can add another contract to the <strong>ShapeInterface</strong>:</p><p>Any shape we create must implement the <strong>volume</strong> method, but we know that squares are flat shapes and that they do not have volumes, so this interface would force the <strong>Square</strong> class to implement a method that it has no use of.</p><p><strong>ISP</strong> says no to this, instead you could create another interface called <strong>SolidShapeInterface</strong> that has the <strong>volume</strong> contract and solid shapes like cubes e.t.c can implement this interface:</p><p>This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead of using a <strong>ShapeInterface</strong> or a <strong>SolidShapeInterface</strong>.</p><p>You can create another interface, maybe <strong>ManageShapeInterface</strong>, and implement it on both the flat and solid shapes, this way you can easily see that it has a single API for managing the shapes. For example:</p><p>Now in <strong>AreaCalculator</strong> class, we can easily replace the call to the <strong>area</strong> method with <strong>calculate</strong> and also check if the object is an instance of the <strong>ManageShapeInterface</strong> and not the <strong>ShapeInterface</strong>.</p><h4 id="dependecy-inversion">dependecy inversion</h4><p><strong>The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.</strong></p><p>this principle realise the open-close displicine, which means that we don’t need to concentrate which is the shape type exactly, because each shape has his own area and we can call it by the abstraction class.</p><p><strong>in the last, you can find my code in attchement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square s &#x3D; new Square(&quot;square&quot;, 1);</span><br><span class="line">Circle c &#x3D; new Circle(&quot;circle&quot;, 1);</span><br><span class="line">Shapes[] ss &#x3D; &#123; s, c &#125;;</span><br><span class="line">CalculatorArea ca &#x3D; new CalculatorArea(ss);</span><br><span class="line">System.out.println(ca.sumShapes());</span><br><span class="line">FormatOutputter fo &#x3D; new FormatOutputter(formatter.HTML, ca);</span><br><span class="line">fo.transfer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class CalculatorArea &#123;</span><br><span class="line">private Shapes[] shapes;</span><br><span class="line"></span><br><span class="line">public CalculatorArea(Shapes[] shapes) &#123;</span><br><span class="line">this.shapes &#x3D; shapes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.area();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int volumeShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.volume();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shapes &#123;</span><br><span class="line">private int radius;</span><br><span class="line"></span><br><span class="line">public Circle(String name, int radius) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getRadius() &#123;</span><br><span class="line">return radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return (int) (Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) (Math.PI * radius * 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class FormatOutputter &#123;</span><br><span class="line">private CalculatorArea ca;</span><br><span class="line">private formatter format;</span><br><span class="line"></span><br><span class="line">public FormatOutputter(formatter format, CalculatorArea ca) &#123;</span><br><span class="line">this.format &#x3D; format;</span><br><span class="line">this.ca &#x3D; ca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer() &#123;</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case JSON:</span><br><span class="line">System.out.println(&quot;json transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case HTML:</span><br><span class="line">System.out.println(&quot;html transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case TXT:</span><br><span class="line">System.out.println(&quot;txt transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case XML:</span><br><span class="line">System.out.println(&quot;xml transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public enum formatter &#123;</span><br><span class="line">XML, JSON, TXT, HTML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeInterface &#123;</span><br><span class="line">int area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public abstract class Shapes implements ShapeInterface, ShapeVolumInterface &#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Shapes(String name) &#123;</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeVolumInterface &#123;</span><br><span class="line">int volume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Square extends Shapes &#123;</span><br><span class="line">private int length;</span><br><span class="line"></span><br><span class="line">public Square(String name, int length) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return length * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) Math.pow(length, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solid </tag>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装*必备的linux命令</title>
      <link href="/2020/02/12/linux-command/"/>
      <url>/2020/02/12/linux-command/</url>
      
        <content type="html"><![CDATA[<p>当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演</p><h4 id="常规操作-小试牛刀">常规操作 小试牛刀</h4><p><strong>ls: 类似于dos下的dir命令</strong></p><p>ls最常用的参数有三个： -a -l -F。</p><p>ls –a</p><p>Linux上的文件以. 开头的文件被系统视为隐藏文件，仅用ls命令是看不到他们的，而用ls -a除了显示一般文件名外，连隐藏文件也会显示出来。</p><p>ls –l</p><p>该参数显示更详细的文件信息。</p><p>ls –F</p><p>使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。但是现在基本上所有的Linux发行版本的ls都已经内建了-F参数，也就是说，不用输入这个参数，我们也能看到各种分辨符号。</p><p><strong>cd: 用于切换用户当前工作目录</strong></p><p>cd aaa 进入aaa目录</p><p>cd 命令后不指定目录，会切换到当前用户的home 目录</p><p>cd ~ 作用同cd后不指定目录，切换到当前用户的home 目录</p><p>cd - 命令后跟一个减号，则会退回到切换前的目录</p><p>cd … 返回到当前目录下的上一级目录</p><p><strong>pwd：用于显示用户当前工作目录</strong></p><p><strong>mkdir 和 rmdir</strong></p><p>midir: 创建目录 rmdir: 删除目录</p><p>两个命令都支持-p参数，对于mkdir命令若指定路径的父目录不存在则一并创建，对于rmdir命令则删除指定路径的所有层次目录，如果文件夹里有内容，则不能用rmdir命令</p><p>如下：</p><p>mkdir -p 1/2/3</p><p>rmdir -p 1/2/3</p><p><strong>tar 打包压缩与解压缩</strong></p><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2</a>命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file&#x3D;&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br></pre></td></tr></table></figure><p><strong>将文件全部打包成tar包</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！ </span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure><p>在选项 <code>f</code> 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 <code>z</code> 选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加 <code>j</code> 选项，则以.tar.bz2来作为tar包名。</p><p><strong>查阅上述tar包内有哪些文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 <code>z</code> 这个选项了。</p><p><strong>将tar包解压缩</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;opt&#x2F;soft&#x2F;test&#x2F;log.tar.gz</span><br></pre></td></tr></table></figure><h4 id="文件操作-装-的核心操作">文件操作 装*的核心操作</h4><p><strong>touch</strong></p><p>inux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令&quot;touch&quot;修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure><p><strong>cp：复制命令</strong></p><p>复制一个文件到另一目录：cp 1.txt …/test2</p><p>复制一个文件到本目录并改名：cp 1.txt 2.txt</p><p>复制一个文件夹a并改名为b：cp -r a b</p><p><strong>mv：移动命令</strong></p><p>将一个文件移动到另一个目录：mv 1.txt …/test1</p><p>将一个文件在本目录改名：mv 1.txt 2.txt</p><p>将一个文件一定到另一个目录并改名：mv 1.txt …/test1/2.txt</p><p><strong>rm命令</strong></p><p>rm命令用于删除文件，与dos下的del/erase命令相似，rm命令常用的参数有三个：-i，-r，-f。</p><p>–i ：系统在删除文件之前会先询问确认，用户回车之后，文件才会真的被删除。需要注意，linux下删除的文件是不能恢复的，删除之前一定要谨慎确认。</p><p>–r：该参数支持目录删除，功能和rmdir命令相似。</p><p>–f：和-i参数相反，-f表示强制删除</p><p><strong>cat命令</strong></p><p>cat命令的功能是显示或连结一般的ascii文本文件。cat是concatenate的简写，类似于dos下面的type命令。用法如下：</p><p>cat file1 显示file1文件内容</p><p>cat file1 file2 依次显示file1, file2的内容</p><p>cat file1 file2 &gt; file3 把file1, file2的内容结合起来，再“重定向（&gt;）”到file3文件中。</p><p>&quot;&gt;“是右重定向符，表示将左边命令结果当成右边命令的输入，注意：如果右侧文件是一个已存在文件，其原有内容将会被清空，而变成左侧命令输出内容。如果希望以追加方式写入，请改用”&gt;&gt;&quot;重定向符。</p><p>如果&quot;&gt;&quot;左边没有指定文件，如： cat &gt;file1，将会等用户输入，输入完毕后再按[Ctrl]+[c]或[Ctrl]+[d]，就会将用户的输入内容写入file1。</p><p><strong>echo命令</strong></p><p>echo命令的使用频率不少于ls和cat，尤其是在shell脚本编写中。</p><p>语法：echo [-ne][字符串]</p><p>功能：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开， 并在最后加上换行符。</p><p>参数：</p><p>-n 显示字串时在最后自动换行</p><p>-e 支持以下格式的转义字符， -E 不支持以下格式的转义字符</p><p>/a 发出警告声；</p><p>/b 删除前一个字符；</p><p>/c 最后不加上换行符号；</p><p>/f 换行但光标仍旧停留在原来的位置；</p><p>/n 换行且光标移至行首；</p><p>/r 光标移至行首，但不换行；</p><p>/t 插入tab；</p><p>/v 与/f相同；</p><p>// 插入/字符；</p><p><strong>more，less，clear</strong></p><p>n more，less命令</p><p>这两个命令用于查看文件，如果一个文件太长，显示内容超出一个屏幕，用cat命令只能看到最后的内容，用more和less两个命令可以分页查看。more指令可以使超过一页的文件内容分页暂停显示，用户按键后才继续显示下一页。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，更方便浏览阅读。</p><p>less的常用动作命令：</p><p>回车键 向下移动一行；</p><p>y 向上移动一行；</p><p>空格键 向下滚动一屏；</p><p>b 向上滚动一屏；</p><p>d 向下滚动半屏；</p><p>h less的帮助；</p><p>u 向上洋动半屏；</p><p>w 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示；</p><p>g 跳到第一行；</p><p>G 跳到最后一行；</p><p>p n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示；</p><p>/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词；</p><p>v 调用vi编辑器；</p><p>q 退出less</p><p>!command 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</p><p>n clear命令</p><p>clear命令是用来清除当前屏幕显示的，不需任何参数，和dos下的cls命令功能相同。</p><h4 id="读写操作-装-境界更上一层楼">读写操作 装*境界更上一层楼</h4><p><strong>vim 高级文本编辑器</strong></p><p>Vim 经常被认为是 “程序员的编辑器”, 它在程序编写时非常有用，很多人认为它是一个完整的集成开发环境(IDE)。仅管如此，Vim并不只是程序员使用的。Vim可以用于多种文档编辑，从email排版到配置文件编写。</p><p><strong>编辑模式</strong>（Normal）：执行命令，也称为正常模式<br>**插入模式 **（Insert）：输入文本<br><strong>命令模式</strong>：执行 <strong>冒号</strong> 命令</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>按下键 i ，进入 <em>Insert</em> 模式（ 这时候，你可以输入文本）</li><li>按 ESC键，就可退回到<em>Normal</em> 模式下</li></ul><p>在Normal下基本命令操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">Insert</span> 模式，按 <span class="selector-tag">ESC</span>回到 <span class="selector-tag">Normal</span>模式。 <span class="selector-tag">x</span> 删当前光标所在的一个字符。<span class="selector-pseudo">:wq</span> 存盘+退出 (<span class="selector-pseudo">:w</span>存盘, <span class="selector-pseudo">:q</span>退出) （注<span class="selector-pseudo">:w</span> 后可以跟文件名）<span class="selector-pseudo">:q</span> ! 不保存退出 <span class="selector-tag">Shift</span>+<span class="selector-tag">ZZ</span> 退出本文档 <span class="selector-tag">dd</span> 删除当前行，并把删除的行存到剪贴板里 <span class="selector-tag">p</span> 粘贴剪贴板<span class="selector-pseudo">:help</span> 显示相关命令的帮助（<span class="selector-pseudo">:q</span> 退出帮助） 移动光标 <span class="selector-tag">hjkl</span> (←↓↑→)</span><br></pre></td></tr></table></figure><p>简单的光标移动命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       当前行第一列</span><br><span class="line">w       移到下一个单词</span><br><span class="line">^       移动到第一个非空白字符</span><br><span class="line">$       移动到最后一列</span><br><span class="line">g       移动到最后一个非空白字符</span><br><span class="line">%       匹配括号移动，包括 (, &#123;, [。 （把光标先移到括号上）</span><br><span class="line"></span><br><span class="line">*       移动光标到上一个匹配的单词</span><br><span class="line"></span><br><span class="line"><span class="comment">#       移动光标到下一个匹配的单词</span></span><br><span class="line">/pattern搜索   pattern的字符串（如果搜索出多个匹配，可按n键到下一个）</span><br></pre></td></tr></table></figure><p><strong>wc命令</strong></p><p>该命令用于统计指定文件中的字节数、字数、行数。该命令各选项含义如下：</p><p>-l 统计行数</p><p>-w 统计字数</p><p>-c 统计字节数</p><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。</p><p>行数、字数、字节数、文件名</p><p>如果命令行中没有文件名，则输出中不出现文件名。</p><p><strong>grep 命令</strong></p><p>grep是（global search regular expression(RE) and print out the line的缩写，用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被””引用，模板后的所有字符串被看作文件名。搜索结果送到屏幕，不影响原文件内容。</p><p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>示例：</p><p>$ ls -l | grep ‘^a’</p><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><p>$ grep ‘test’ d*</p><p>显示所有以d开头的文件中包含test的行。</p><p>$ grep ‘test’ aa bb cc</p><p>显示在aa，bb，cc文件中匹配test的行。</p><p>$ grep ‘[a-z]/{5/}’ aa</p><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><p>$ grep ‘w/(es/)t.*/1’ aa</p><p>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.<em>），这些字符后面紧跟着另外一个es（/1），找到就显示该行。如果用egrep或grep -E，就不用&quot;/&quot;号进行转义，直接写成’w(es)t.</em>/1’就可以了。</p><h4 id="进程操作-比肩程序员">进程操作 比肩程序员</h4><p><strong>nohup 挂起操作</strong></p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。</p><p>nohup command 或者 nohup command &amp;</p><p>这之间的差别是带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上）；</p><p><strong>tip: crl + z 可以切换当前进程到后台运行</strong></p><p><strong>ps 进程</strong></p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><ul><li>ps工具标识进程的5种状态码:</li></ul><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><ul><li>命令参数</li></ul><p>a 显示所有进程</p><p>-a 显示同一终端下的所有程序</p><p>-A 显示所有进程</p><p>c 显示进程的真实名称</p><p>-au 显示较详细的资讯</p><p>-aux 显示所有包含其他使用者的行程</p><ul><li>各相关信息的意义：</li></ul><p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p><p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p><p>UID 程序被该 UID 所拥有</p><p>PID 就是这个程序的 ID ！</p><p>PPID 则是其上级父程序的ID</p><p>C CPU 使用的资源百分比</p><p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p><p>SZ 使用掉的内存大小</p><p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p><p>TTY 登入者的终端机位置</p><p>TIME 使用掉的 CPU 时间。</p><p>CMD 所下达的指令为何</p><p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID</p><p><strong>kill</strong></p><p>Linux kill命令用于删除执行中的程序或工作。</p><p>彻底杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456(pid)</span><br></pre></td></tr></table></figure><p><strong>head，tail</strong></p><p>n head和tail命令 看log找错误改bug</p><p>都用于查看文本文件，区别在于： head显示文件的头n行，tail显示文件的尾n行，缺省情况n都为10行。可以通过-n方式指定行数，如：</p><p>head -100 file和tail -100 file分别表示显示文件头100行和尾100行内容。</p><p>n tail -f命令</p><p>可以实时查看文件新增内容。</p><h4 id="系统权限与磁盘管理操作-运维聊一聊">系统权限与磁盘管理操作 运维聊一聊</h4><p><strong>df disk free查看分区大小和占用情况</strong></p><p>-l 仅显示本地磁盘(默认）</p><p>-a 显示所有文件系统的磁盘使用情况，包含比如/proc/（查看包括0字节文件）</p><p>-h 以1024进制计算最合适的单位显示磁盘容量</p><p>-H 以1000进制计算最合适的单位显示磁盘容量</p><p>-T 显示磁盘分区类型（各个分区使用的文件系统）</p><p><strong>du disk usage统计磁盘上的文件大小</strong></p><p>-b 以byte为单位统计文件</p><p>-k 以KB为单位统计文件</p><p>-m 以MB为单位统计文件</p><p>-h 以1024进制计算最合适的单位统计文件</p><p>-H 以1000进制计算最合适的单位统计文件</p><p>-s 指定统计目标<br>第一 主分区和扩展分区总数不能超过4个<br>第二 扩展分区最多只能有一个<br>第三 扩展分区不能直接存取数据</p><p><strong>磁盘分区 fdisk</strong></p><ul><li>硬盘分区工具 &quot;fdisk&quot;命令</li></ul><p>使用fdisk分区需要跟一些参数</p><p>分区操作：</p><p>\0.fdisk -l 查看当前系统分区情况</p><p>1.fdisk /dev/sdb 进入分区模式 （fdisk 需要分区的磁盘设备名）</p><ol start="2"><li><p>输入 m 查看命令帮助信息</p></li><li><p>输入 n 添加分区</p></li></ol><p>p：主分区</p><p>e：扩展分区</p><p>l : 逻辑分区</p><p>设置起始和结束</p><p>大小 +数字[k, M, G]</p><p>\4. 输入 p 查看分配逻辑</p><p>\5. 输入 d 删除对应分区逻辑（删除是扩展分区的话，对应的逻辑分区也被删除）</p><p>\6. 输入 w 将分区逻辑实施并退出 fdisk命令</p><p>补充：在fdisk内部操作的分区操作，只是计划，只有当键入 w 时才会进行实际的分区</p><p><strong>chown</strong></p><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h4 id="计算机网络操作-神进化完成">计算机网络操作 *神进化完成</h4><p><strong>netstat 查看网络状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">    -t  列出TCP协议端口</span><br><span class="line">    -u  列出UDP协议端口</span><br><span class="line">    -n  不适用域名与服务名，而使用IP地址和端口号</span><br><span class="line">    -l  仅列出在监听状态网络服务</span><br><span class="line">    -a  列出所有的网络连接</span><br><span class="line">    -r  列出路由列表，功能和route命令一致</span><br><span class="line">    常用：-tuln –an –rn</span><br></pre></td></tr></table></figure><p><strong>route</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">route</span> –<span class="selector-tag">n</span> 查看路由列表（可以看到网关） <span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">default</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 临时设定网关</span><br></pre></td></tr></table></figure><p><strong>ifconfig 关闭与启动网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdown 网卡设备名</span><br><span class="line">    禁用该网卡设备</span><br><span class="line">ifup 网卡设备名</span><br><span class="line">    启用该网卡设备</span><br></pre></td></tr></table></figure><p><strong>nslookup 域名解析命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nslookup</span> <span class="selector-attr">[主机名或IP]</span> 进行域名与<span class="selector-tag">IP</span>地址解析 <span class="selector-tag">nslookup</span>&gt;<span class="selector-tag">server</span> 查看本机<span class="selector-tag">DNS</span>服务器</span><br></pre></td></tr></table></figure><p><strong>ping 网络测试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ping</span> <span class="selector-attr">[选项]</span> <span class="selector-tag">ip</span>或域名 探测指定<span class="selector-tag">IP</span>或域名的网络状况 <span class="selector-tag">-c</span> 次数：指定<span class="selector-tag">ping</span>报的次数</span><br></pre></td></tr></table></figure><p><strong>SSH 远程连接</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH命令</span><br><span class="line">    ssh 用户名<span class="meta">@ip</span></span><br><span class="line">        远程管理指定Linux服务器</span><br><span class="line">    scp [-r] 用户名<span class="meta">@ip</span>:文件路径 本地路径</span><br><span class="line">        下载文件到本地</span><br><span class="line">    scp [-r] 本地文件 用户名<span class="meta">@ip</span>:上传路径</span><br><span class="line">        上传文件到远程服务器</span><br></pre></td></tr></table></figure><p><strong>traceroute追踪</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-attr">[xuanxiang]</span> <span class="selector-tag">IP</span>或域名 路由跟踪命令 <span class="selector-tag">-n</span> 使用<span class="selector-tag">IP</span>，不使用域名，速度更快</span><br></pre></td></tr></table></figure><h4 id="curl-wget-必杀操作">curl wget 必杀操作</h4><p>当想要直接通过 [Linux] 命令行下载文件，马上就能想到两个工具：wget 和 cURL。它们有很多一样的特征，可以很轻易的完成一些相同的任务，虽然它们有一些相似的特征，但它们并不是完全一样。这两个程序适用与不同的场合，在特定场合下，都拥有各自的特性。</p><p>wget 和 cURL 都可以下载内容。它们的核心就是这么设计的。它们都可以向互联网发送请求并返回请求项。这可以是文件、图片或者是其他诸如网站的原始 HTML 之类。</p><p>这两个程序都可以进行 HTTP POST 请求。这意味着它们都可以向网站发送数据，比如说填充表单什么的。</p><p>由于这两者都是命令行工具，它们都被设计成可脚本化。wget 和 cURL 都可以写进你的 Bash 脚本 ，自动与新内容交互，下载所需内容。</p><p>wget 简单直接。这意味着你能享受它超凡的下载速度。wget 是一个独立的程序，无需额外的资源库，更不会做其范畴之外的事情。</p><p>wget 是专业的直接下载程序，支持递归下载。同时，它也允许你下载网页中或是 FTP 目录中的任何内容。</p><p>wget 拥有智能的默认设置。它规定了很多在常规浏览器里的事物处理方式，比如 cookies 和重定向，这都不需要额外的配置。可以说，wget 简直就是无需说明，开罐即食！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//soft.vpser.net/lnmp/lnmp1.1-full.tar.gz</span></span><br><span class="line">    下载命令</span><br></pre></td></tr></table></figure><p>cURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。</p><p>cURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。</p><p>cURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。</p><p>cURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。</p><p>cURL 同样支持让数据发送变得更容易的 gzip 压缩技术。</p><p>那你应该使用 cURL 还是使用 wget？这个比较得看实际用途。如果你想快速下载并且没有担心参数标识的需求，那你应该使用轻便有效的 wget。如果你想做一些更复杂的使用，直觉告诉你，你应该选择 cRUL。</p><p>cURL 支持你做很多事情。你可以把 cURL 想象成一个精简的命令行网页浏览器。它支持几乎你能想到的所有协议，可以交互访问几乎所有在线内容。唯一和浏览器不同的是，cURL 不会渲染接收到的相应信息。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> file </tag>
            
            <tag> net </tag>
            
            <tag> process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface and class</title>
      <link href="/2020/02/12/interface-and-class/"/>
      <url>/2020/02/12/interface-and-class/</url>
      
        <content type="html"><![CDATA[<p>interface</p><p>contains parameter and method</p><p>method par default is public abstract, we can not concerate but since java 8, default</p><p>parameter par default is public static final</p><p>a interface can extends multi interface, but it should realise all of the parment methods</p><p>abstract class</p><p>abstract class can concentrate method and contains various type : public private static</p><p>abstract class can have static method</p><p>hériter only one class</p><p>1、抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。</p><p>2、当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</p><p>3、当注重代码的扩展性跟可维护性时，应当优先采用接口。①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活; ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interface </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashcode, equals区别与联系</title>
      <link href="/2020/02/12/hashcode-equal/"/>
      <url>/2020/02/12/hashcode-equal/</url>
      
        <content type="html"><![CDATA[<p>有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。下面我们一起来看一下，它们到底有什么区别，总结一波！</p><p>01、hashCode介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.hashCode());}</code></pre><p>}<br>通过调用hashCode()方法获取对象的hash值。</p><p>02、equals介绍<br>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.equals(obj));}</code></pre><p>}<br>03、hashCode() 和 equals() 有什么关系？<br>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我们梳理了一下 “hashCode() 和 equals()的关系”。我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><p>3.1、不会创建“类对应的散列表”<br>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</p><p>equals() 用来比较该类的两个对象是否相等，而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 举个例子</p><p>public class DemoNormalTest {</p><pre><code>public static void main(String[] args) {// 新建2个相同内容的Person对象，// 再用equals比较它们是否相等Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>p1.equals(p3) : false; p1(2018699554) p3(1735600054)<br>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><p>3.2、会创建“类对应的散列表”<br>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的:</p><p>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。<br>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。<br>举个例子</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，    Person p1 = new Person(&quot;eee&quot;, 100);    Person p2 = new Person(&quot;eee&quot;, 100);    Person p3 = new Person(&quot;aaa&quot;, 200);    // 新建HashSet对象     HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();    set.add(p1);    set.add(p2);    set.add(p3);    // 比较p1 和 p2， 并打印它们的hashCode()    System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());     // 打印set    System.out.printf(&quot;set:%s\n&quot;, set); }private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>set:[(eee, 100), (aaa, 200), (eee, 100)]<br>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>举个例子，我们同时覆盖equals() 和 hashCode()方法。</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);Person p4 = new Person(&quot;EEE&quot;, 100);// 新建HashSet对象HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();set.add(p1);set.add(p2);set.add(p3);set.add(p4);// 比较p1 和 p2， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());// 比较p1 和 p4， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());// 打印setSystem.out.printf(&quot;set:%s\n&quot;, set);}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot; + name + &quot;, &quot; + age + &quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}/** * 重写hashCode方法 */@Overridepublic int hashCode() {int nameHash = name.toUpperCase().hashCode();return nameHash ^ age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(68545) p2(68545)<br>p1.equals(p4) : false; p1(68545) p4(68545)<br>set:[(eee, 100), (EEE, 100), (aaa, 200)]</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashcode </tag>
            
            <tag> equals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set家族的对比</title>
      <link href="/2020/02/12/set-hashset-treeset-linkedset/"/>
      <url>/2020/02/12/set-hashset-treeset-linkedset/</url>
      
        <content type="html"><![CDATA[<p>Set接口<br>Set 接口与 List 接口相比没有那么多操作方法，比如：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><p>对比一下Set接口和Collection接口就知道，其实Set接口仅仅对Collection所有方法进行继承而已，而自己没有扩展任何方法，Set接口与Collection接口一样，都是15个方法。</p><img src="/2020/02/12/set-hashset-treeset-linkedset/set.jpg" alt="set" style="zoom:100%; ">Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。这里说的相同元素指的是用 equals() 方法比价后返回 true，当然了如果用 == 也返回true，那肯定也是相同的。一. HashSet特点：<ol><li><p>HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是无序的。</p></li><li><p>HashSet如何保证唯一性？</p></li></ol><p>1). HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2). 确保唯一性的两个方法：hashCode()和equals()方法。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>二. LinkedHashSet<br>特点：</p><ol><li><p>LinkedHashSet中不能有相同元素，可以有一个Null元素，元素严格按照放入的顺序排列。</p></li><li><p>LinkedHashSet如何保证有序和唯一性？</p></li></ol><p>1). 底层数据结构由哈希表和链表组成。</p><p>2). 链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>三. TreeSet<br>特点：</p><ol><li><p>TreeSet是中不能有相同元素，不可以有Null元素，根据元素的自然顺序进行排序。</p></li><li><p>TreeSet如何保证元素的排序和唯一性？</p></li></ol><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(log(n))</p></li><li><p>非线程安全</p></li></ol><p>四. 总结：<br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collections </category>
          
          <category> Set </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashset </tag>
            
            <tag> linkedhashset </tag>
            
            <tag> treeset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讲清楚Vector vs ArrayList vs LinkedList</title>
      <link href="/2020/02/11/vector-arraylist-linkedlist/"/>
      <url>/2020/02/11/vector-arraylist-linkedlist/</url>
      
        <content type="html"><![CDATA[<p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></li><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></li><li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p></li><li><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p></li><li><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p></li><li><p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p></li><li><p>笼统来说：LinkedList：增删改快，ArrayList：查询快（有索引的存在）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> arraylist </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试高频HashMap VS HashTable</title>
      <link href="/2020/02/11/hashmapVsHashtable/"/>
      <url>/2020/02/11/hashmapVsHashtable/</url>
      
        <content type="html"><![CDATA[<p>在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一样的。·<br>在使用时一般是用ArrayList代替Vector，LinkedList代替Stack，HashMap代替HashTable，即使在多线程中需要同步，也是用同步包装类。<br>另外在使用上还有一些小的差异，比如：</p><ul><li><p>HashTable的key和value都不允许为null值，而HashMap的key和value则都是允许null值的。这个其实没有好坏之分，只是Sun为了统一Collection的操作特性而改进的。</p></li><li><p>HashTable有一个contains(Object value)方法，功能上与containsValue(Object value)一样，但是在实现上花销更大，现在已不推荐使用。而HashMap只有containsValue(Object value)方法。</p></li><li><p>HashTable使用Enumeration，HashMap使用Iterator。Iterator其实与Enmeration功能上很相似，只是多了删除的功能。用Iterator不过是在名字上变得更为贴切一些。模式的另外一个很重要的功用，就是能够形成一种交流的语言（或者说文化）。有时候，你说Enumeration大家都不明白，说Iterator就都明白了。</p></li></ul><p><strong>不同点</strong></p><h4 id="接口">接口</h4><p><img src="https://pic3.zhimg.com/80/v2-12c49eba132902bbea990a4d77ecce37_hd.jpg" alt="img" style="zoom:50%;"><img src="https://pic3.zhimg.com/80/v2-d7d5449c9638ec4955288a3aa2ba9f13_hd.jpg" alt="img"></p><p>HashMap和Hashtable不仅作者不同，而且连父类也是不一样的。HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口</p><p>Dictionary类是一个已经被废弃的类（见其源码中的注释）。父类都被废弃，自然而然也没人用它的子类Hashtable了。</p><h4 id="线程安全">线程安全</h4><p>线程安全性不同</p><p>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</p><p>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，</p><p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><h4 id="初始容量大小和每次扩充容量大小的不同">初始容量大小和每次扩充容量大小的不同</h4><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说Hashtable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。</p><h4 id="计算hash值的方法不同">计算hash值的方法不同</h4><p>为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p><p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><p><img src="https://pic4.zhimg.com/50/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"></p><p>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</p><p>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p><p>HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算</p><p>为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Interview </category>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
            <tag> hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2分钟说清楚shell和batch文件</title>
      <link href="/2020/02/11/shellandbatch/"/>
      <url>/2020/02/11/shellandbatch/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg" alt="Batch Programming (Dos Scripting) VS Shell Scripting" style="zoom:50%; ">Batch file</p><p>batch programming vs shell programming</p><p><img src="http://www.gonet.com.cn/~editor/eweditor/uploadfile/20171027141729471.png" alt="区别"></p><p>由于我们普通人接触UNIX的比较少，就不在多说。今天主要来说说WINDOWS系统和LINUX及苹果操作系统的区别。首先这三个系统设计上有本质的区别。最大的区别在于WINDOWS是一个成熟的商业操作系统，拿过来就能用，而LINUX不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。</p><img src="https://img-blog.csdn.net/20180619102423833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVfQXlt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表格" style="zoom:%; "><p>When I started my career in IT field, I have landed into windows world, as I know that no companies give chance to a fresher to work on production Linux/Unix servers. Its a good experience to work on <strong>DOS scripts(aka Batch programming).</strong> There are many <strong>similarities/differences/advantages/disadvantages</strong> between <strong>Batch programming</strong> and <strong>Shell scripting</strong>. Lets see what they are.</p><p><strong>Similarities</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Sequential execution of group commands in a batch file</td><td>Sequential execution of group command in shell scripts</td></tr><tr><td>2</td><td>Can read inputs from users</td><td>Can read inputs from users</td></tr><tr><td>3</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td></tr><tr><td>4</td><td>Supports advanced features such as Functions and Arrays</td><td>Supports advanced features such as Functions and Arrays</td></tr><tr><td>5</td><td>Supports regular expressions(using findstr)</td><td>Supports regular expressions</td></tr><tr><td>6</td><td>Can include other programming codes such as perl(ie…in middle of dos script we can include some other programming language code for effective scripting to get our desired output)</td><td>Can include other programming codes such as Perl, AWK, SED etc.</td></tr></tbody></table><p><strong>Differences</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Lack of richness of tools/commands</td><td>Have good number of tools(as of my knowledge there are more than 75000 commands in Linux/Unix)</td></tr><tr><td>2</td><td>Supports only one vendor(i.e.windows)</td><td>Supports for number of vendors such as Sun/apple/IBM AIX/HP-UX/GNU Linux etc.</td></tr><tr><td>3</td><td>No other variants for DOS</td><td>There are number of variants such as bash, ksh, csh, zsh etc…</td></tr><tr><td>4</td><td>Low capabilities of integrating with other programming code in batch scripting</td><td>Good capabilities of integrating other programming code in shell script</td></tr><tr><td>5</td><td>Cannot handle complex regular expressions</td><td>Can handle complex regular expressions.</td></tr><tr><td>6</td><td>A batch file should always end with .bat</td><td>There is no such concept like file extension, but a shell script file permission should be set to executable.</td></tr><tr><td>7</td><td>To execute a batch program just enter the file name at CLI</td><td>To execute a shell script, here are the ways to execute it 1)chmod +x <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a>; ./shellscript.sh 2)sh <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> batch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由String浅谈Immutable不可变对象设计模式</title>
      <link href="/2020/02/11/java-immutable/"/>
      <url>/2020/02/11/java-immutable/</url>
      
        <content type="html"><![CDATA[<h1>什么是Immutable</h1><p>Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而<strong>不用加锁实现线程安全</strong>，因为不可变对象一定是线程安全的，同时由于不需要用一些锁机制等保证内存一致性问题也减少了同步开销。<br>谈到Immutable Object会让很多Javaer联想到Java语言中的final关键字，final关键字可以修饰属性、方法和类。final的作用为</p><blockquote><p>final 修饰的 class 代表该类不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p></blockquote><p>那是不是被final修饰的对象就可以认为是Immutable Object呢？当然不是。请看下面的例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strList = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strList.add(<span class="string">"ONE"</span>);  <span class="comment">//ok</span></span><br><span class="line">strList.add(<span class="string">"TWO"</span>);  <span class="comment">//ok</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; unmodifiableStrList = Collections.unmodifiableList(strList);</span><br><span class="line">unmodifiableStrList.add(<span class="string">"THREE"</span>); <span class="comment">//throw UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p>这个例子中 <code>strList</code> 声明成final，只能说明strList变量指向的地址空间不能改变但是该地址空间指向的内容是可以修改的。</p><h1>如何定义Immutable Object</h1><p>Java 语言目前还没有原生的不可变对象的支持，但在<a href="https://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener">Java™ Tutorials</a>中给出的如何定义一个不可变对象的方法。</p><p>类中的属性不提供&quot;setter&quot;方法；</p><p>类中所有的属性声明成private和final类型；</p><p>类也声明成final的，以防止类被继承；</p><p>如果有属性是引用类型的，也要防止引用类型的属性被调用方修改了，如通过构造器初始化所有成员，尤其是引用对象要进行深拷贝(deep copy，符合copy-on-write 原则)；</p><p>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，也要深拷贝，创建私有的 copy。</p><p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name,String address)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getAddress() &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看上面示例中使用到的 <code>Collections.unmodifiableList()</code> 方法是如何将一个可变的对象变成不可变对象</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; unmodifiableList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的list是ArrayList，他是RandomAccess的实例</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(<span class="keyword">list</span>) :</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableList&lt;&gt;(<span class="keyword">list</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UnmodifiableRandomAccessList对象是Collections的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableRandomAccessList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    UnmodifiableRandomAccessList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnmodifiableList</code> 是 <code>UnmodifiableRandomAccessList</code> 的父类，它们两个都是 <code>Collections</code> 的静态内部类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;E&gt; <span class="title">extends</span> <span class="title">UnmodifiableCollection</span>&lt;E&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List</span>&lt;E&gt; &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;? extends E&gt; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    UnmodifiableList(List&lt;? extends E&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        super(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">list</span> = <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">list</span>.get(index);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List unmodifiableStrList = Collections.unmodifiableList(strList);</code> 语句执行之后unmodifiableStrList变量实际指向的类型会变成 <code>UnmodifiableList</code> 。然后再执行add方法的时候就会抛出 <code>UnsupportedOperationException</code> 异常。<br>除了 <code>unmodifiableList()</code> 方法之外， <code>Collections</code> 中还定义了将其他集合修饰成不可变对象的方法。</p><ul><li>Collections.unmodifiableCollection()</li><li>Collections.unmodifiableMap()</li><li>Collections.unmodifiableSortedMap()</li><li>Collections.unmodifiableSet()</li><li>Collections.unmodifiableSortedSet()</li></ul><p>其基本实现思路和 <code>unmodifiableList()</code> 方法是一样的，另外 <code>Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;);</code> 返回的List对象也是不可变的。</p><h1>String对象的不可变性</h1><p><code>String</code> 是典型的 Immutable 类，被声明成为 final class，它的属性基本都是 final 的。由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。下面是String源码的部分摘录，可以看到它是符合Immutable Object的定义规则的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D;</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 进行深拷贝来构造引用类型的成员变量 *&#x2F;</span><br><span class="line">    public String(char value[]) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public String(StringBuilder builder) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">    &#125;</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen &#x3D; str.length();</span><br><span class="line">        if (otherLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; value.length;</span><br><span class="line">        char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public char[] toCharArray() &#123;</span><br><span class="line">        &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">        char result[] &#x3D; new char[value.length];</span><br><span class="line">        System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可见，string是线程安全的，java中string对象需要慎用尤其是我们有大量的字符串拼接修改删除增加的操作时，这会造成大量的内存开销，由此我们可以考虑使用stringbuilder。如果需要同步，则可以使用stringbuffer</p><p>那就要分别看看它们的 <code>append()</code> 源码了；</p><p>StringBuilder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder中的append方法没有使用synchronized关键字，意味着多个线程可以同时访问这个方法。那么问题就来了额，如果两个线程同时访问到这个方法，那么AbstractStringBuilder中的count是不是就是相同的，所以这两个线程都是在底层char数组的count位置开始append添加，那么最终的结果肯定就是在后执行的那个线程append进去的数据会将前面一个覆盖掉。因此我们的控制台输出才会出现StringBuilder一直都是小于1000的。然而StringBuffer却不会发生这种情况。</p><h2 id="总结">总结</h2><ol><li>StringBuilder相比StringBuffer效率更高，但多线程不安全；</li><li>在单线程中字符串的频繁拼接使用StringBuilder效率更高，对于多线程使用StringBuffer则更安全；</li><li>字符串简单操作时没必要使用上述两者，还是用String类型提高速度；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> immutable </tag>
            
            <tag> stringbuilder </tag>
            
            <tag> stringbuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话说Serializable</title>
      <link href="/2020/02/10/transient-java/"/>
      <url>/2020/02/10/transient-java/</url>
      
        <content type="html"><![CDATA[<p>大白话定义：</p><p>序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.</p><p><strong>切记序列化不考虑static变量</strong></p><p>Java原生序列化方式是通过实现Serializable接口实现的. 不实现该接口会导致无法序列化, 抛出异常如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException</span><br></pre></td></tr></table></figure><p>序列化的应用场景：</p><blockquote><p>将对象转换为字节流, 用于网络传输, 例如用于RPC远程调用。</p><p>将对象保存到磁盘中</p></blockquote><p>Java原生序列化是通过IO包中的ObjectInputStream和ObjectOutputStream实现的。ObjectOutputStream类负责实现序列化, ObjectInputStream类负责实现反序列化。</p><h4 id="Java序列化反序列化实例">Java序列化反序列化实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Person [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class testPerson &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transient">transient</h4><p>出于安全问题，有时候不会把指定字段进行序列化保存，例如密码, 此处以Person对象的pwd字段为例, 为pwd字段添加transient修饰后，默认序列化机制会忽略它。</p><p>对比结果如下 尽管我们对pwd初始化为mdp，但是由于transient关键字，则pwd不被序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;);</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;null]</span><br></pre></td></tr></table></figure><p>如果transient修饰的字段也需要序列化和反序列化，可以使用readObject和writeObject方法。</p><p>我们只需要在当前 Person 类中添加 readObject() 和 writeObject() 方法，在 writeObject 方法中实现对 pwd 的字段赋值，就可以使pwd字段被序列化到字节流中；在 readObject 方法中实现对 pwd 字段读取，并赋值给Person对象即可。<br>添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private transient String pwd;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream s) throws Exception &#123;</span><br><span class="line">s.defaultReadObject();</span><br><span class="line">this.pwd &#x3D; (String) s.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream s) throws Exception &#123;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">this.pwd &#x3D; &quot;pwd&quot;;</span><br><span class="line">s.writeObject(this.pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPwd(String pwd) &#123;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readObject和writeObject在本文后段内容会讲解.</p><p>这里的defaultWriteObject方法作用是序列化非transient字段以及非静态字段; 这里的defaultReadObject方法作用是反序列化非transient字段以及非静态字段; 当类中含有非transient字段时, 一定要加上这两个方法.</p><p>如果被序列化的类中存在多个transient的字段, 序列化时需要如下操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class TransientPerson implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private transient Integer age;</span><br><span class="line">private transient String name;</span><br><span class="line">private transient Integer money;</span><br><span class="line"></span><br><span class="line">public TransientPerson(Integer age, String name, Integer money) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">this.age &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.money &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.name &#x3D; (String) stream.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeObject(this.age);</span><br><span class="line">stream.writeObject(this.money);</span><br><span class="line">stream.writeObject(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMoney(Integer money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;TransientPerson [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;transientperson.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">TransientPerson person &#x3D; new TransientPerson(3, &quot;abc&quot;, 123);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">TransientPerson newPerson &#x3D; (TransientPerson) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc, money &#x3D; 123]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><hr><p>这里writeObject和readObject的使用是有顺序的, 例如第一次writeObject是将age作为Object写入, 所以第一次调用readObject读到的对象就一定是age; 所以, 写入的顺序是age, money, name, 读取时候的顺序一定也要是age, money, name.</p><p>上面理论上会写入了四个对象, 第一个是defaultWriteObject写入的Person对象, 之后写入的是age(Integer对象), money(Integer), name(String).</p><p>当然这里defaultWriteObject没有写入, 因为所有成员字段都是transient修饰, 所以实际上只有三个对象(age, money, name). 换句话说, 当所有字段被transient修饰时, 可以不用defaultWriteObject和defaultReadObject.</p><h4 id="serialVersionUID">serialVersionUID</h4><p>当person对象被序列化保存到person.txt文件时, 在Person对象中添加新的属性address, 只执行反序列化代码, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">&#x2F;&#x2F;Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;, &quot;paris&quot;);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.writeObject(person);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">&#x2F;&#x2F;System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><p>输出结果依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;pwd, address&#x3D;null]</span><br></pre></td></tr></table></figure><p>但是我们删除serialVersionUID字段后再次执行, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line">private transient String pwd;</span><br><span class="line">private String address; &#x2F;&#x2F; 新添加的属性</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd, String address) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">this.address &#x3D; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: wotest.test.Person;  local class incompatible: stream classdesc serialVersionUID &#x3D; 1,  local class serialVersionUID &#x3D; 3229018537912438741</span><br></pre></td></tr></table></figure><p>原因:</p><blockquote><p>没有定义serialVersionUID值, 反序列化可能会出现 <code>local class incompatible</code> 异常, 是Java的安全机制.</p><p>当序列化对象时, 如果该对象所属类没有serialVersionUID, Java编译器会对jvm中该类的Class文件进行摘要算法生成一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; serialVersionUID(version1), 并保存在序列化结果中. </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当反序列化时, jvm会再次对jvm中Class文件摘要生成一个serialVersionUID(version2). 当且仅当version1=version2时, 才会将反序列化结果加载入jvm中, 否则jvm会判断为不安全, 拒绝载入并抛出 <code>local class incompatible</code> 异常.</p><p>这样存在的问题就是, 当对象被序列化后, 其所属类只要进行过类名称, 它所实现的接口的名称, 以及所有成员名称的修改, 会导致摘要算法算出的serialVersionUID变化.</p></blockquote><p>从而version1 != version2导致抛出异常.</p><blockquote><p>例如序列化对象存储在磁盘中后, jvm停止, 对其所属类进行修改. 再次启动jvm, 对该对象序列化时就会抛异常.</p></blockquote><p>由此可知, 反序列化时会通过比较serialVersionUID进行 <code>判断反序列化内容是否安全</code> , 所以添加如下声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 3229018537912438741L;</span><br></pre></td></tr></table></figure><p>将serialVersionUID值固定下来, 可以防止这种情况下的反序列化失败.</p><p><strong>另外, 如果 User 对象升级版本，修改了结构，而且不想兼容之前的版本，那么只需要修改下 serialVersionUID 的值就可以了。</strong></p><p>建议，每个需要序列化的对象，都要添加一个 serialVersionUID 字段。</p><p><strong>最后延伸一下，HashMap中重写的writeObject和readObject</strong></p><h5 id="HashMap序列化存在的问题">HashMap序列化存在的问题</h5><p>HashMap有必须重写它们的理由, 因为序列化会导致字节流在不同的jvm中传输, 而序列化基本要求就是反序列化后的对象与序列化之前的对象是一致的.</p><p>HashMap中，由于Entry的存放位置是根据Key的Hash值计算, 对于同一个Key，在不同的jvm中计算得出的Hash值可能是不同的.</p><p>Hash值不同导致HashMap对象反序列化的结果与序列化之前不一致. 有可能序列化之前Key=’name’的元素放在数组的第0个位置, 而反序列化后在数组第2个位置.</p><h5 id="HashMap的解决方式">HashMap的解决方式</h5><ul><li><p>将可能造成数据不一致的元素使用transient修饰，然后重写writeObject/readObject方法, 在该方法中操作这些敏感元素, 避免默认序列化方法的干扰。被transient修饰的元素有: Entry[] table, size, modCount。</p></li><li><p>首先，HashMap序列化的时候会屏蔽掉负载因子, 只把不为空的key和value进行序列化. 传送到新的jvm反序列化时, 根据新的jvm处的规则重新对key进行hash算法, 重新填充一个数组. 这样避免了对象的不一致.</p></li></ul><h5 id="HashMap源码">HashMap源码</h5><p>writeObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    int buckets &#x3D; capacity();</span><br><span class="line">    &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s); &#x2F;&#x2F; 将有效的键值对进行了序列化.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到writeObject中序列化了buckets和size, 之后又通过internalWriteEntries方法将有效的键值对进行了序列化.</p><p>之后在readObject方法中反序列化时也要按照这个顺序.</p></blockquote><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                &#x2F;&#x2F; Read and ignore number of buckets</span><br><span class="line">    int mappings &#x3D; s.readInt(); &#x2F;&#x2F; Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; &#x2F;&#x2F; (if zero, use defaults)</span><br><span class="line">        &#x2F;&#x2F; Size the table using given load factor only if within</span><br><span class="line">        &#x2F;&#x2F; range of 0.25...4.0</span><br><span class="line">        float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;</span><br><span class="line">        int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft &#x3D; (float)cap * lf;</span><br><span class="line">        threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table &#x3D; tab;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key &#x3D; (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value &#x3D; (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按照顺序依次读出了:</p><ul><li>对象中非transient以及非static字段(defaultReadObject方法);</li><li>buckets, 但是被忽略了(见注释: Read and ignore number of buckets);</li><li>size(int mappings = s.readInt());</li><li>根据size遍历读取键值对(for (int i = 0; i &lt; mappings; i++)).</li></ul></blockquote><p>遍历读取的键值对最终依据新的规则保存到了新的map中, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key &#x3D; (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value &#x3D; (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList重写writeObject和readObject">ArrayList重写writeObject和readObject</h4><p>值得注意的是, ArrayList重写writeObject和readObject. 是因为在ArrayList中的数组容量基本上都会比实际的元素的数大, 为了避免序列化没有元素的数组而重写.</p><ul><li>writeObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in capacity</span><br><span class="line">    s.readInt(); &#x2F;&#x2F; ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a &#x3D; elementData;</span><br><span class="line">        &#x2F;&#x2F; Read in all elements in the proper order.</span><br><span class="line">        for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serialisation </tag>
            
            <tag> deserialisation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态委托</title>
      <link href="/2020/02/04/delegate-avance/"/>
      <url>/2020/02/04/delegate-avance/</url>
      
        <content type="html"><![CDATA[<p>接着上一篇的内容<br>大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;技术方法</span><br><span class="line">public interface OledTch &#123;</span><br><span class="line">&#x2F;&#x2F; 技术名称</span><br><span class="line">public void tchName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 色彩饱和度</span><br><span class="line">public void colorSaturation();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星</span><br><span class="line">public class Sumsung implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;98%NTSC - Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;华为</span><br><span class="line">public class Huawei implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;富士康</span><br><span class="line">public class Fotconn implements OledTch &#123;</span><br><span class="line">private OledTch oledMap; &#x2F;&#x2F;富土康的OLED生产图纸</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：甲方指定用哪家的图纸就用哪家的图纸</span><br><span class="line">public Fotconn(OledTch oledMap) &#123;</span><br><span class="line">this.oledMap &#x3D; oledMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：默认情况下，用华为的生产图纸</span><br><span class="line">public Fotconn() &#123;</span><br><span class="line">this.oledMap &#x3D; new Huawei();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">oledMap.tchName();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">                oledMap.colorSaturation();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class Xiaomi_Pipeline &#123;</span><br><span class="line"></span><br><span class="line">public void oled() &#123;</span><br><span class="line">Sumsung sumsung &#x3D; new Sumsung(); &#x2F;&#x2F; 确定使用三星的OLED技术</span><br><span class="line">Fotconn fotconn &#x3D; new Fotconn(sumsung);&#x2F;&#x2F; 告诉乙方 富土康：“我要三星图纸生产的OLED”</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小米正在生产: &quot;);</span><br><span class="line">fotconn.tchName();</span><br><span class="line">fotconn.colorSaturation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testXiaomi8() &#123;</span><br><span class="line">Xiaomi_Pipeline xiaomi8 &#x3D; new Xiaomi_Pipeline();</span><br><span class="line">xiaomi8.oled();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.39.03.png" alt="屏幕快照 2020-02-04 22.39.03" style="zoom:33%; "><p>我想讲一下我今天新学到的这个思路，就是动态代理，假象一个环境，我们用schduler来调控我们的任务，然后每一个任务对应不同的service，每个service我们有具体的实现方法，这时我们可以用到invoke的动态委托，我来画一个图。</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.04.13.png" alt="屏幕快照 2020-02-04 22.04.13" style="zoom:50%; "><h4 id="使用动态代理">使用动态代理</h4><h4 id="定义接口">定义接口</h4><p>下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下动态代理的简单实现，委托类和代理类都实现了Sell接口，Sell接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 委托类和代理类都实现了Sell接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Sell &#123; </span><br><span class="line">    void sell(); </span><br><span class="line">    void ad();</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler接口">InvocationHandler接口</h4><p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 调用处理程序</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface InvocationHandler &#123; </span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。</p><h4 id="委托类的定义">委托类的定义</h4><p>动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Vendor implements Sell &#123; </span><br><span class="line">    public void sell() &#123; </span><br><span class="line">        System.out.println(&quot;In sell method&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        System,out.println(&quot;ad method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中介类">中介类</h4><p>上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123; </span><br><span class="line">    &#x2F;&#x2F;obj为委托类对象; </span><br><span class="line">    private Object obj; </span><br><span class="line"> </span><br><span class="line">    public DynamicProxy(Object obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @Override </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span><br><span class="line">        System.out.println(&quot;before&quot;); </span><br><span class="line">        Object result &#x3D; method.invoke(obj, args); </span><br><span class="line">        System.out.println(&quot;after&quot;); </span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法</p><h3 id="动态生成代理类">动态生成代理类</h3><p>动态生成代理类的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123; </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建中介类实例 </span><br><span class="line">        DynamicProxy inter &#x3D; new DynamicProxy(new Vendor()); </span><br><span class="line">        &#x2F;&#x2F;加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取代理类实例sell </span><br><span class="line">        Sell sell &#x3D; (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter)); </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;通过代理类对象调用代理类方法，实际上会转到invoke方法调用 </span><br><span class="line">        sell.sell(); </span><br><span class="line">        sell.ad(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br></pre></td></tr></table></figure><p>复制代码方法的三个参数含义分别如下：<br>loader：定义了代理类的ClassLoder;<br>interfaces：代理类实现的接口列表<br>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例<br>我们运行一下，看看我们的动态代理是否能正常工作。我这里运行后的输出为</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cbbd27e07f9a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="代理模式">代理模式</h3><p>这个应该是设计模式中最简单的一个了，类图</p><p>代理模式最大的特点就是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作</p><p>Java动态代理其实内部也是通过Java反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后作一些相应的处理，这样说的比较笼统，举个简单的例子</p><p>比如我们在应用中有这样一个需求，在对某个类的一个方法的调用前和调用后都要做一下日志操作，</p><p>一个普通的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AppService &#123;  </span><br><span class="line">    public boolean createApp(String name);  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该接口的默认实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AppServiceImpl implements AppService &#123;  </span><br><span class="line">    public boolean createApp(String name) &#123;  </span><br><span class="line">        System.out.println(&quot;App[&quot;+name+&quot;] has been created.&quot;);  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>日志处理器（实质充当了中介类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 注意需实现Handler接口  </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LoggerInterceptor implements InvocationHandler &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;目标对象的引用，这里设计成Object类型，更具通用性  </span><br><span class="line">    public LoggerInterceptor(Object target)&#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] arg)  throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;Entered &quot;+target.getClass().getName()+&quot;-&quot;+method.getName()+&quot;,with arguments&#123;&quot;+arg[0]+&quot;&#125;&quot;);  </span><br><span class="line">        Object result &#x3D; method.invoke(target, arg);&#x2F;&#x2F;调用目标对象的方法  </span><br><span class="line">        System.out.println(&quot;Before return:&quot;+result);  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>外部调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AppService target &#x3D; new AppServiceImpl();&#x2F;&#x2F;生成目标对象  </span><br><span class="line">        &#x2F;&#x2F;接下来创建代理对象  </span><br><span class="line">        AppService proxy &#x3D; (AppService) Proxy.newProxyInstance(  </span><br><span class="line">                target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), new LoggerInterceptor(target));  </span><br><span class="line">        proxy.createApp(&quot;Kevin Test&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delegate </tag>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈java中的委托和继承</title>
      <link href="/2020/02/04/delagate-java/"/>
      <url>/2020/02/04/delagate-java/</url>
      
        <content type="html"><![CDATA[<p>上学的时候听到过委托这个词，写程序的时候自己用到过这种方式，面试的时候被问到过，做题的时候也有相关的练习，今天工作的时候debug看到我们自己也用到了delegate这个设计模式作为基类，所以就在这里总结一下。</p><p>为了区分继承 Inheritance，在这里将两者对比</p><h5 id="概念">概念</h5><p><strong>delegate和inheritance都可以提高代码的复用性</strong></p><ul><li><p>delegate：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象</p></li><li><p>继承：利用extends来扩展一个基类。</p></li></ul><hr><h5 id="Delegation（委托）">Delegation（委托）</h5><p>首先我们来看委托： 委托分为委托方和依赖方，他要求特定的方法在运行时调用不同的代码，这就是委托依赖与动态绑定，例如我们看一下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">void foo() &#123;</span><br><span class="line">this.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">System.out.println(&quot;a.bar&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在B类中，不使用继承，而是利用委托结合A，达到复用A类中代码的效果，其实平常我们在编程中也写过很多这样的例子只是不知道这种设计模式就是委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a &#x3D; a; </span><br><span class="line">    &#125;</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        a.foo(); &#x2F;&#x2F; call foo() on the a-instance &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;b.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面代码的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    A a &#x3D; new A();</span><br><span class="line">    B b &#x3D; new B(a); </span><br><span class="line">    b.foo();</span><br><span class="line">    b.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易地看出来结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.bar</span><br><span class="line">b.bar</span><br></pre></td></tr></table></figure><p>这就是一种简单的委派机制。</p><p>当然在当下IDP（控制反转：这里不多赘述了，之前也提到过这是spring的核心之一）的时代，接口才是王道，所以我们可以换另一种方式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoggingList&lt;E&gt; implements List&lt;E&gt;&#123;</span><br><span class="line"> private final List&lt;E&gt; list1;</span><br><span class="line">    public LoggingList(List&lt;E&gt; list) &#123; </span><br><span class="line">        this.list1 &#x3D; list; </span><br><span class="line">    &#125; </span><br><span class="line">    public boolean add(E e) &#123; </span><br><span class="line">        System.out.println(&quot;Adding &quot; + e); </span><br><span class="line">        return list1.add(e); </span><br><span class="line">    &#125; </span><br><span class="line">    public E remove(int index) &#123; </span><br><span class="line">        System.out.println(&quot;Removing at &quot; + index); </span><br><span class="line">        return list1.remove(index); </span><br><span class="line">    &#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">list1.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这就相当于我们重写add，remove和clear三个方法，但是没有继承</p><h4 id="委派的几种类型归纳">委派的几种类型归纳</h4><ul><li>Use (A use B)</li><li>Composition/aggregation (A owns B)</li><li>Association (A has B)</li></ul><h4 id="Dependency（依赖）-临时性的delegation">Dependency（依赖）: 临时性的delegation</h4><ul><li>在这种关系中，一个类使用另一个类而不将其作为一个属性。</li><li>两类之间的这种关系称为“uses-a”关系。例如，它可以是一个参数，或者在一个方法中本地使用，参考下面的代码：</li></ul><p>首先新建一个课程类：</p><p>public class Course {}</p><p>在课表类总使用课程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CourseSchedule &#123;</span><br><span class="line">    List&lt;Course&gt; courses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public void add (Course c) &#123;</span><br><span class="line">        courses.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove (Course c) &#123;</span><br><span class="line">        courses.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，并没有将Course类作为CourseSchedule类的属性来使用，而是作为迭代器中的元素和方法中的参数来使用。</p><h4 id="Association（关联）-永久性的delegation">Association（关联）: 永久性的delegation</h4><p>关联是类之间的持久关系，允许一个对象实例让另一个对象实例代表它自己做其他事。<br>这种关系属于has-a的关系，是结构化的，因为它指定了一种对象与另一种对象相连接，并且不代表行为，即不在该类的方法中使用另一个类的方法，只是简单的将不同的对象连接起来。</p><p>下面展示一下关联的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Teacher &#123;    </span><br><span class="line">private Student [] students;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;    </span><br><span class="line">private Teacher teacher;    </span><br><span class="line">Course[] selectedCourses; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在两个类中（Student和Teacher）互相都有彼此的实例，而且没有使用继承，就直接将这几个不同的类相连接，这就是利用了Association方式。</p><h4 id="Composition-更强的delegation">Composition: 更强的delegation</h4><p>组合是将简单对象或数据类型组合成更复杂的方法的一种方法。<br>这种关系是a-part-of关系，一个类有另一个属性或实例变量——实现了一个对象包含另一个对象。<br>let s show 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Heart &#123;&#125;</span><br><span class="line">class Person &#123; </span><br><span class="line">    private Heart heart &#x3D; new Heart();</span><br><span class="line">    public void operation () &#123; </span><br><span class="line">        heart.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式理解起来就很简单了，直接在该类中实例化一个其他类，然后该调用方法调用方法，对这个实例想怎么用怎么用，十分灵活。<br>不过需要注意的是：<br>这里的实例是private的，也就是说，外界访问不到，这样的话，更改其值只能在该方法中；而且每次创建该类的对象时，就已经创建好这个类中的实例；也就是说一旦创建好该类的对象，其中的属性指向便已经创建好。</p><h4 id="Aggregation">Aggregation</h4><p>聚集：对象存在于另一个之外，是在外部创建的，所以它作为一个参数传递给构造函数。<br>这种关系是has-a的关系，区别于</p><p>让我们看一个这个例子的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;&#125;</span><br><span class="line">class Course &#123; </span><br><span class="line">    private Student[] students; </span><br><span class="line">    public addStudent (Student s) &#123; </span><br><span class="line">        studtents.append(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这里，内部的属性是可以在外部指定的，而不是完全依赖该类。</p><h4 id="Composition-vs-Aggregation">Composition vs. Aggregation</h4><p>组合和聚集是最常用的两种delegation方式，可以说，其中的使用包括了依赖和关联方式，并在其上做了进一步的扩展。二者很相似，但又有很多不同之处，这里举一个例子看一下二者的最大不同之处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer(HttpListener listener, RequestProcessor processor) &#123;</span><br><span class="line">        this.listener &#x3D; listener;</span><br><span class="line">        this.processor &#x3D; processor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer() &#123; </span><br><span class="line">        this.listener &#x3D; new HttpListener(80); </span><br><span class="line">        this.processor &#x3D; new RequestProcessor(“&#x2F;www&#x2F;root”);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inheritance（继承）">Inheritance（继承）</h4><p>继承就很好说了，直接是一个类利用extends扩展其父类，而且一个类只能扩展一个父类，但是可以多层扩展。<br>参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        this.bar(); </span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;A.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    public B() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void foo() &#123; </span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        System.out.println(&quot;B.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以猜一下下面代码的输出的结果，比较有趣：</p><p>B b = new B();<br>b.foo();<br>我这里运行的结果是</p><p>B.bar<br>可以看到，在继承中，子类拥有父类所有的方法，而且还可以继续增加父类中没有的方法。</p><h4 id="适用于不同场合">适用于不同场合</h4><p>总而言之，委派和继承都是为了代码复用，只是方式不同。</p><ul><li>委托可以被看作是对象级别的重用机制，而继承是类级别的重用机制。</li><li>此外，如果子类只需要复用父类中的一小部分方法，可以不需 要使用继承，而是通过委派机制来实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delegate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rmi_java_springboot</title>
      <link href="/2020/01/30/rmi-java-springboot/"/>
      <url>/2020/01/30/rmi-java-springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker vs VM 与 web url的关系</title>
      <link href="/2020/01/26/computerwebadnresources/"/>
      <url>/2020/01/26/computerwebadnresources/</url>
      
        <content type="html"><![CDATA[<h3 id="1-What-Happens-When-You-Type-in-a-URL">1 What Happens When You Type in a URL?</h3><p>1 enter url in browser</p><p>2 browser look up ip address of domaine via dns</p><p>3 browser send a request to server</p><p>4 server returns a http response</p><p>5 browser rends html</p><p>6 browser need css js images then repeat 3-5</p><p>7 finish loading, send futur async request</p><h3 id="2-How-Web-Browsers-and-Web-Servers-Communicate">2 How Web Browsers and Web Servers Communicate?</h3><p>Web browsers and servers communicate using TCP/IP. Hypertext Transfer Protocol is the standard application protocol on top of TCP/IP supporting web browser requests and server responses</p><p>Web browsers also rely on DNSto work with URLs. These protocol standards enable different brands of web browsers to communicate with different brands of web servers without requiring special logic for each combination.</p><p>1 A person specifies a URL in a browser.</p><p>2  The browser initiates a TCP connection to the web server or server pool (using port 80 by default). As part of this process, the browser also makes DNS lookup requests to convert the URL to an IP address.</p><p>3 After the server completes acknowledgment of its side of the TCP connection, the browser sends HTTP requests to the server to retrieve the content.</p><p>4 after the server replies with content for the page, the browser retrieves it from the HTTP packets and displays it accordingly. Content can include embedded URLs for advertising banners or other external content, that in turn triggers the browser to issue new TCP connection requests to those locations. The browser may also save temporary information about its connections to local files on the client computer called <em>cookies</em>.</p><p>5 Any errors encountered during the request for the content might be shown as http status error line</p><h3 id="3-what-is-microservice-architecture">3 what is microservice architecture?</h3><p>A microservices architecture takes this same approach and extends it to the loosely coupled services which can be developed, deployed, and maintained independently. Each of these services is responsible for discrete task and can communicate with other services through simple APIs to solve a larger complex business problem.</p><p>Once developed, these services can also be deployed independently of each other and hence its easy to identify hot services and scale them independent of whole application. Microservices also offer improved fault isolation whereby in the case of an error in one service the whole application doesn’t necessarily stop functioning. When the error is fixed, it can be deployed only for the respective service instead of redeploying an entire application.</p><p>Another advantage which a microservices architecture brings to the table is making it easier to choose the technology stack (programming languages, databases, etc.) which is best suited for the required functionality (service) instead of being required to take a more standardized, one-size-fits-all approach.</p><h3 id="4-Difference-between-docker-and-vm">4 Difference between docker and vm?</h3><p>Docker is virtual machine that was more lightweight, economical, and scalable. Docker is a container-based technology that lets you develop distributed applications</p><p>**A virtual machine is a system which acts exactly like a computer.**In simple terms, it makes it possible to run what appears to be on many separate computers on hardware, that is one computer. Each virtual machine requires its underlying operating system, and then the hardware is virtualized.</p><p>**Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container</p><p><strong>. Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container.</strong></p><img src="https://geekflare.com/wp-content/uploads/2019/09/traditional-vs-new-gen.png" alt="Traditional vs New Gen" style="zoom:60%; "><p>The operating system support of Virtual machine and Docker container is very different. From the image above, you can see each virtual machine has its guest operating system above the host operating system, which makes virtual machines heavy. While on the other hand, Docker containers share the host operating system, and that is why they are lightweight.</p><p>Sharing the host operating system between the containers make them very light and helps them to boot up in just a few seconds. Hence, the overhead to manage the container system is very low compared to that of virtual machines.</p><p>The docker containers are suited for situations where you want to run multiple applications over a single operating system kernel.<strong>But if you have applications or servers that need to run on different operating system flavors, then virtual machines are required.</strong></p><p><strong>Security</strong></p><p>The virtual machine does no share operating system, and there is strong isolation in the host kernel. Hence, they are more secure as compared to Containers. A container have a lot of security risks, and vulnerabilities as the containers have shared host kernel.</p><p><strong>Portability</strong></p><p>Docker containers are easily portable because they do not have separate operating systems. A container can be ported to a different OS, and it can start immediately. On the other hand, virtual machines have separate OS, so porting a virtual machine is difficult as compared to containers, and it also takes a lot of time to port a virtual machine because of its size.</p><p>For development purposes where the applications must be developed and tested in different platforms, Docker containers are the ideal choice.</p><p><strong>Performance</strong></p><p>Comparing Virtual machines and Docker Containers would not be fair because they both are used for different purposes. But the lightweight architecture of docker its less resource-intensive feature makes it a better choice than a virtual machine. As a result, of which containers can startup very fast compared to that of virtual machines, and the resource usage varies depending on the load or traffic in it.</p><p>Unlike the case of virtual machines, there is no need to allocate resources permanently to containers. Scaling up and duplicating the containers is also an easy task compared to that of virtual machines, as there is no need to install an operating system in them.</p><table><thead><tr><th><strong>Virtual Machine</strong></th><th><strong>Docker Container</strong></th></tr></thead><tbody><tr><td>Hardware-level process isolation</td><td>OS level process isolation</td></tr><tr><td>Each VM has a separate OS</td><td>Each container can share OS</td></tr><tr><td>Boots in minutes</td><td>Boots in seconds</td></tr><tr><td>VMs are of few GBs</td><td>Containers are lightweight (KBs/MBs)</td></tr><tr><td>Ready-made VMs are difficult to find</td><td>Pre-built docker containers are easily available</td></tr><tr><td>VMs can move to new host easily</td><td>Containers are destroyed and re-created rather than moving</td></tr><tr><td>Creating VM takes a relatively longer time</td><td>Containers can be created in seconds</td></tr><tr><td>More resource usage</td><td>Less resource usage</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring高频面试题</title>
      <link href="/2020/01/26/springBootMVC/"/>
      <url>/2020/01/26/springBootMVC/</url>
      
        <content type="html"><![CDATA[<h3 id="基本常识">基本常识</h3><hr><p>使用Spring框架的好处是什么？**</p><ul><li>**轻量：**Spring是轻量的，基本的版本大约2MB。</li><li>**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li>**面向切面的编程(AOP)：**Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li>**容器：**Spring包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li>**事务管理：**Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li>**异常处理：**Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛出的）转化为一致的unchecked异常。</li></ul><p><strong>Spring由哪些模块组成?</strong></p><p>以下是Spring框架的基本模块：</p><ul><li><p>Coremodule</p><p>spring core模块是spring的核心容器，它实现了<strong>ioc</strong>模式，提供了spring框架的基础功能。此模块中包含的beanfactory类是spring的核心类，负责javabean的配置与管理。它采用factory模式实现了ioc即依赖注入。</p></li><li><p>Beanmodule</p><p>谈到javabean，它是一种 java 类，它遵从一定的设计模式，使它们易于和其他开发工具和组件一起使用。定义 javabean 是一种java 语言写成的可重用组件。要编写javabean，类必须是具体类和公共类，并且具有无参数的构造器。</p></li><li><p>Contextmodule</p><p>pring context模块继承beanfactory（或者说spring核心）类，并且添加了事件处理、国际化、资源装载、透明装载、以及数据校验等功能。它还提供了框架式的bean的访问方式和很多企业级的功能，如jndi访问、支持ejb、远程调用、集成模板框架、email和定时任务调度等。</p></li><li><p>ExpressionLanguagemodule</p></li><li><p>dao模块</p></li></ul><p>dao是 data access object的缩写，dao模式思想是将业务逻辑代码与数据库交互代码分离，降低两者耦合。通过dao模式可以使结构变得更为清晰，代码更为简洁。dao模块提供了jdbc的抽象层，简化了数据库厂商的异常错误（不再从sqlexception继承大批代码），大幅度减少代码的编写，并且提供了对声明式事务和编程式事务的支持。</p><ul><li>orm映射模块</li></ul><p>spring orm 模块提供了对现有orm框架的支持，各种流行的orm框架已经做得非常成熟，并且拥有大规模的市场，spring没有必要开发新的orm工具，它对hibernate提供了完美的整合功能，同时也支持其他orm工具。注意这里spring是提供各类的接口（support），目前比较流行的下层数据库封闭映射框架，如 ibatis, hibernate等</p><p><strong>为什么说Spring是一个容器？</strong></p><p>因为用来形容它用来存储单例的bean对象这个特性。</p><p><strong>Spring配置文件</strong></p><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><p><strong>什么是SpringIOC容器？</strong></p><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p><strong>IOC的优点是什么？</strong></p><p>IOC或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><p><strong>ApplicationContext通常的实现是什么?</strong></p><ul><li>**FileSystemXmlApplicationContext：**此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li><li>**ClassPathXmlApplicationContext：**此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li>**WebXmlApplicationContext：**此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><h3 id="依赖注入">依赖注入</h3><hr><p>什么是Spring的依赖注入？**</p><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><ul><li><p>**构造器依赖注入：**构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 强制依赖</p></li><li><p>**Setter方法注入：**Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 可选依赖</p></li></ul><h3 id="Springbeans">Springbeans</h3><hr><p><strong>什么是Springbeans?</strong></p><p>Springbeans是那些形成Spring应用的主干的java对象。它们被SpringIOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean>的形式定义。</bean></p><p>Spring框架定义的beans都是单件beans。在beantag中有个属性”singleton”，如果它被赋为TRUE，bean就是单件，否则就是一个prototypebean。默认是TRUE，所以所有在Spring框架中的beans缺省都是单件。</p><p><strong>Spring框架中的单例bean是线程安全的吗?</strong></p><p>不，Spring框架中的单例bean不是线程安全的。</p><p><strong>解释Spring框架中bean的生命周期。</strong></p><ul><li>Spring容器从XML文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware接口，Spring传递bean的ID到setBeanName方法。</li><li>如果Bean实现了BeanFactoryAware接口，Spring传递beanfactory给setBeanFactory方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors和bean关联，这些bean的postProcessAfterInitialization()方法将被调用。</li><li>如果bean实现了DisposableBean，它将调用destroy()方法。</li></ul><p><strong>哪些是重要的bean生命周期方法？你能重载它们吗？</strong></p><p>有两个重要的bean生命周期方法，第一个是setup，它是在容器加载bean的时候被调用。第二个方法是teardown它是在容器卸载类的时候被调用。</p><p>Thebean标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><p><strong>什么是Spring的内部bean？</strong></p><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义innerbean，在Spring的基于XML的配置元数据中，可以在<property>或<constructor-arg>元素内使用<bean>元素，内部bean通常是匿名的，它们的Scope一般是prototype。</bean></constructor-arg></property></p><p><strong>在Spring中如何注入一个java集合？</strong></p><p>Spring提供以下几种集合的配置元素：</p><ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为String类型。</props></li></ul><p><strong>什么是bean装配?</strong></p><p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><p><strong>什么是bean的自动装配？</strong></p><p>Spring容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p><p><strong>自动装配有哪些局限性?</strong></p><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p>**模糊特性：**自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><p><strong>解释不同方式的自动装配。</strong></p><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ul><li><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref属性来进行装配。</li><li>**byName：**通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li>**byType:：**通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li><strong>constructor：这个方式类似于</strong>byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>**autodetect：**首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><h3 id="Spring-注解">Spring 注解</h3><hr><p><strong>什么是基于Java的Spring注解配置? 给一些注解的例子.</strong></p><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration注解为例，它用来标记类可以当做一个bean的定义，被SpringIOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><p><strong>什么是基于注解的容器配置?</strong></p><p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p><p>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p><p><strong>怎样开启注解装配？</strong></p><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<a href="context:annotation-config/">context:annotation-config/</a>元素。</p><p><strong>@Required注解</strong></p><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p><p><strong>@Autowired注解</strong></p><p>@Autowired注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p><p><strong>@Qualifier注解</strong></p><p>当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p><h3 id="Spring-数据访问">Spring 数据访问</h3><hr><p><strong>在Spring框架中如何更有效地使用JDBC?</strong></p><p>使用SpringJDBC框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements和queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><p>Add jDBC dependency -&gt; Instance class -&gt; DaoInterface -&gt; JDBCObjectImp</p><p><strong>JdbcTemplate</strong></p><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><p><strong>pring对DAO的支持</strong></p><p>Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，HibernateorJDO结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p><p><strong>使用Spring通过什么方式访问Hibernate?</strong></p><p>在Spring中有两种方式访问Hibernate：</p><p>控制反转HibernateTemplate和Callback。</p><p>继承HibernateDAOSupport提供一个AOP拦截器。</p><p><strong>Spring支持的ORM</strong></p><p>Spring支持以下ORM：</p><ul><li>Hibernate</li><li>iBatis</li><li>JPA(JavaPersistenceAPI)</li><li>TopLink</li><li>JDO(JavaDataObjects)</li><li>OJB</li></ul><p><strong>Spring支持的事务管理类型</strong></p><p>Spring支持两种类型的事务管理：</p><p>· <strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>· **声明式事务管理：**这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><p><strong>你更倾向用那种事务管理类型？</strong></p><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p><h4 id="Spring面向切面编程（AOP）"><strong>Spring面向切面编程（AOP）</strong></h4><hr><p><strong>解释AOP</strong></p><p>面向切面的编程，或AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p><p><strong>Aspect切面</strong></p><p>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在SpringAOP中，切面通过带有@Aspect注解的类实现。</p><p><strong>在SpringAOP中，关注点和横切关注的区别是什么？</strong></p><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p><strong>通知</strong></p><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用五种类型的通知：</p><p><strong>before</strong>：前置通知，在一个方法执行前被调用。</p><p>**after:**在方法执行之后调用的通知，无论方法执行是否成功。</p><p>**after-returning:**仅当方法成功完成后执行的通知。</p><p>**after-throwing:**在方法抛出异常退出时执行的通知。</p><p>**around:**在方法执行之前和之后调用的通知。</p><p><strong>什么是代理?</strong></p><p>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的</p><p><strong>解释基于XMLSchema方式的切面实现。</strong></p><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h4 id="Spring的MVC"><strong>Spring的MVC</strong></h4><hr><p><strong>什么是Spring的MVC框架？</strong></p><p>Spring配备构建Web应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p><p><strong>DispatcherServlet</strong></p><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><p><strong>WebApplicationContext</strong></p><p>WebApplicationContext继承了ApplicationContext并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的servlet。</p><p><strong>什么是SpringMVC框架的控制器？</strong></p><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><p><strong>@Controller注解</strong></p><p>该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用ServletAPI。</p><p><strong>@RequestMapping注解</strong></p><p>该注解是用来映射一个URL到一个类或一个特定的方处理法上。</p><p><strong>返回Json用什么注解？</strong></p><p>@ResponseBody</p><h4 id="Spring事务支持的隔离级别">Spring事务支持的隔离级别</h4><hr><p>Spring 事务上提供以下的隔离级别:</p><ul><li>ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别</li><li>ISOLATION_READ_UNCOMMITTED　: 允许读取未提交的数据变更，可能会导致脏读，幻读或不可重复读</li><li>ISOLATION_READ_COMMITTD : 允许读取为提交数据, 可以阻止脏读，当时幻读或不可重复读仍可能发生</li><li>ISOLATION_REPEATABLE_READ: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生</li><li>ISOLATION_SERIALIZABLE :　完全服从ACID</li></ul>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode SQL 175-185整理</title>
      <link href="/2020/01/26/leetcodeSQL/"/>
      <url>/2020/01/26/leetcodeSQL/</url>
      
        <content type="html"><![CDATA[<p>SQL 例题整理 查询用mysql实现</p><h3 id="175-Combine-Two-Tables组合两个表">175. Combine Two Tables组合两个表</h3><img src="/2020/01/26/leetcodeSQL/sql175.png" alt="sql175" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT P.FirstName, P.LastName, A.City, A.State</span><br><span class="line">FROM Person AS P LEFT JOIN Address AS A</span><br><span class="line">ON P.PersonId &#x3D; A.PersonId;</span><br></pre></td></tr></table></figure><h3 id="176-Second-Highest-Salary-第二高的薪水">176. Second Highest Salary 第二高的薪水</h3><img src="/2020/01/26/leetcodeSQL/sql176.png" alt="sql176" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">select </span><br><span class="line">(SELECT DISTINCT</span><br><span class="line">    Salary </span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">ORDER BY Salary DESC</span><br><span class="line">LIMIT 1 OFFSET 1) as SecondHighestSalary</span><br><span class="line"></span><br><span class="line">2 </span><br><span class="line">select max(salary) as SecondHighestSalary</span><br><span class="line">from employee</span><br><span class="line">where salary &lt; (select max(salary) from employee);</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) AS SecondHighestSalary</span><br></pre></td></tr></table></figure><h3 id="177-Nth-Highest-Salary">177. Nth Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql177.png" alt="sql177" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    declare m int;</span><br><span class="line">    set m &#x3D; n-1;</span><br><span class="line"> RETURN (</span><br><span class="line">   select distinct salary from employee order by salary desc limit m,1</span><br><span class="line"> );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="178-rank-scores">178.rank scores</h3><img src="/2020/01/26/leetcodeSQL/sql178.png" alt="sql178" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(distinct Score) FROM Scores WHERE Score &gt;&#x3D; s.Score) Rank</span><br><span class="line">FROM Scores s</span><br><span class="line">ORDER BY Score desc</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) as tm WHERE s &gt;&#x3D; Score) as Rank</span><br><span class="line">FROM Scores</span><br><span class="line">ORDER BY Score desc</span><br></pre></td></tr></table></figure><h3 id="180-Consecutive-number">180. Consecutive number</h3><img src="/2020/01/26/leetcodeSQL/sql180.png" alt="sql180" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    l1.Num AS ConsecutiveNums</span><br><span class="line">FROM</span><br><span class="line">    Logs l1,</span><br><span class="line">    Logs l2,</span><br><span class="line">    Logs l3</span><br><span class="line">WHERE</span><br><span class="line">    l1.Id &#x3D; l2.Id - 1</span><br><span class="line">    AND l2.Id &#x3D; l3.Id - 1</span><br><span class="line">    AND l1.Num &#x3D; l2.Num</span><br><span class="line">    AND l2.Num &#x3D; l3.Num</span><br></pre></td></tr></table></figure><h3 id="181-Employees-Earning-More-Than-Their-Managers超过经理收入的员工">181. Employees Earning More Than Their Managers超过经理收入的员工</h3><img src="/2020/01/26/leetcodeSQL/sql181.png" alt="sql181" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT E1.Name AS Employee</span><br><span class="line">FROM Employee AS E1 INNER JOIN Employee AS E2</span><br><span class="line">ON E1.ManagerId &#x3D; E2.Id</span><br><span class="line">WHERE E1.Salary &gt; E2.Salary;</span><br></pre></td></tr></table></figure><h3 id="182-Duplicate-Emails查找重复的电子邮箱">182. Duplicate Emails查找重复的电子邮箱</h3><img src="/2020/01/26/leetcodeSQL/sql182.png" alt="sql182" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email</span><br><span class="line">FROM Person</span><br><span class="line">GROUP BY Email</span><br><span class="line">HAVING COUNT(Id) &gt; 1;</span><br></pre></td></tr></table></figure><h3 id="183-Customers-Who-Never-Order">183. Customers Who Never Order</h3><img src="/2020/01/26/leetcodeSQL/sql183.png" alt="sql183" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.name as Customers</span><br><span class="line">from customers as c</span><br><span class="line">where c.id not in (select o.CustomerId from orders as o)</span><br></pre></td></tr></table></figure><h3 id="184-Department-Highest-Salary">184. Department Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql184.png" alt="sql184" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    Department.name AS &#39;Department&#39;,</span><br><span class="line">    Employee.name AS &#39;Employee&#39;,</span><br><span class="line">    Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department ON Employee.DepartmentId &#x3D; Department.Id</span><br><span class="line">WHERE</span><br><span class="line">    (Employee.DepartmentId , Salary) IN</span><br><span class="line">    (   SELECT</span><br><span class="line">            DepartmentId, MAX(Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        GROUP BY DepartmentId</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="185-Departement-top-3-salary">185. Departement top 3 salary</h3><img src="/2020/01/26/leetcodeSQL/sql185.png" alt="sql185" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee e1</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department d ON e1.DepartmentId &#x3D; d.Id</span><br><span class="line">WHERE</span><br><span class="line">    3 &gt; (SELECT</span><br><span class="line">            COUNT(DISTINCT e2.Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee e2</span><br><span class="line">        WHERE</span><br><span class="line">            e2.Salary &gt; e1.Salary</span><br><span class="line">                AND e1.DepartmentId &#x3D; e2.DepartmentId</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id></h3>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring, Spring MVC, SpringBoot介绍</title>
      <link href="/2020/01/26/spring/"/>
      <url>/2020/01/26/spring/</url>
      
        <content type="html"><![CDATA[<p>浅谈spring springMVC Springboot三者</p><blockquote><p>The <strong>Spring Framework</strong> is an application framework and inversion of control container for the Java platform. The framework’s core features can be used by any Java application, but there are extensions for building web applications on top of the Java EE (Enterprise Edition) platform. Although the framework does not impose any specific programming model, it has become popular in the Java community as an addition to, or even replacement for the Enterprise JavaBeans (EJB) model. The Spring Framework is open source.</p></blockquote><h4 id="什么是Spring">什么是Spring</h4><p>我们说到Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，<strong>通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等</strong>，比如基于Spring的项目里经常能看到的 <code>Bean</code> ，它代表的就是由Spring管辖的对象。</p><p>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个 <code>WelcomeService</code> 服务接口，一般情况下都是通过 <code>WelcomeService service = new WelcomeServiceImpl();</code> 创建实例并进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> WelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换 <code>WelcomeServiceImpl</code> 为一个 <code>MockWelcomeServiceImpl</code> ，以方便测试，怎么办？没有其他办法，只有改代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> MockWelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；<br>下面看通过Spring的IOC如何实现，首先将 <code>WelcomeService</code> 交由Spring管理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.WelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/welcome"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String welcome() &#123;</span><br><span class="line">        <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，只需要更改配置文件，将 <code>WelcomeService</code> 对应的实现改为 <code>MockWelcomeServiceImpl</code> 即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这种方式对业务代码没有任何侵入，<strong>它有效的实现松耦合</strong>，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等</p><p><strong>纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案</strong></p><h4 id="什么是Spring-MVC？">什么是Spring MVC？</h4><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），<strong>主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易</strong>，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.qgd.oms.web.common.mvc.OmsDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/css/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">location</span>=<span class="string">"/static/views/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/fonts/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/lib/ueditor/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/img/"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.validationQuery&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultAutoCommit"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxOpenPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"configService"</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.ConfigService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configStore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.impl.DbConfigStore"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskScheduler"</span> <span class="attr">ref</span>=<span class="string">"defaultScheduler"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"refreshInterval"</span> <span class="attr">value</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若需添加其它功能，如security，则需添加对应配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/css/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/js/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/img/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span> <span class="attr">entry-point-ref</span>=<span class="string">"omsAuthenticationEntryPoint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logout</span> <span class="attr">logout-url</span>=<span class="string">"/omsmc/authentication/logout/*"</span> <span class="attr">success-handler-ref</span>=<span class="string">"omsLogoutSuccessHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">logout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/omsmc/authentication/login*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/ms/**/*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/**'</span> <span class="attr">access</span>=<span class="string">"authenticated"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;security:form-login /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-filter</span> <span class="attr">ref</span>=<span class="string">"omsUsernamePasswordAuthenticationFilter"</span> <span class="attr">position</span>=<span class="string">"FORM_LOGIN_FILTER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remember-me</span> <span class="attr">services-ref</span>=<span class="string">"omsRememberMeServices"</span> <span class="attr">key</span>=<span class="string">"yfboms"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h4 id="什么是Spring-Boot？">什么是Spring Boot？</h4><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node. Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于<strong>实现自动配置，降低项目搭建的复杂度</strong>，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入spring-boot-starter-web依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-starter-web&lt;/</span>artifactId&gt;</span><br><span class="line">&lt;<span class="regexp">/dependency&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Spring Boot应用，直接写业务逻辑即可</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"how are you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MockServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为 <code>spring-boot-starter-web</code> 模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是<strong>约定优于配置</strong>原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持</p><p>在Spring Boot中，你会发现你引入的所有包都是<em>starter</em>形式，如：</p><ul><li><code>spring-boot-starter-web-services</code> ，针对SOAP Web Services</li><li><code>spring-boot-starter-web</code> ，针对Web应用与网络接口</li><li><code>spring-boot-starter-jdbc</code> ，针对JDBC</li><li><code>spring-boot-starter-data-jpa</code> ，基于hibernate的持久层框架</li><li><code>spring-boot-starter-cache</code> ，针对缓存支持</li></ul><p>Spring Boot对starter的解释如下：</p><blockquote><p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</p></blockquote><h1>Spring，Spring MVC，Spring Boot 三者比较</h1><p>其实写到这里，很多读者应该已经清楚，这三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能，下面用一张图来描述三者的关系：</p><img src="/2020/01/26/spring/mvc_spring_boot.png" alt="mvc_spring_boot" style="zoom:33%;"><p>最后一句话总结：<strong>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql高频概念</title>
      <link href="/2020/01/25/sqlExecuteProcess/"/>
      <url>/2020/01/25/sqlExecuteProcess/</url>
      
        <content type="html"><![CDATA[<h4 id="SQL">SQL</h4><blockquote><p>SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system.</p></blockquote><h4 id="sql语法的分析是从右到左">sql语法的分析是从右到左</h4><p>1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。<br>2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。<br>3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。<br>5）选择优化器，不同的优化器一般产生不同的“执行计划”<br>6）选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。<br>7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。<br>8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>9）运行“执行计划”</p><h4 id="select-语句执行顺序">select 语句执行顺序</h4><p>1 from子句组装来自不同数据源的数据；</p><p>2 where子句基于指定的条件对记录行进行筛选；</p><p>3 group by子句将数据划分为多个分组；</p><p>4 使用聚集函数进行计算；</p><p>5 使用having子句筛选分组；</p><p>6 计算所有的表达式；</p><p>7 select 的字段；</p><p>8 使用order by对结果集进行排序。<br>SQL语言不同于其他编程语言的最明显特征是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语句中，第一个被处理的子句式FROM，而不是第一出现的SELECT。SQL查询处理的步骤序号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)SELECT (9) DISTINCT (11) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(1)  FROM &lt;left_table&gt;</span><br><span class="line">(3) &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(2) ON &lt;join_condition&gt;</span><br><span class="line">(4) WHERE &lt;where_condition&gt;</span><br><span class="line">(5) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6) WITH &#123;CUBE | ROLLUP&#125;</span><br><span class="line">(7) HAVING &lt;having_condition&gt;</span><br><span class="line">(10) ORDER BY &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><h4 id="where与having的区别">where与having的区别</h4><p>对需要进行分组的数据进行限制，汇总函数不能用在 WHERE 子句中，而是要用HAVING 子句 。HAVING子句允许你将汇总函数作为条件。</p><h4 id="UNION与UNION-ALL合并">UNION与UNION ALL合并</h4><p>UNION将返回两个查询的结果并去除其中的重复部分，UNION ALL与UNION一样对表进行了合并，但是它不去掉重复的记录。</p><h4 id="数据定义语言">数据定义语言</h4><p>Data definition language</p><blockquote><p>A <strong>data definition</strong> or <strong>data description language</strong> (<strong>DDL</strong>) is a syntax similar to a computer <a href="https://en.wikipedia.org/wiki/Programming_language" target="_blank" rel="noopener">programming language</a> for defining <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener">data structures</a>, especially <a href="https://en.wikipedia.org/wiki/Database_schema" target="_blank" rel="noopener">database schemas</a>. DDL statements create and modify database objects such as tables, indexes, and users. Common DDL statements are CREATE, ALTER, and DROP</p></blockquote><p>类似于我们编程的数据结构，用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束，DDL不需要commit.</p><h4 id="数据操作语言">数据操作语言</h4><p><strong>DML</strong>（<strong>Data Manipulation Language</strong>）<strong>数据操纵语言</strong>statements are used for managing data within schema objects.</p><p>由DBMS提供，用于让用户或程序员使用，实现对数据库中数据的操作。<br>DML分成交互型DML和嵌入型DML两类。<br>依据语言的级别，DML又可分成过程性DML和非过程性DML两种。<br>需要commit.<br>SELECT<br>INSERT<br>UPDATE<br>DELETE<br>MERGE<br>CALL<br>EXPLAIN PLAN<br>LOCK TABLE</p><h4 id="数据库控制语言"><strong>数据库控制语言</strong></h4><p><strong>DCL</strong>（<strong>Data Control Language</strong>）<strong>数据库控制语言</strong> 授权，角色控制等<br>GRANT 授权<br>REVOKE 取消授权</p><h4 id="TCL-（Transaction-Control-Language）-事务控制语言">TCL**（<strong>Transaction Control Language</strong>）**事务控制语言</h4><p>SAVEPOINT 设置保存点<br>ROLLBACK 回滚<br>SET TRANSACTION</p><h4 id="Turncate-和-drop">Turncate 和 drop</h4><p>turncate只删除表中的数据，不触碰表的结构。drop删除整个表，<strong>小心使用drop与turncate，因为他们是数据定义语言，不能roll back</strong></p><h4 id="MINUS相减">MINUS相减</h4><p>返回的记录是存在于第一个表中但不存在于第二个表中的记录。如果解释器不支持一般用table_name1 t2 LEFT OUTER JOIN table_name2 t2 WHERE t2.col_name IS NULL;</p><h4 id="关于空值【高频】"><strong>关于空值【高频】</strong></h4><p>SQL中的空值是NULL，空值是不能用等号来比较的，而是要用IS NULL或者IS NOT NULL来判断值是否为空值。</p><p>面试的时候往往需要在输出结果中对空值进行处理，这时候最好用的就是IFNULL函数和ISNULL函数了。<strong>IFNULL</strong>是当SQL查询某个字段为空的时候，查询结果中设置其值为默认值。<strong>ISNULL</strong>使用指定的替换值替换 NULL：<br>ISNULL (检查的对象, 如果为空值替换的值)</p><p>可惜，MySQL中ISNULL只是用来判断是否为空，不能实现替换功能，所以用IFNULL代替，语法和上面的ISNULL一样。</p><h4 id="返回前几行【高频】"><strong>返回前几行【高频】</strong></h4><p>MySQL的LIMIT+数字和TOP子句是等价的，并非所有的数据库系统都支持 TOP 子句。所以我们来简单看一下limit+offset的用法。以下这两句都合乎语法，但是有区别：</p><p>select * from table_name limit 3,1;        # 跳过前3条数据，从数据库中第4条开始查询，取一条数据，即第4条数据<br>select * from table_name limit 3 offset 1;   # 从数据库中的第2条数据开始查询3条数据，即第2条到第4条</p><p>记住这两句，再加上order by column_name (desc) 就能应付“消费第二多的客户”、“点击量第5到20名”之类的问题的。</p><h4 id="条件语句【中频】"><strong>条件语句【中频】</strong></h4><p>条件语句考得并不多，但是如果很久不用MySQL就容易忘记。MySQL里常用的条件语句是Case。Case语句分为两种：简单Case函数和Case搜索函数。</p><p>- 简单Case函数：<br>CASE gender WHEN ‘0’ THEN ‘male’ WHEN ‘1’ THEN ‘female’ ELSE ‘others’ END<br>- Case搜索函数：<br>CASE WHEN age &lt; 18 THEN ‘未成年人’ WHEN age &lt; 60 THEN ‘成年人’ ELSE ‘老年人’ END</p><p>Case语句只返回第一个符合条件的结果，剩下的条件会被自动忽略，比如上例中一个数据的age为16，那么它就在第一个case中被返回，不会进入第二个when中进行判断，因此返回’未成年人’而不是’成年人’。</p><h4 id="随机抽样【低频】"><strong>随机抽样【低频】</strong></h4><p>有时候面试会考到如何在SQL表中随机抽样，这时候就要用到RAND()函数。</p><p>通常被面试者的第一反应是：SELECT * FROM table ORDER BY RAND() LIMIT 10000，这样来抽取一万个样本。但是如果数据量很大，上述的做法太慢了：它对于每一行都用了RAND()函数，这一步复杂度是O(n)；然后再排序，这一步的复杂度O(nlogn)。</p><p>所以可以改用这个方法：SELECT * FROM table WHERE RAND() &lt;= .3，这样可以抽出约30%的数据，然后再用TOP或者LIMIT子句。</p><h4 id="自然连接和内链接区别">自然连接和内链接区别</h4><p>自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列，但是相同列的数量不能大于1</p><h4 id="subquery和join的对比">subquery和join的对比</h4><p>与子查询相比，join的查询效率还是比子查询高，因为使用子查询时，数据库还要建一张临时表</p><h4 id="子查询执行顺序">子查询执行顺序</h4><p>带有子查询时，先执行子查询在执行主查询</p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20道SQL 面试题帮你拿到第一个offer</title>
      <link href="/2020/01/25/sql20questions/"/>
      <url>/2020/01/25/sql20questions/</url>
      
        <content type="html"><![CDATA[<h3 id="基本语法">基本语法</h3><p><strong>创建表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE table_name (</span><br><span class="line"> column1 datatype null or not null(optional),</span><br><span class="line"> column2 datatype null or not null(optional),</span><br><span class="line"> column3 datatype null or not null(optional),</span><br><span class="line">  ....</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure><p><strong>删除表中数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><p><strong>修改：添加列，删除列，修改列名，数据类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP COLUMN DateOfBirth;</span><br><span class="line"></span><br><span class="line">-- 修改列名</span><br><span class="line">alter table table_name </span><br><span class="line">rename column oldname to newname</span><br><span class="line"></span><br><span class="line">-- 修改列的数据类型</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name datatype;</span><br></pre></td></tr></table></figure><h4 id="常见问题">常见问题</h4><p><strong>1 查询姓“孟”老师的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(教师号)</span><br><span class="line">from teacher</span><br><span class="line">where 教师姓名 like &#39;孟%&#39;;</span><br></pre></td></tr></table></figure><p><strong>2 查询课程编号为“0002”的总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sum(成绩)</span><br><span class="line">from score</span><br><span class="line">where 课程号 &#x3D; &#39;0002&#39;;</span><br></pre></td></tr></table></figure><p><strong>3 查询选了课程的学生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct 学号) as 学生人数 </span><br><span class="line">from score;</span><br></pre></td></tr></table></figure><h4 id="练习-分组">练习 分组</h4><p><strong>4 查询各科成绩最高和最低的分， 以如下的形式显示：课程号，最高分，最低分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号,max(成绩) as 最高分,min(成绩) as 最低分</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>5 查询每门课程被选修的学生</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, count(学号)</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>6 查询男生、女生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 性别,count(*)</span><br><span class="line">from student</span><br><span class="line">group by 性别;</span><br></pre></td></tr></table></figure><h4 id="分组结果的条件">分组结果的条件</h4><p><strong>注意使用group by  having</strong></p><p><strong>7 查询平均成绩大于60分学生的学号和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, avg(成绩)</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having avg(成绩)&gt;60;</span><br></pre></td></tr></table></figure><p><strong>8 查询student表中重名的学生，结果包含id和name，按name, id升序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name</span><br><span class="line">from student</span><br><span class="line">where name in (</span><br><span class="line">select name from student group by name having(count(*) &gt; 1)</span><br><span class="line">) order by name;</span><br></pre></td></tr></table></figure><p><strong>9 在student_course表中查询平均分不及格的学生，列出学生id和平均分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sid,avg(score) as avg_score</span><br><span class="line">from student_course</span><br><span class="line">group by sid having(avg_score&lt;60);</span><br></pre></td></tr></table></figure><p><strong>10 查询至少选修两门课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, count(课程号) as 选修课程数目</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><p><strong>11查询不及格的课程并按课程号从大到小排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号 </span><br><span class="line">from score </span><br><span class="line">where score &lt; 60 </span><br><span class="line">group by 课程号desc</span><br></pre></td></tr></table></figure><p><strong>12 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">group by 课程号</span><br><span class="line">order by 平均成绩 asc,课程号 desc;</span><br></pre></td></tr></table></figure><p><strong>13 查询两门以上不及格课程的同学的学号及其平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号， avg（成绩） as 平均成绩</span><br><span class="line">from score</span><br><span class="line">where score &lt; 60</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><h4 id="复杂查询-子查询">复杂查询 : 子查询</h4><p><strong>14 查询所有课程成绩小于60分学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in （ select 学号</span><br><span class="line">from student</span><br><span class="line">where score &lt; 60)</span><br></pre></td></tr></table></figure><p><strong>15 查询没有学全所有课的学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号) &lt; (select count(课程号) from course))</span><br></pre></td></tr></table></figure><p><strong>16 查询出只选修了两门课程的全部学生的学号和姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from course</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&#x3D;2）;</span><br></pre></td></tr></table></figure><h4 id="多表查询">多表查询</h4><h5 id="区分概念">区分概念</h5><p>表A记录如下：</p><p>aID　　　　　aNum<br>1　　　　　a20050111<br>2　　　　　a20050112<br>3　　　　　a20050113<br>4　　　　　a20050114<br>5　　　　　a20050115</p><p>表B记录如下:<br>bID　　　　　bName<br>1　　　　　2006032401<br>2　　　　　2006032402<br>3　　　　　2006032403<br>4　　　　　2006032404<br>8　　　　　2006032408</p><p><strong>nature join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from A,B</span><br><span class="line">where A.aID &#x3D; B.bId</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>inner join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">innerjoin B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>left join</strong></p><img src="/2020/01/25/sql20questions/leftjoin.png" alt="leftjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">left join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL</p><p><strong>right join</strong></p><img src="/2020/01/25/sql20questions/rightjoin.png" alt="rightjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">right join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>NULL　　　　　NULL　　　　　8　　　　　2006032408</p><p><strong>full join</strong></p><img src="/2020/01/25/sql20questions/fulljoin.png" alt="fulljoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM A</span><br><span class="line">FULL OUTER JOIN B</span><br><span class="line">ON A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL　　　　　NULL　　　　NULL　　　　　82006032408</p><p><strong>17 查询所有学生的学号、姓名、选课数、总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selecta.学号,a.姓名,count(b.课程号) as 选课数,sum(b.成绩) as 总成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号;</span><br></pre></td></tr></table></figure><p><strong>18 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select a.学号,a.姓名, avg(b.成绩) as 平均成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号</span><br><span class="line">having avg(b.成绩)&gt;85;</span><br></pre></td></tr></table></figure><p><strong>19 查询学生的选课情况：学号，姓名，课程号，课程名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.学号, a.姓名, c.课程号,c.课程名称</span><br><span class="line">from student a inner join score b on a.学号&#x3D;b.学号</span><br><span class="line">inner join course c on b.课程号&#x3D;c.课程号;</span><br></pre></td></tr></table></figure><p><strong>20 查询出每门课程的及格人数和不及格人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select 课程号,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 及格人数,</span><br><span class="line">sum(case when 成绩 &lt;  60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 不及格人数</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p>使用分段[100-85], [85-70], [70-60], [&lt;60]来统计各科成绩，分别统计：各分数段人数，课程号和课程名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select a.课程号,b.课程名称,</span><br><span class="line">sum(case when 成绩 between 85 and 100 </span><br><span class="line"> then 1 else 0 end) as &#39;[100-85]&#39;,</span><br><span class="line">sum(case when 成绩 &gt;&#x3D;70 and 成绩&lt;85 </span><br><span class="line"> then 1 else 0 end) as &#39;[85-70]&#39;,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 and 成绩&lt;70  </span><br><span class="line"> then 1 else 0 end) as &#39;[70-60]&#39;,</span><br><span class="line">sum(case when 成绩&lt;60 then 1 else 0 end) as &#39;[&lt;60]&#39;</span><br><span class="line">from score as a right join course as b </span><br><span class="line">on a.课程号&#x3D;b.课程号</span><br><span class="line">group by a.课程号,b.课程名称;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始手把手教大家如何制作网站（进阶版）</title>
      <link href="/2020/01/18/setupSiteImprove/"/>
      <url>/2020/01/18/setupSiteImprove/</url>
      
        <content type="html"><![CDATA[<p>第一次知道hexo，next风格是在刷算法题时看一些回复，然后无意中看到了一个名为<a href="https://tding.top/" target="_blank" rel="noopener">小丁的博客</a>的网站，对比了一下他和我最初自己写blog网站，感觉自己的low爆了，于是就决定去重新做一个炫酷的</p><img src="/2020/01/18/setupSiteImprove/ding.png" alt="ding" style="zoom:33%; "><p>通过上一片文章，我们对hexo博客框架有了基本的认识，然而要想做出一些炫酷的效果，我们可以从这一篇文章中找到自己想要的摘取</p><h4 id="附加选项">附加选项</h4><p>1 动态背景</p><p>2 鼠标点击气球爆炸效果</p><p>3 右上角加加入github装横</p><p>4 RSS xml 全览</p><p>5 小图标链接</p><p>6 加入订阅 打赏功能</p><p>7 评论功能</p><p>8 个性化侧边栏</p><p>9 原创声明</p><p>10 网站访问量人数，次数，阅读数统计</p><h4 id="1-动态背景">1 动态背景</h4><p><strong>具体实现方法</strong></p><p>注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）<br>打开 /next/_config.yml, 在里面添加如下代码：(可以放在最后面)</p><p>打开 <code>/next/_config.yml</code> , 在里面添加如下代码：(可以放在最后面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># --------------------------------------------------------------</span><br><span class="line"># background settings</span><br><span class="line"># --------------------------------------------------------------</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https:&#x2F;&#x2F;github.com&#x2F;hustcc&#x2F;canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure><p><strong>实现效果图</strong></p><p><a href="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" alt="img"></a></p><p><strong>如果你感觉默认的线条太多的话 可以这么设置</strong></p><p>在上一步修改 <code>_layout.swig</code> 中，把刚才的这些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;</span><br><span class="line">color&#x3D;&quot;0,0,255&quot; opacity&#x3D;&#39;0.7&#39; zIndex&#x3D;&quot;-2&quot; count&#x3D;&quot;99&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>配置项说明</strong></p><ul><li><code>color</code> ：线条颜色, 默认: <code>'0,0,0'</code> ；三个数字分别为(R, G, B)</li><li><code>opacity</code> : 线条透明度（0~1）, 默认: <code>0.5</code></li><li><code>count</code> : 线条的总数量, 默认: <code>150</code></li><li><code>zIndex:</code> 背景的z-index属性，css属性用于控制所在层的位置, 默认: <code>-1</code></li></ul><h4 id="2-鼠标点击气球爆炸效果">2 鼠标点击气球爆炸效果</h4><img src="/2020/01/18/setupSiteImprove/ballon.png" alt="ballon" style="zoom:33%; "><p><strong>具体实现方法</strong></p><p>首先在 <code>themes/next/source/js/src</code> 里面建一个叫fireworks.js的文件，然后粘贴如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure><p>打开 <code>themes/next/layout/_layout.swig</code> , 在最底部的 <code>&lt;/body&gt;</code> 上面粘贴如下如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.fireworks %&#125;</span><br><span class="line">   &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>打开主题配置文件，在里面最后写下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Fireworks</span><br><span class="line">fireworks: true</span><br></pre></td></tr></table></figure><h4 id="3-右上角加加入github装横">3 右上角加加入github装横</h4><h4 id="img-src-hautdroite-png-alt-hautdroite-style-zoom-50"><img src="/2020/01/18/setupSiteImprove/hautdroite.png" alt="hautdroite" style="zoom:50%; "></h4><p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">这里</a>挑选自己喜欢的样式，然后复制代码：</p><p>我自己选择的是这个样式：</p><img src="/2020/01/18/setupSiteImprove/folkgithub.png" alt="folkgithub" style="zoom:50%; "><p>然后粘贴刚才复制的代码到 <code>themes/next/layout/_layout.swig</code> 文件中(放在<code> </code>的下面)，并把<code> href</code>改为你的github地址, 例如我的<em>github链接是</em>： <strong><a href="https://github.com/wuhewuhe" target="_blank" rel="noopener">https://github.com/wuhewuhe</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe&quot; class&#x3D;&quot;github-corner&quot; aria-label&#x3D;&quot;View source on GitHub&quot;&gt;&lt;svg width&#x3D;&quot;80&quot; height&#x3D;&quot;80&quot; viewBox&#x3D;&quot;0 0 250 250&quot; style&#x3D;&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;path d&#x3D;&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill&#x3D;&quot;currentColor&quot; style&#x3D;&quot;transform-origin: 130px 106px;&quot; class&#x3D;&quot;octo-arm&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill&#x3D;&quot;currentColor&quot; class&#x3D;&quot;octo-body&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;&#x2F;a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h4 id="4-RSS-xml-全览">4 RSS xml 全览</h4><img src="/2020/01/18/setupSiteImprove/rss.png" alt="rss" style="zoom:50%; "><p><strong>具体实现</strong></p><p>安装 Hexo 插件：(这个插件会放在 <code>node_modules</code> 这个文件夹里)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>进入根目录下的*_config.yml*, 修改如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line"></span><br><span class="line">## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line"></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p>然后打开next主题文件夹里面的 <code>_config.yml</code> , 在里面配置为如下样子：(就是在 <code>rss:</code> 的后面加上 <code>/atom.xml</code> , <strong>注意</strong>在冒号后面要加一个空格)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&#39;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure><p>配置完之后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>重新生成一次，你会在 <code>./public</code> 文件夹中看到 <code>atom.xml</code> 文件</p><h4 id="5-小图标链接">5 小图标链接</h4><img src="/2020/01/18/setupSiteImprove/icon.png" alt="icon" style="zoom:50%; "><p><strong>具体实现</strong></p><p>编辑Next主题下的_config.yml文件，next主题对应四种不同的布局Muse是紧凑型，Mist的默认sidebar在上面，Pisces和Gemini除了sidebar位置没发现特别大的区别。我习惯把菜单栏放在左边，所以用了Gemini的sechema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><p>然后找到下面的<em>social link</em>选项，进行如下格式编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe || github</span><br><span class="line">  E-Mail: mailto:dachichiwuhe@gmail.com || envelope</span><br><span class="line">  Linkedin: https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;he-wu-15321b137&#x2F; ||  linkedin</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100013356700523 || facebook</span><br><span class="line">  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  YouTube: https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC3brgfzjExkGq-qkp3vNNrw || youtube</span><br><span class="line">  Instagram: https:&#x2F;&#x2F;www.instagram.com&#x2F;wu.6971&#x2F; || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><p>||的意思是前面为对应链接，后面为图标</p><p>最后设置下面的social icon</p><p>social_icons:<br>enable: true<br>icons_only: false<br>transition: false</p><h4 id="6-加入订阅打赏功能">6 加入订阅打赏功能</h4><img src="/2020/01/18/setupSiteImprove/donate.png" alt="donate" style="zoom:33%;"><p>如果大家使用的next主题5.1版本之上的的话，那么编辑next下的_config.yml文件如下：</p><h1>Wechat Subscriber</h1><p>wechat_subscriber:<br>enabled: true<br>qcode: /images/wechat-qrcode.png<br>description: subscribe to my blog by scanning my public wechat account</p><h1>Reward</h1><p>reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！<br>wechatpay: /images/wechat.jpeg<br>alipay: /images/ali.jpeg<br>#bitcoin: /images/bitcoin.png</p><p>添加自己微信二维码照片到next下的images文件下，然后修改相应的提示语</p><img src="/2020/01/18/setupSiteImprove/images.png" alt="images" style="zoom:33%;"><h4 id="7-评论功能">7 评论功能</h4><img src="/2020/01/18/setupSiteImprove/Comments.png" alt="Comments" style="zoom:33%;"><p>这个功能有不同的实现方法和插件，像valine，gitment，gitalk，那么以我为准，我就讲我的方法(<strong>很不幸的发现现在很久没人维护，不能使用了</strong>)</p><blockquote><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p></blockquote><p><strong>使用 <code>Gitment</code></strong></p><ul><li><p>首先要有github帐号</p></li><li><p>接着<a href="https://github.com/settings/profile" target="_blank" rel="noopener">注册 OAuth Application</a></p><img src="/2020/01/18/setupSiteImprove/ouath.png" alt="ouath" style="zoom:33%;"></li><li><p>要确保填入正确的 callback URL（一般是网站的域名，如 <a href="https://wuhewuhe.github.io/">https://wuhewuhe.github.io/</a>)</p></li><li><p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p></li><li><p>这个页面，你还可以知道application拥有者：owner</p></li></ul><p>打开Next主题的 <code>_config.yml</code> 文件, 在评论相关设置的区域添加下面的代码, 并根据 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment 文档</a>说明来添加相应的值</p><img src="/2020/01/18/setupSiteImprove/gitment.png" alt="gitment" style="zoom:33%;"><p>确认 <code>next/layout/_partials/comments.swig</code> 是否有如下代码：</p><img src="/2020/01/18/setupSiteImprove/comment.png" alt="comment" style="zoom:50%;"><h4 id="8-个性化侧边栏">8 个性化侧边栏</h4><img src="/2020/01/18/setupSiteImprove/sidebar.png" alt="sidebar" style="zoom:33%;"><p><strong>具体实现</strong></p><p>我们可以根据自己需要添加左侧menu，比如我自定义about，photo和commonweal三个界面</p><p>首先，编辑next主题下的_config.yml文件，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> </span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> </span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> </span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> </span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || /sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> </span><br><span class="line">  <span class="comment">#top: /top/ || signal</span></span><br><span class="line">  <span class="attr">photo:</span> <span class="string">/photo/</span></span><br></pre></td></tr></table></figure><p>然后分别生成三个文章，注意关掉评论，没有分类和标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n 404</span><br><span class="line">hexo n about</span><br><span class="line">hexo n photo</span><br></pre></td></tr></table></figure><h4 id="9-原创声明">9 原创声明</h4><img src="/2020/01/18/setupSiteImprove/invent.png" alt="invent" style="zoom:50%; "><p><strong>具体实现</strong></p><p>在目录 <code>next/layout/_macro/下</code> 添加 <code>my-copyright.swig</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-author&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.author&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; post.author | default(config.author) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.link&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.license_title&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; __(&#39;post.copyright.license_content&#39;, theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，post的预定义link是用的根目录下的url所以需要确定url对应的是自己的网站地址：如下图所示：</p><img src="/2020/01/18/setupSiteImprove/post_url.png" alt="post_url" style="zoom:50%; "><p>然后编辑next主题下的_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;3.0&#x2F;</span><br></pre></td></tr></table></figure><h4 id="10-网站访问量人数，次数，阅读数统计">10 网站访问量人数，次数，阅读数统计</h4><img src="/2020/01/18/setupSiteImprove/visit.png" alt="visit" style="zoom:45%; "><p><strong>具体实现</strong></p><p>关于网站访问人数这块我也是踩过很多的雷，出现了好几次改了之后没效果的情况，这里我为大家一一细说。</p><p><strong>改法1</strong> 使用next主题 5.1版本以上</p><p>打开主题的配置文件 <code>/theme/next/_config.yml</code> ，找到如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: false</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 的值由 <code>false</code> 改为 <code>true</code> ，便可以看到页脚出现访问量，上述配置表示：</p><ul><li><p><code>site_uv</code> 表示是否显示整个网站的UV数</p></li><li><p><code>site_pv</code> 表示是否显示整个网站的PV数</p></li><li><p><code>page_pv</code> 表示是否显示每个页面的PV数</p></li></ul><p>表示是否显示每个页面的PV数</p><p>当然，对于不蒜子的配置可以随意更改，一下附上本人的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: 访客数</span><br><span class="line">  site_uv_footer: 人</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: 总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;  阅读数</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>使用 <code>hexo s</code> 部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用 <code>localhost:4000</code> 进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p><p><strong>改法2</strong> 引用busuanzi脚本 同用法通用法</p><p>要使用不蒜子必须在页面中引入 <code>busuanzi.js</code> ，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>本人使用的是next主题，所以在 <code>themes/next/layout/_third-party/analytic/busuanzi-count.swig</code> 中添加上述脚本，也可以把脚本添加在footer或者header中，如果使用的是其他主题，大致也是一样的，不过可能后缀是ejs，没有影响。</p><figure class="highlight plain"><figcaption><span>*if* theme.busuanzi_count.site_uv %&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;span *class*&#x3D;&quot;site-uv&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125;</span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.site_pv %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;span *class*&#x3D;&quot;site-pv&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.page_pv %&#125;</span><br><span class="line"></span><br><span class="line">   &lt;span *class*&#x3D;&quot;page_pv&quot;&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>hexo确实是一个功能很强大，高度集成的框架，插件非常多，像我使用过的还有热度搜索，文章推荐，文章链接等，大家可以去<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>一一探索, 网站支持中文确实方便大家阅读。以上两篇文章是我自己的学习笔记，也同样是我对hexo的一点点小小见解</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始手把手教大家如何制作网站（基础版）</title>
      <link href="/2020/01/15/how-to-setup-site/"/>
      <url>/2020/01/15/how-to-setup-site/</url>
      
        <content type="html"><![CDATA[<p>随着互联网浪潮的翻腾，国内外涌现出越来越多优秀的网站，自媒体人，blog。他们凭借这自己独到的见解，以及在某一方面的建树，瞬间圈粉，成为了我们所谓的网红。如果你是一个不甘寂寞的人，那么你可曾想过做一个属于自己的网站。</p><p>很多人觉着做一个网站是一个很繁琐的过程，从域名，到服务器，再到各种协议，前端，后台，数据库，测试，上线部署… . 以上都是大型的企业级项目，其实如果我们很好的借助现成的工具，那么无论你是不是计算机专业，懂不懂编代码，记住几条命令，改一些配置，不花一分钱，你就拥有属于自己的个性化网站。</p><h4 id="工具">工具</h4><p>hexo 框架, Next主题，github服务器，markdown编辑器</p><p>以上这四个工具，就足够我们做出一个精美的网站。</p><h4 id="Hexeo">Hexeo</h4><img src="/2020/01/15/how-to-setup-site/Hexo.jpg" alt="Hexo" style="zoom:25%; "><blockquote><blockquote><p><em>Hexo</em> is a fast, simple &amp; powerful <em>blog</em> framework powered by Node.js.</p></blockquote></blockquote><p>这是hexo官网给出的简介，确实hexo是全球最大的同性恋网站，但是其也是一个由node js编写的，非常快捷好用的博客协同框架。其优点就是：</p><ul><li>部署简单 ： 一条指令就完成</li><li>速度快： 快速生成文章，渲染几百个页面几秒钟搞定</li><li>开源 ：非常多的插件，强大的api，庞大的讨论区</li><li>支持markdow语法 ： 之前写过一期md语法的介绍，高效书写，很好的和github，简书兼容</li></ul><p>读完本文，实践作出一个属于自己的网站，你就会发现hexo的优点。</p><h5 id="hexo-基本操作">hexo 基本操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo -version #查看版本</span><br><span class="line">hexo clean #清空</span><br><span class="line">hexo g #generate 生成</span><br><span class="line">hexo s #server 本地调试</span><br><span class="line">hexo d #deploy 部署</span><br><span class="line">hexo list &lt;type&gt; #列出资料 page，tags，categories</span><br><span class="line">hexo --save #安全模式 遇到问题重新执行</span><br><span class="line">hexo --debug #debug 显示log</span><br><span class="line">hexo --silent</span><br></pre></td></tr></table></figure><h4 id="Github">Github</h4><img src="/2020/01/15/how-to-setup-site/github.png" alt="github" style="zoom:20%; "><p>Github，想起了一句忘记从哪里听到的话<strong>你和大神之间就只差一个github</strong>，他本来就是一个托管代码的大仓库，相信每一个程序的新手毕竟之路都是有github的陪伴，有了他我们再也不用担心不小心删了代码，或者把某一个地方改崩了，大家还能协同开发各司其职。同时git也是github的唯一版本库管理工具，我也专门做了一起git的使用从进阶到入门，感兴趣的小伙伴可以在往期内容查看。当然github也分为个人和企业，收费与免费版，github的初衷就是开源，大家都可以看到源代码，做出自己的贡献，有很多炙手可热，家喻户晓的项目都在github上开源：</p><ul><li>React ReactMobile （github仓库下载量贡献第一的repository，由facebook维护）</li><li>Linux （操作系统之父）</li><li>Swift （Apple 发布的原生编程语言）</li></ul><p>当然，初次之外，github还有很多其他的功能，比如我们今天用到的服务器域名。</p><h4 id="搭建步骤">搭建步骤</h4><h5 id="基本步骤">基本步骤</h5><p>1 安装npm，node js</p><p>2 下载 安装 hexo框架</p><p>3 发布文章</p><p>4 下载 Next主题</p><p>5 修改配置（人性化图片，title，分类，标签）</p><p>6 文章字数统计 阅读时间</p><p>7 网站运行时间</p><p>8 加入搜索功能</p><p>9 Github 获取域名</p><p>10 绑定域名 部署</p><h5 id="附加选项">附加选项</h5><p>1 动态背景</p><p>2 鼠标点击气球爆炸效果</p><p>3 右上角加加入github装横</p><p>4 评论功能</p><p>5 小图标链接</p><p>6 加入微信 支付宝打赏</p><p>7 RSS xml 全览</p><p>8 文章底角加入微信公众号推送</p><p>9 防止转载</p><p>10 网站访问量人数和次数统计</p><h5 id="安装npm-nodejs">安装npm nodejs</h5><p><a href="https://www.npmjs.com/get-npm%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%86%8D%E7%82%B9%E5%87%BBdownload" target="_blank" rel="noopener">https://www.npmjs.com/get-npm点击进入链接，再点击download</a> node js and npm，勾选本地安装。安装结束后，打开终端，分别输入<strong>node -v</strong>和 <strong>npm -v</strong> 查看npm和node是否成功安装以及其对应版本。</p><img src="/2020/01/15/how-to-setup-site/npm.png" alt="npm" style="zoom:50%; "><h5 id="下载-安装-hexo框架">下载 安装 hexo框架</h5><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，命名为Blog_life，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中，copy文件夹路径进入终端依次输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>执行完这两句话后，打开<strong>localhost：4000</strong>可以看到如下图所示</p><img src="/2020/01/15/how-to-setup-site/hexoinit.jpeg" alt="hexoinit" style="zoom:100%; "><h5 id="发布文章">发布文章</h5><p>这里带大家熟悉一下hexo的几条常用命令，掌握这几条大家就可以基本完成文章的发布与删除</p><p><code>hexo new &quot;gitTuto&quot;</code></p><p>可以简写为 hexo n “文章题目”</p><h5 id="下载next主题">下载next主题</h5><p>本文默认大家电脑已经安装了git，如果需要熟悉安装<a href="https://wuhewuhe.github.io/2020/01/18/gitTuto/#more">git介绍，安装，基本操作</a>。hexo有100多个主题，大家可以在官网上看到挑选自己喜欢的，这里为大家展示Next主题，主要是因为其黑白风格简明耐看，而且社区庞大，及时更新，有问题好解决，而且next也是hexo最出名的主题之一。</p><p>这里建议老鸟下载最新版，但是新手还是使用稳定版的比较好，我本人使用的5.1.4，如果为了避免错误大家可以全程和我同步。</p><p><code>git clone https://github.com/iissnan/hexo-theme-next</code></p><p>下载完成后，进入blog目录下的theme文件，发现多了一个next主题，进入根目录的_config.yml文件，将找到theme关键字修改问<strong>theme ：next</strong>注意空格，重新执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后大家后看到如下效果：</p><img src="/2020/01/15/how-to-setup-site/next.png" alt="next" style="zoom:50%; "><h5 id="修改配置">修改配置</h5><p><strong>网站的titile 与 subttile</strong></p><p>进入根目录下的*_config.yml*，编辑此文件，自定义title和subtitle</p><img src="/2020/01/15/how-to-setup-site/title.png" alt="title" style="zoom:33%; "><p><strong>编辑照片</strong></p><p>找到一张我们想要的照片jpg，jpeg，png格式不限，调整大小至215*215 pixel放到themes/next/source/images下，进入next主题下的_config.yml, 查找关键字avatar编辑</p><img src="/2020/01/15/how-to-setup-site/avatar.png" alt="avatar" style="zoom:33%; "><p><strong>文章分类</strong></p><p>分档归类，方便自己管理管理博客，同时也能方便读者阅读，这也是hexo的特性之一</p><p>打开分类功能：</p><p><code>hexo new page categories</code></p><p>这说你的source目录下生成 categories/index.md 文件，我们将其打开，把它改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;categories&quot; </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这时候你就可以给你的文章归类存档了，使用方式就是在你的文章的头部加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - 分类1 </span><br><span class="line"> - 分类2</span><br></pre></td></tr></table></figure><p>注意yml格式的文件编写是一定注意空格，否则不识别</p><p><strong>文章标签</strong></p><p>同上所示，首先大概标签功能，在对其md文件进行编辑，修改其类型和关闭评论功能，添加标签。</p><p>注意这里大家为了区分标签和分类，可以定义自己熟悉的语法格式，比如我的分类都是首字母大写，标签首字母小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">type: &quot;categories&quot;  </span><br><span class="line">comments: false</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br></pre></td></tr></table></figure><p>最后回到根目录的*_config.yml*文件中检查，tag_dir和category_dir是否被激活，如下图所示</p><img src="/2020/01/15/how-to-setup-site/tag.png" alt="tag" style="zoom:33%; "><p>另外，Markdown 的语法是写作最优雅最简洁最简单的，如果之前没用过的建议去学一下<a href="https://wuhewuhe.github.io/2019/12/29/markdown/#more">Markdown语法简介</a>。</p><h5 id="文章字数统计-阅读时间">文章字数统计 阅读时间</h5><p>如果没有安装 hexo-wordcount 插件，先安装该插件：</p><p><strong>npm i --save hexo-wordcount</strong></p><p>next主题已经集成此功能，我们直接修改配置就好</p><p>要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true         # 单篇 字数统计</span><br><span class="line">  min2read: true          # 单篇 阅读时长</span><br><span class="line">  totalcount: false       # 网站 字数统计</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/words.png" alt="words" style="zoom:33%; "><h5 id="网站运行时间">网站运行时间</h5><p>找到 \themes\next\layout_partials\ 下面的footer.swig文件</p><p>找到<span id="sitetime">在其后面加入如下代码</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    function siteTime()&#123;</span><br><span class="line">        window.setTimeout(&quot;siteTime()&quot;, 1000);</span><br><span class="line">        var seconds &#x3D; 1000</span><br><span class="line">        var minutes &#x3D; seconds * 60</span><br><span class="line">        var hours &#x3D; minutes * 60</span><br><span class="line">        var days &#x3D; hours * 24</span><br><span class="line">        var years &#x3D; days * 365</span><br><span class="line">        var today &#x3D; new Date()</span><br><span class="line">        var todayYear &#x3D; today.getFullYear()</span><br><span class="line">        var todayMonth &#x3D; today.getMonth()</span><br><span class="line">        var todayDate &#x3D; today.getDate()</span><br><span class="line">        var todayHour &#x3D; today.getHours()</span><br><span class="line">        var todayMinute &#x3D; today.getMinutes()</span><br><span class="line">        var todaySecond &#x3D; today.getSeconds()</span><br><span class="line">        var t1 &#x3D; Date.UTC(2017,4,18,11,00,00)</span><br><span class="line">        var t2 &#x3D; Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond)</span><br><span class="line">        var diff &#x3D; t2-t1</span><br><span class="line"></span><br><span class="line">        var diffYears &#x3D; Math.floor(diff&#x2F;years)</span><br><span class="line">        var diffDays &#x3D; Math.floor((diff&#x2F;days)-diffYears*365)</span><br><span class="line">        var diffHours &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days)&#x2F;hours)</span><br><span class="line">        var diffMinutes &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)&#x2F;minutes)</span><br><span class="line">        var diffSeconds &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)&#x2F;seconds)</span><br><span class="line">        document.getElementById(&quot;sitetime&quot;).innerHTML&#x3D;&quot; this site has runnned &quot;+diffYears+&quot; year &quot;+diffDays+&quot; day &quot;+diffHours+&quot; hour &quot;+diffMinutes+&quot; minute &quot;+diffSeconds+&quot; second&lt;br&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    siteTime()</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/runtime.png" alt="runtime" style="zoom:33%; "><h5 id="搜索功能">搜索功能</h5><p>安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>全局配置文件_config.yml，新增如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;flashlab&#x2F;hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/search.png" alt="search" style="zoom:33%;"><h5 id="Github-获取域名">Github 获取域名</h5><p>为了让全世界的人都可以访问到你的网站，接着创建一个public的仓库，比如我<strong><a href="http://wuhewuhe.github.io">wuhewuhe.github.io</a></strong>那么到时我就可以通过此网址来访问我的网站了。 创建完成之后，那么你就有自己的 Git 地址了。然后进入setting选项，找到github pages一栏</p><p>这里为什么建议大家新建一个以自己github名字命名的仓库，这里我踩过雷，给大家提议个醒，因为在_config.yml中有一个选项</p><img src="/2020/01/15/how-to-setup-site/url.png" alt="url" style="zoom:33%; "><p>说的是如果我们建了一个二级仓库需要从新修改deploy的url</p><img src="/2020/01/15/how-to-setup-site/githubUrl.png" alt="githubUrl" style="zoom:33%; "><h5 id="绑定域名-部署">绑定域名 部署</h5><p>从终端进入到blog根目录下，执行如下语句用于安装hexo-deploy-git插件</p><p><code>npm install hexo-deployer-git --save</code></p><p>修改根目录下的_config.yml下的deploy选下如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe&#x2F;wuhewuhe.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装成功后，进入到pack.json文件中可以到其版本</p><p><code> &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;,</code><br>重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>成功后，访问到**<a href="https://wuhewuhe.github.io/**%E5%B0%B1%E5%AE%8C%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%A7%81%E4%BA%BA%E7%9A%84%E7%BD%91%E7%AB%99%E5%8F%91%E5%B8%83">https://wuhewuhe.github.io/**就完成了我们自己私人的网站发布</a></p><h4 id="总结">总结</h4><p>到这里，我们就已经基本熟悉了hexo框架，next主题，github仓库的使用以及运作流程，如果大家感兴趣想添加更多的特效，是网站更加多姿多彩请看下一章<a href="https://wuhewuhe.github.io/2020/01/18/setupSiteImprove/#more">从零开始手把手教大家如何制作网站(进阶版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有路径问题浅谈动态规划</title>
      <link href="/2020/01/05/path-dp/"/>
      <url>/2020/01/05/path-dp/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是动态规划">什么是动态规划</h3><p>在网上找到一个很形象的例子，猿爸爸把 1+1+1+1+1+1+1+1 = 写在纸上，问小猿（咦）：<br>「它们加起来是多少哇？」</p><p>（数了一会…）「8 ！」</p><p>猿爸爸在左边又加了个 1+，再问一次小猿：<br>「现在呢？」</p><p>（迅速地）「9 ！」</p><p>「为什么小猿这么快就知道了呢？」</p><p>「因为你刚刚加了 1 啊~」</p><p>「所以只要记得之前的结果，就不用再计一次数啦。」</p><p>嗯，动态规划就是一种「先记住些事，方便后面节约时间」的神奇方法</p><hr><h3 id="定义">定义</h3><blockquote><p>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.</p></blockquote><p>以上GeeksforGeeks对动态规划的诠释，于我而言，我认为动态规划的核心思想就是如何将原有的问题拆分成字问题。<strong>如果这个问题我们要是可以用滴归来解决，那么我们一般可以通过动态规划的思路来降低时间复杂度。</strong></p><hr><h3 id="动态规划套路">动态规划套路</h3><p>我认为动态规划总体来讲可以分为三个步骤：</p><ul><li>设定状态</li><li>初始化</li><li>状态转移方程</li></ul><p>具体这三步指的是什么，我将通过路径问题来向大家逐一介绍。</p><p>网上有很多大神总结动态规划可以分为自下而上和自上而下，这一块我天资愚钝，没有领悟得很透彻，就不过多深入去说。</p><hr><h3 id="例题">例题</h3><p>本题是我从leetcode上的第62题，可以说是一道非常经典的动态规划入门题：</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 16.49.32.png" alt="Screenshot 2020-01-05 at 16.49.32" style="zoom:50%; "><p>题目让我们找到从图的左上角到右下角的所有路径，告诉我们只能向下或者向右走。</p><h3 id="题目分析">题目分析</h3><p>首先这个题是一个<strong>计数</strong>问题，提到计数这个关键词，那么很快我们就可以联想到程序猿爸爸让儿子1+1+1… .</p><ul><li>状态</li></ul><p>我们可以将这个题转化为一个m*n的矩阵，矩阵上的每一个格子的值就代表从左上到达该格子的所有路径总和。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.10.53.png" alt="Screenshot 2020-01-05 at 17.10.53" style="zoom:25%; "><p>如图所示，由A到B最多有两个路径： 1 右 下 2 下右。 所以B对应的状态为2，A对应的状态为1</p><ul><li><p>初始化</p><p>明确了状态之后，我们需要对矩阵初始化，为了题目给定了矩阵的长和宽，那么我们就可以创建一个对应的m*n的矩阵，然后我们知道初始位置是左上角，所以其初始值为1，然后最上面的一行和最左面的一行值也都为1。因为我们只有一种方式可以到达他们。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.17.33.png" alt="Screenshot 2020-01-05 at 17.17.33" style="zoom:25%; "></li><li><p>状态转换方程</p><p>回到图中，我们已经已知了初始值，那么我们如何求解到问号位置的值呢？<br><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.19.54.png" alt="Screenshot 2020-01-05 at 17.19.54" style="zoom:25%; "><br>我们发现到达？位置的路径总和就是等于到达？位置上方和左边的值相加。因为题目告诉我们只有两种移动方式。对应的方程就是 <code>res[i][j] = res[i - 1][j] + res[i][j - 1];</code></p></li></ul><h3 id="结果展示">结果展示</h3><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.26.00.png" alt="Screenshot 2020-01-05 at 17.26.00" style="zoom:50%; ">所以如果我们给出一个4*4的矩阵，那么一共存在20种走法从左上走到右下<h3 id="代码实现">代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">&#x2F;&#x2F;corner case</span><br><span class="line">if (m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line">if (m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1)</span><br><span class="line">return 1;</span><br><span class="line">&#x2F;&#x2F; init state </span><br><span class="line">int[][] res &#x3D; new int[m][n];</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">res[i][0] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">res[0][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; loop the matrix </span><br><span class="line">for (int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">for (int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">&#x2F;&#x2F; state change equation</span><br><span class="line">res[i][j] &#x3D; res[i - 1][j] + res[i][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是m<em>n, 空间复杂度也是m</em>n。 这里可以通过滚动数组将时间复杂度优化到n。</p><h3 id="follow-up">follow up</h3><p>为什么说动态规划是对递归的的一种优化，其实这个题，我们用深度优先搜索也可以做。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths2(int m, int n) &#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0 &amp;&amp; n&#x3D;&#x3D;0)</span><br><span class="line">        return 0;</span><br><span class="line">    return dfs(0,0,m,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int dfs(int i,int j,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&#x3D;&#x3D;m-1 &amp;&amp; j&#x3D;&#x3D;n-1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(i&gt;&#x3D;m || j&gt;&#x3D;n)</span><br><span class="line">        return 0;</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    sum+&#x3D;dfs(i,j+1,m,n)+dfs(i+1,j,m,n);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们会发现搜索是超过时间限制的，为什么因为搜索的时间复杂度是2^(m+n)。<br>因为搜索的数据结构就是二叉树，好比我们要想知道4<em>4矩阵的结果，就先把4</em>4拆分成对应的（3，4）与（4，3）相加，再将（3，4）拆分成（2，4）和（3，3）以此类推不停地拆分直到（0，0）的初始位置，然后我们发现这个过程中出现了很多重复的问题，并且每一个点都可以拆分成两个点。所以当m，n越大，起花费时间也越多。</p><h3 id="总结">总结</h3><p>动态规划和递归一直以来都是我算法的弱项，和平铺直叙的线性思维不同，递归和动态规划是通过对问题的拆分，很多时候是逆向思维。我发现此类问题都是代码量很小，但是需要想的很周全。之后，我会多通过练习来加深自己对其的认识。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2019/12/29/markdown/"/>
      <url>/2019/12/29/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈markdown语法">浅谈markdown语法</h2><p><strong>文章需要2分钟阅读 适用于每一个拥有电脑的你</strong><br>本期我将用最短的时间，向大家介绍一个码字的神奇，不用排版，只要记住几个symbol就能高效快捷的记录。</p><h4 id="介绍">介绍</h4><p>markdown 可能很多人听起来有点陌生，他就是类似于我们常使用的word或者wpf，是一种轻量级的标记语言。很多的网络作者，现代的编辑，还有程序猿背景的工作者大多数都青睐于此文本格式用于写作。向我们经常看到的论坛：简书，github，stackoverflow都是支持并推广markdown语法。</p><h4 id="起源">起源</h4><p>Markdown 由 John Gruber 在2004年创建，至今已经是12年的时间。关于Markdown最初的定义如下：</p><blockquote><p>a plain text formatting syntax<br>a software tool, written in Perl, that converts the plain text formatting to HTML</p></blockquote><p>指明markdown是一个纯文本语言，转化为html，html就是我们每天在各式各样网站上浏览看的文字图片对应的代码。</p><p>最初的设计理念：</p><blockquote><p>The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions.</p></blockquote><p>设计初衷就是markdown这种语法非常的简便易读，省去传统word大规模反锁的排版，而是然作者专注于内容的书写。</p><h4 id="常用的-markdown语法">常用的 markdown语法</h4><ul><li><p>标题</p><p><strong>语法</strong></p><img src="/2019/12/29/markdown/title.png" alt="title" style="zoom:50%; "><p><strong>效果</strong></p><img src="/2019/12/29/markdown/titleShow.png" alt="titleShow" style="zoom:50%; "></li><li><p>列表</p></li></ul><p><strong>语法</strong></p><img src="/2019/12/29/markdown/order.png" alt="order" style="zoom:50%; "><p>**效果 **</p><img src="/2019/12/29/markdown/orderShow.png" alt="orderShow" style="zoom:50%; "><ul><li><p>插入图片</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;MD.png&quot; alt&#x3D;&quot;MD&quot; style&#x3D;&quot;zoom:50%;&quot; &#x2F;&gt;</span><br><span class="line">or </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![MD](MD.png)</span><br></pre></td></tr></table></figure><pre><code>这里可以直接写绝对路径，但是大多数浏览器都是支持相对路径。如果不行的话肯定也有相应的插件支持。zoom代表图片的大小。使用topora这样的编译器可以直接拖拽图片到编辑区域。</code></pre><p><strong>效果</strong><br><img src="/2019/12/29/markdown/MD.png" alt="MD" style="zoom:50%; "></p><ul><li><p>链接</p><p><strong>语法</strong><br><code>`[baidu](https://www.baidu.com)`</code><br><strong>效果</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">baidu</a></p></li><li><p>引用</p><p><strong>语法</strong><br><img src="/2019/12/29/markdown/reference.png" alt="reference" style="zoom:50%;"></p></li></ul><p><strong>效果</strong></p><img src="/2019/12/29/markdown/Screenshot 2019-12-30 at 00.34.56.png" alt="Screenshot 2019-12-30 at 00.34.56" style="zoom:25%;"><ul><li>代码</li><li><ul><li><p>单行代码</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96; print(&quot;hello world&quot;);&#96;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><code>print(&quot;hello world&quot;);</code></p><ul><li><ul><li><p>代码块</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​```c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**效果**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>斜体 粗体</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜粗体***</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><em>斜体</em><br><strong>粗体</strong><br><em><strong>斜粗体</strong></em></p><ul><li><p>分隔符</p><p><strong>语法</strong><br><code>三个连续的+，*或者- </code><br><strong>效果</strong></p></li></ul><hr><ul><li><p>表格（不推荐）</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><h4 id="优缺点">优缺点</h4><h5 id="优点：">优点：</h5><p>说了这么多，markdown的优点我相信大家也都感受到了，比如</p><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开</li><li>让你专注于文字而不是排版</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等</li><li>Markdown 的标记语法有极好的可读性</li></ul><h5 id="缺点：">缺点：</h5><ul><li>没有完全统一的标准</li></ul><blockquote><p>这里可以说一则趣事，早些时候由tack Overflow 创始人和几个互联网巨头联合起来想制订一个统一的标准叫做Standard Markdown。结果这个事儿被创始人知道了，老爷子不开心，说你不能用standard这么官方的名字，因为我就没想让它统一。后来这个计划更名为Common Markdown。</p></blockquote><ul><li><p>作为一个中间语言，没有html丰富的功能</p><blockquote><p>html全称hypertext markup language，是一种超文本标记语言，他集成了很多的功能，是markdown语法所不具备的。比如其上传视频，改变布局… …</p></blockquote></li><li><p>对于一定的格式写法有些复杂</p></li></ul><blockquote><p>相信所有熟悉markdown写法的人都知道，markdown语法更改字体颜色，剧中右对齐是做不到的，需要插入html代码，虽然说排版已经违背了设计的初衷，但我们也不能一点都不修边幅。还有就是markdown始终对于插入表格是个硬伤，始终要注意index对其。</p></blockquote><h4 id="markdown-编译器">markdown 编译器</h4><p>如果你看了我的文章想尝试一下mardown语言，我在这里为大家列出一些当前比较流行的mardown编译器。</p><ul><li>typora  (良心安利，免费好用，实时预览，macos/window兼容)</li><li>Mou （功能强大，插件很多，<strong>但是收费</strong>）</li><li>印象笔记 （不错的选择，手机电脑可以通过云来同步）</li><li>sublime （书写方便，快捷，但是不能预览）</li><li>visualstudio （同理sublime）</li></ul><h4 id="总结">总结</h4><p>一个技术的存在可以达到hot or popular一定是有其的道理。markdown语言我认为非常适合写技术博客，经常码字追求流畅的文字工作者，<strong>如果一个东西能够大幅度的提升我们的工作效率，那么我们为什么不用它</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> writing skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU</title>
      <link href="/2019/12/28/LRU/"/>
      <url>/2019/12/28/LRU/</url>
      
        <content type="html"><![CDATA[<h2 id="LRU-Least-Recently-Used-页面置换算法">LRU(Least Recently Used) 页面置换算法</h2><p>本篇文章阅读时间 5 分钟， 技术实现 java， javascript。</p><h4 id="概述">概述</h4><p>这一周本来是想将Mario（马里奥）做完，但是周三晚上下班看了一眼React，于是一发不可收拾，之前是听同学，朋友，同事说react的香，一直没有感觉到，真是自己从头学了一下才感受到他火确实是有道理。因为自己的学习笔记还没有整理完，mario的进度推迟了。正巧在自己做网站的时候，看到react-router里面有一个封装好的内置类history，自己在写的时候遇到了浏览记录的问题。正巧室友说在国内面试时被问到这个问题。这期，临时决定写一写这个LRU页面置换算法。</p><h4 id="算法缘由">算法缘由</h4><p>第一次听到这个页面置换算法应该是大三的操作系统课，但是当时也就是考试复习随便瞟一眼，也没仔细看。字如其名，其本质就是选择调出用户想要的页面，好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。这是官方给出的解释，白话说，假如浏览器只能同时加载显示三个页面，那么我们应该通过一种最合理的方式显示出我们最常用的三个，而将不常用的替换掉。常见的置换算法像是OPT，FIFO，CLOCK，LRU。我自己认为LRU是最贴近现实生活，同时也是最常考到。</p><h4 id="例题展示">例题展示</h4><p>为了更好的讲述这个题，我就从leetcode上面直接拔下来一个题。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.24.22.png" alt="Screenshot 2019-12-22 at 21.24.22" style="zoom:25%; "><p>题目说的什么意思呢，就是让我们自己通过数据结构设计一个类并指定缓存的最大存储量，类表示的就是我们浏览器的缓存，类里面有两个方法，分别为get和put。get的意思就是，如果此时缓存记录里有我要找的东西，那么直接返回结果。没有就输出一个-1。put的意思就是，每次我们访问一个新的网页，将这个网页放入到我们的缓存中，如果该网页已经存在于缓存中，则对其内容进行替换。若不存在，加入到缓存中。</p><p>他这里有一个follow up：问我们怎么能够用常数的时间复杂度完成所有的操作。（就是优的解决方案）</p><h4 id="分析：">分析：</h4><p>首先读完这个题目，并结合我们的我们的生活常识，很快，我就想到根据我们需要用一个固定长度的数据结构去存储用户的访问记录。然后再看到put方法key，value键值对，我想到了hashtable。我们可以用hashtable的key设置为数字，代表用户的浏览记录标示；value作为内容。并且hashtable的查找时间复杂度为O（1）。再之后，我们会发现这个题单纯一个hashmap数据结构还不能满足我们的所有需求，比如从技术层面出发，我们知道hashmap的添加和删除操作都是o（logn）的时间复杂度。应用层面上，单纯只用hashmap，我们怎么做到对内容的更新与调度。于是，在这里我们可以在引入一个双向节点，这里有很多做法比如用deque，linkedlist。我是从题目本身出发，自己写了一个Node类，他有四个属性，分别是prev（前一个节点），next（下一个节点），key（页面表示），value（内容）。这样设计的好处就是，我们在执行添加和删除的操作时，只需要改变指针的方向不需要便利整个list到达了最优的时间复杂度。</p><p>这里，可能文字还是有些拗口，尤其是针对分计算机专业的童鞋们，我付上一个图片更能清晰直观的描述设计思路，以及运行过程。</p><p><strong>模型</strong></p><table><thead><tr><th><strong>Hash table - capacity</strong>**（<strong><strong>2</strong></strong>）****- head(0, 0)**</th></tr></thead><tbody><tr><td>Node 1 key = 1, value = 1, prev = head, next = Node2</td></tr><tr><td>Node 2 key = 1, value = 1, prev = Node1, next = tail</td></tr></tbody></table><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.45.19.png" alt="Screenshot 2019-12-22 at 21.45.19" style="zoom:25%; "><p>假设我们模拟执行 例题中给的几步</p><h5 id="Step-1-LRUCache-cache-new-LRUCache-2-cache-put-1-1">Step 1 : LRUCache cache = new LRUCache(2); cache.put(1, 1);</h5><p>首先我们初始化了一个缓存对象，并设置他的最大容量为2。</p><p>此时我们将第一个元素放进来。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.27.png" alt="Screenshot 2019-12-29 at 00.26.27" style="zoom:25%; "><h5 id="Step2-cache-put-2-2">Step2 : cache.put(2, 2);</h5><p>检测是否超过最大容量。再将第二元素放到队伍头节点</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.30.png" alt="Screenshot 2019-12-29 at 00.26.30" style="zoom:25%; "><h5 id="Step3-cache-get-1">Step3 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。发现有则返回value。并交换节点（2，2）和（1，1）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.34.png" alt="Screenshot 2019-12-29 at 00.26.34" style="zoom:25%; "><h5 id="Step4-cache-put-3-3">Step4 : cache.put(3, 3);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（2，2）删除，再把新的节点（3，3）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.38.png" alt="Screenshot 2019-12-29 at 00.26.38" style="zoom:25%; "><h5 id="Step5-cache-get-2">Step5 : cache.get(2);</h5><p>检测缓存中是否有id为2的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.41.png" alt="Screenshot 2019-12-29 at 00.26.41" style="zoom:25%; "><h5 id="Step6-cache-put-4-4">Step6 : cache.put(4, 4);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（1，1）删除，再把新的节点（4，4）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.44.png" alt="Screenshot 2019-12-29 at 00.26.44" style="zoom:25%; "><h5 id="Step7-cache-get-1">Step7 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.48.png" alt="Screenshot 2019-12-29 at 00.26.48" style="zoom:25%; "><h5 id="Step8-cache-get-3">Step8 :cache.get(3);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.52.png" alt="Screenshot 2019-12-29 at 00.26.52" style="zoom:25%; "><h5 id="Step9-cache-get-4">Step9 : cache.get(4);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value。并交换节点（4，4）和（3，3）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.55.png" alt="Screenshot 2019-12-29 at 00.26.55" style="zoom:25%; "><h4 id="代码实现">代码实现</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.04.26.png" alt="Screenshot 2019-12-22 at 22.04.26" style="zoom:25%; "><p>为了方便编程，避免空指针，便于调试。我自己设置了一个头节点和尾节点。在LRU里面自定义一个内部节点类。LRU的结构为hashmap套node。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.07.26.png" alt="Screenshot 2019-12-22 at 22.07.26" style="zoom:25%; "><p>添加到头部，因为是双向所以需要改变两次。这里要插入头部，所以先保存一下原有的头节点，再让原有的头节点与新添加节点做操作。1 新添加节点的下一个指向原有头节点。2 head的下一个指向新添加节点。3 原有头节点的上一个指向新添加节点。 4新添加节点的上一个指向head。 建议大家在做指针指向问题的时候画草图，并且想改变好一个方向再去改变另外的方向。</p><p>删除，也是把前一个节点的下一个节点指向要删除节点的下一个。再把删除节点下一个的前一个指向删除节点的前一个。<img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.15.39.png" alt="Screenshot 2019-12-22 at 22.15.39" style="zoom:25%; "></p><p>get 操作：检测hashmap是否含有key值。若存在，取出node节点，删除原有的node节点，再从新插入到头部。返回value。没有直接返回-1。</p><p>put操作 ：检测hashmap是否含有key值，若存在，取出node节点。取出node节点，删除原有的node节点，再从新插入到头部。若没有，先判断，hashmap是否达到自己的最大容量，若达到，删除队尾节点，在将新节点插入头部。如没达到容量直接插入。</p><h4 id="测试结果">测试结果</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.03.57.png" alt="Screenshot 2019-12-22 at 22.03.57" style="zoom:25%; "><h4 id="源码仓库：">源码仓库：</h4><p><a href="https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem" target="_blank" rel="noopener">https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem</a></p><h4 id="总结">总结</h4><p><strong>LRU</strong>最近最久未使用页面置换算法，无论是在面试中作为一个程序设计题的高频出现，还是其cache思想贴近实际生活都是我认为很重要的一个点。希望自己的见解都初学者有帮助，对非it领域算是一个扩展知识的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> page replacement </tag>
            
            <tag> lru </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tetris</title>
      <link href="/2019/12/28/tetris/"/>
      <url>/2019/12/28/tetris/</url>
      
        <content type="html"><![CDATA[<h2 id="俄罗斯方块Tetris">俄罗斯方块Tetris</h2><h4 id="背景回顾">背景回顾:</h4><p>我觉俄罗斯方块在游戏领域的地位，有点像乔丹打篮球。为什么这么说，EA对过去30年的游戏评点，俄罗斯方块这样一个仅在当时老毛子开发出来做检测效率的东西，列在榜单首位。在那个遥远寒冷的西伯利亚，俄罗斯工程师发布这个名为Tetris后，在那个人口还没有爆炸增长，电脑还没普及的时候，先后有5亿人对此游戏下载。甚至毫不夸张的说，很多人第一次听到俄罗斯就是通过俄罗斯方块这个小游戏。时至今日，俄罗斯方块早已下架，但是以任然保持着9项吉尼斯世界纪录，同样也在影视，医疗领域做出了不小的贡献。</p><h4 id="程序界面设计-：">程序界面设计 ：</h4><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.31.12.png" alt="Screenshot 2019-12-25 at 17.31.12" style="zoom:25%; "><h4 id="程序开发设计：">程序开发设计：</h4><h5 id="创建主题窗口，设置游戏界面，画边框">创建主题窗口，设置游戏界面，画边框</h5><p>同其他类型小游戏一样，我们第一步要做的就是创建一个frame设置其大小，是否可见，相对位置。然后在主体frame中插入一个jpanel，实现游戏的所有逻辑细节。可能对于不同的游戏项目，我们可能需要上网找资源，但是俄罗斯方块我们可以直接用java自带的graphic包里面的drawRect方法来绘制正方体就足矣。因为之前已经写过如何设置推算调试窗体大小，这里就不过多赘述。</p><p>我设置每个小方框的边长为20pxl，主题窗口的宽为400pxl，高度为500pxl。游戏界面，容器的高度为21行，宽度为12行。其中第一列和最后一列还有最后一行是墙壁。唯一一点需要考虑的是用什么去存出游戏的地图，这里我看网上有的人有list，map，我更倾向于2位数组。原因很简单，长度固定，数组的访问修改快，通过一些边界条件，程序效率也高。因此在我的程序里，二维数组第一位代表列，就是对应二维坐标系的x；第二维代表行，就是二维坐标系的y。准备工作都做好后，我们初始化地图，设置边框。</p><p>来看一下第一步结束的效果图：</p><img src="/2019/12/28/tetris/Step1.png" alt="Step1" style="zoom:25%; "><h5 id="方块的绘制">方块的绘制:</h5><p>俄罗斯方块从字面意义上我们就知道方块是这游戏的操作的主体，所以我认为这一步也是整个游戏开发中最重要的环节。首先我们需要确定游戏中有多少种基本形状，这个我就上网google了一下。随后我们要确定用什么样的数据结构去存储和表示方块的形状。因为我们知道方块是可以旋转的；每次旋转完之后形状由于方向的改变，所以图形也变化。</p><p>这里我们首先先列出俄罗斯方块的7本基本形状，然后再去进行下一步的detail：</p><p>I字形</p><img src="/2019/12/28/tetris/shapei.png" alt="shapei" style="zoom:25%; "><p>田字形</p><img src="/2019/12/28/tetris/shapeSquare.png" alt="shapeSquare" style="zoom:25%; "><p>Z字形</p><img src="/2019/12/28/tetris/shapeZ.png" alt="shapeZ" style="zoom:25%; "><p>S字形</p><img src="/2019/12/28/tetris/shapes.png" alt="shapes" style="zoom:25%; "><p>T字形</p><img src="/2019/12/28/tetris/shapeT.png" alt="shapeT" style="zoom:25%; "><p>L字形<br><img src="/2019/12/28/tetris/shapeL.png" alt="shapeL" style="zoom:25%; "></p><p>J字形</p><img src="/2019/12/28/tetris/shapeJ.png" alt="shapeJ" style="zoom:25%; "><p>从图片中我们就可以观察到，I形状的长或宽等于四，是这里最长的。所以我们的目的是用一个数据结构表示所有的图形，因此我想到可以使用4<em>4的一个二维数组。0表示空闲，1表示填充，如果把二维数组平铺下来就是一个长度为16的一维数组。然后我们就要考虑到方块的旋转引起形状的变化，所以我们还需要分析，每个形状经过旋转好最多能产生几种不同的形状。举个例子，比如田字形无论怎么旋转都是同样的形状，但是L或者J字形就可以产生4种不同的状态，因此我们可以用4</em>16的数组代表每个图形的所有变化。</p><h5 id="举例-L">举例 L</h5><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.48.27.png" alt="Screenshot 2019-12-25 at 17.48.27" style="zoom:25%; "><p>而一种方块的所有变形体的信息可以用二维数组来存储，依旧拿L形方块举例，它的所有形态可以存储为</p><p>{</p><p>{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }</p><p>},</p><p>由于二维数组只能存储一种方块的所有变形体信息，故要存储七种方块的所有变体信息则要使用三维数组来进行存储。</p><h4 id="3方块-初始化-左右移动-旋转-下落-：">3方块 初始化-&gt;左右移动-&gt;旋转-&gt;下落 ：</h4><p>一提到移动，可以说完变不离其宗，对于java来讲就两个大方向thread或者timer，通过图形坐标的改变，其定时的刷新来重新绘制panel。可能两者存在细微差别，但是对我来讲可能就像是方法改个名字比如thread要重写runner方法。而timer是重写actionlistener。（这两个东西很重要，可能简单的也说不清楚，因为他不是文章的主题，我们就跳过了）。之前的falppy bird和小恐龙跳跃我都用的是thread。这一次俄罗斯方块我就使用timer方法。</p><p>我们的要在这一步实现的功能是方块自然下落，左右可以移动，并且下落过程中可以旋转。那么一步一步来，第一步方块的初始化。</p><h5 id="1-create-rectangle">1 create rectangle</h5><p>这里我先设置一个固定的x，y坐标代表每次当一个方块落地后，下一个方块就会从这里重新出现一个新的，我默认的是左上角就是x=1, y=0。然后设置2个随机数，取值范围为1-7和1-4，分别对应哪一个图形，和图形具体的哪一种状态。</p><h5 id="2-左右移动">2 左右移动</h5><p>因为这里用户可以通过键盘的左右键来操作图形的移动。每当表示每种行为状态的变化时，我们就要引入事件的监听。左右移动顾名思义就是在y轴坐标不变的条件下，移动x。向右移动x变大，向左移动x减小。最后再重新绘制图片。但是这里有我们需要写一个函数，来判断图形是否还可以继续移动，当图形向右移动到最右边触碰到墙壁的时候此时就不能再向右移动，反之亦然。因此我们可以用两个for循环对图像的每个点遍历，当有一个点碰到墙壁则返回false。</p><h5 id="3-旋转">3 旋转</h5><p>就是改变图形的状态，在已知图形的种类和初始状态的条件下，每点击一次按钮就旋转90度。这里我们还需要判定是否可以旋转，当图形已经碰到了另外的图形，则此时不能在放生状态改变。就是我们在绘制地图时，默认0为空，1为已填充图形，2为墙壁。同样还是对当前图形状态的每一个点做遍历，若图形已经碰到最底部的墙壁或者两个图形出现相重叠部分，那么也不能旋转。这两个条件，我也是借鉴了网上的代码。</p><h5 id="4-下落">4 下落</h5><p>默认如何图形可以移动，那么每次timer重新刷新界面y坐标就会自动加1。如何碰到地面或者两个图形重叠，那么下落停止。</p><h4 id="5-重绘界面-设置分数">5 重绘界面 设置分数</h4><p>首先我们设定一个全局变量反应当前游戏得分，每消除一行则加10分。我们设定timer线程每隔一段时间重新绘制界面，每次当一个方块落地后无法移动时。我们会将其加入到map地图中，就是对图形的x，y坐标对应到map中，将原来是0的地方填充为1。然后我们还需要检查是否出现方块填满一整行的情况。这里就是对map进行遍历，两层循环，外层遍历行（从最后一行开始），里层循环遍历列（从第一列开始），设置一个变量来记录每一行已填充的方块数量，如果填充的方块数量刚好等于，游戏容器的宽度减2（墙壁）。于是我们将此行上面的所有行向下移动一行。</p><p>做到这一步：我们游戏就已经见成效了，在这里做一个小的演示：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 18.44.12.png" alt="Screenshot 2019-12-25 at 18.44.12" style="zoom:25%; "><h4 id="6-完善游戏体验与调试">6 完善游戏体验与调试</h4><p>其实每次最后一步就对游戏进行一个简单的测试，检查是否出现bug。完善一些小功能，修改一下UI设计。</p><h5 id="游戏结束-分数记录-暂定-重新开始-下一个图形">游戏结束 分数记录 暂定 重新开始 下一个图形</h5><p>游戏结束条件就是我们的方块累计到达了顶部，这个我我们可以写一个方法，判断在最顶上一行是否出现填充的方块，如出现，游戏结束。然后我们需要对比当前得分与游戏最高得分做对比，若当前得分高于最高得分，则更新。</p><p>游戏重新开始，就是将分数清0，然后重新绘制地图，墙壁，初始化方块。</p><p>游戏暂停与继续，对timer线程调用api，start/stop。这里我们用JMenu做了一个分级菜单，菜单里我们可以退出，暂定，继续游戏。别切阅读游戏玩法提示。</p><p>下一个图形，这个玩过俄罗斯方块的都知道每当一个图形初始化后，右侧界面都会出现的下一次图形的提示。这里我们就是新建两个随机数，分别代表图形种类和状态。然后在每次每次初始化新图形，重新绘制面板时，在界面右侧绘制下一次将要出现的图形。</p><p>最后给大家看一个完整版的效果图：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-29 at 00.11.28.png" alt="Screenshot 2019-12-29 at 00.11.28" style="zoom:25%; "><h4 id="建议阅读时间-8分钟，-程序实现-java，-源代码">建议阅读时间 8分钟， 程序实现 java， 源代码:</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris</a></p><h4 id="总结：">总结：</h4><p>大概用了7个小时去进行程序整体设计，编程实现，调试，代码优化。然后4个小时去写文档。基本上完成俄罗斯方块的复刻，当然，还有细节做的不够好，比如背景音乐，方块颜色……</p><p>最后想说一说最近编程的一些感想，编程可能语言在不停的变，但是面向对象的思想没变，数据结构没变。我觉学习一门技术最重要的不是看概念，而是不停的实践，理论基础是在实践中总结出来才能记得更牢固。任何一个框架，技术都有自己的套路，当我们熟悉它之后，学会用计算机的思维方式去思考的时候，那么我们才能做到学以致用。（说远了，我也是差的还很远）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flappy bird</title>
      <link href="/2019/12/28/flappy-bird/"/>
      <url>/2019/12/28/flappy-bird/</url>
      
        <content type="html"><![CDATA[<h2 id="Flappy-Bird-仿写">Flappy Bird 仿写</h2><p>通过之前做贪吃蛇和小恐龙跳跃，对jframe，swing和awt的基础已经回顾的差不多了，因此这篇文章就不再一一赘述我已经写过的细节。讲讲大体上实现思路，设计模式还有哪些点需要注意。惯例，还是把所有素材和源码放到github上。</p><p>Flappy bird这个游戏是2014年一个在美国工作的越南裔移动端游戏工程师（Dong Nguyen ）开发的，然后在apple商店推出后就瞬间爆火，然后其自己突然让游戏下架。我在youtube上看了一些视频，据说此事与dark net相关（也不知真的假的）。后来，过来一段时间，他又从新上架这这款游戏，可是已经没有了当时的人气。因为我也认识当事人，也不知道事情的来龙去脉，所以今天我只是从技术的角度去复习这款游戏。</p><h4 id="技术选用与涉及技术：">技术选用与涉及技术：</h4><p>java8， eclipse IDE, jframe，awt，swing，thread</p><h4 id="思路">思路:</h4><p>由于我从事的领域并不是游戏开发，这只能算是我的爱好也是对技术的温故知新，所以我只是讲讲我对其的认识。我发现市场很多游戏都是单页面应用，我所指的单页面就是玩家对于操作对象始终停留在一个窗口中，我们通过不停的变化背景，生成障碍物去让游戏继续。对于这些单页面的应用，我通常的实现步骤就是先创建一个叫app的class，此类包含main函数，就是程序的入口，在这里面预设一个固定大小的主窗口初始化，加入监听器，然后再新建一个gamepanel类，所有的逻辑都会在这个类中完成。并将此类在app中事例化。然后分别对此程序中涉及到的所有对象创建class，比如小鸟（bird），管道（pipe），线程（thread），游戏本身所有的规则（game）。我本人的开发习惯是喜欢单独建一个辅助类（helper），存放所有的辅助函数，比如想图片的读取，声音的播放之类的。这些大概的轮廓搞好后，然后我们开始写程序。</p><h4 id="1寻找素材-调整合适大小">1寻找素材 调整合适大小</h4><p>这里我听取网友的建议然后进行过测试</p><p>小鸟3张 翅膀平行，下落，上升  管道2张（朝上和朝下） 背景图片一站 陆地一张</p><p>小鸟尺寸为 45 * 32 pixel</p><p>管道为为 66*400 pixel</p><p>大地和背景都为 500*500 pixel</p><h4 id="2-绘制背景，管道-，小鸟">2 绘制背景，管道 ，小鸟</h4><p>首先绘制背景，分别加载两张背景图片，注意顺序，当图片累加时会有重叠的问题。</p><p>然后是小鸟，给小鸟一个初始化的位置，作为游戏的起点。最后是管道。管道分为朝上和朝下，管道的宽度是固定的，也是给定一个初始值。</p><p>完成这一步，效果就是大概这样的：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 01.23.53.png" alt="Screenshot 2019-12-15 at 01.23.53" style="zoom:25%; "><h4 id="3-让小鸟跳跃-移动-挥舞翅膀">3 让小鸟跳跃 移动 挥舞翅膀</h4><h5 id="Step1-小鸟移动">Step1 小鸟移动</h5><p>实现这个功能，我需要预设一个jump为小鸟的单次上升高度。还有一个gravity引力系数，常识由于有地心引力的存在下降速度总是比上升速度快，我预设一个0.5，就是在我这个游戏中下降速度是上升速度的两倍。这里还有一点需要注意就是按键，如果按了空格键，小鸟位置上升，不按空格键，小鸟则直接下降，通过不停的点击空格键是可以让小鸟的高度累加。为了更贴近现实，我加入了一个图片旋转的功能，就是上升时，小鸟的头部会向上倾斜，反之亦然。此时我们可以通过awt的内置类affinetransform对图片进行一定幅度的旋转。</p><h5 id="Step2-小鸟跳跃">Step2 小鸟跳跃</h5><p>与小恐龙制作相差无几，我们可以让背景以一定的速度从右向左移动就可以达到一种小鸟在移动的感觉。此时我们需要用到线程，每隔一定的时间，重新绘制背景。我预设一个25ms，每25ms线程就会更新一次小鸟以及背景的位置。然后对键盘键监听，按空格键则小鸟位置上升，松开空格键则位置下落。</p><h5 id="Step3-挥舞翅膀">Step3 挥舞翅膀</h5><p>找到三张不同的图片是小鸟翅膀的位置分别在上中下，然后每隔25ms，单线程调用时累加游戏时间除以100再对3取余数，就达到了每100ms小鸟的翅膀就移动一次位置。</p><h4 id="4-管道的出现-移动">4 管道的出现 移动</h4><p>因为我们每隔25ms线程会去重新刷新界面，所以我们给定管道一个初始速度3。每25ms，管道向左移动3pixel。然后取一个在50-200之间取一个随机值，代表在接下来的50-200pixel会出现下一个管道。对于管道的y坐标，需要多考虑一点，因为小鸟的高度是32pixel，然后管道的高度是400pixel所以管道只是在界面中显示一段，我对于游戏的设计就是朝上的管道和朝下的管道总是成对出现，然后为了保证小鸟可以顺利通过管道，我给两个管道中间预留了50-120的pixel，然后再去推理出朝上和朝下管道具体的y轴值。</p><p>完成这一步，游戏也就实现了60%，效果如下：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.02.16.png" alt="img" style="zoom:25%; "><h4 id="5-碰撞检测">5 碰撞检测</h4><p>首先先新建一个arraylist用于存放出现的管道。奇数代表朝下，偶数朝上。用一个i记录当前管道。与小恐龙撞仙人掌相同，如何判定小鸟是否可以通过管道，我们需要对小鸟进行碰撞检测。每一组碰撞检测可以分为四个方面，我用两张图片向大家更好的讲解。</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.03.46.png" alt="Screenshot 2019-12-15 at 02.03.46" style="zoom:25%; "><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-28 at 23.54.44.png" alt="Screenshot 2019-12-28 at 23.54.44" style="zoom:25%; "><p>我们取到小鸟的头部检测小鸟有没有碰到管道的两个前沿，以及小鸟分过管道后是否碰到管道的后沿。当然是存在一定可能小鸟会碰到管道的中间，但在我这个游戏中，我已经计算过，线程25ms刷新一次，如果小鸟在进入管道前没有撞到管道，小鸟在跳跃或者下降，因为宽度固定，所以小鸟已经走到管道外。因此我只需要检测管道的头和尾。与小鸟的头和尾即可。</p><p>当然，我们还需要检测小鸟的位置使其置于大地和天空之间，如果超出范围也是碰撞。</p><h4 id="6-游戏暂停-结束-重新开始">6 游戏暂停 结束 重新开始</h4><p>暂停：设置一个全局变量pause，初始值为false。点击p时则pause变为true，此时游戏暂停。在界面中写出提示语，点击p键继续游戏。我们需要暂时让线程停止工作，从而使画面不刷新。</p><p>结束：设置一个全局变量death，初始值为false。当小鸟碰到大地，天空，管道时，death为true。在界面给出提示语，游戏结束，点击R键从新开始游戏</p><p>重新开始 ： 从新初始化小鸟的位置，分数，清空管道的list。</p><h4 id="7-分数统计-记录">7 分数统计 记录</h4><p>在主窗体底下设置一个长矩形，分别代表当前得分和记录，没通过一对管道增加1分，当游戏结束时，比较当前得分与最高得分。若当前得分高则更新记录。</p><p>最后呈现一下最终效果：</p><h4 id="源代码：">源代码：</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird</a></p><h4 id="总结：">总结：</h4><p>通过此次的flappy bird的开发，相比于前两次无论是开发时间，思路，完成度从自己的角度出发都有了一定程度的提升。同时也学到了一些新的写法和awt的用法，比如图片旋转；把游戏逻辑单写成一个类来封装；对于按键监听的press，release双操作。下一次，我想复写一下马里奥（mario），以此结束Jframe这个模块。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trex up</title>
      <link href="/2019/12/28/trex-up/"/>
      <url>/2019/12/28/trex-up/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾：">前情回顾：</h4><p>不知道从那一年开始，这个不重要。 google 设计师在每次chrome断网时加入了一个彩蛋，此时此刻，将会出现一只萌萌的短腿霸王龙（Trex）开始原地踏步，然后点击space此时小恐龙向上蹦一下。然后接连出现仙人掌和小鸟，在我们灵力的操作下霸王龙躲避一个个障碍。隔一段时间，背景变为黑色，随着跨过障碍物越多，分数越高。</p><p>这个游戏操作简单，玩起来简单快捷。同时缓解了我们在断网时候的焦急，可以说这只萌萌的霸王龙可谓成为了网络萌宠，流量大咖。这篇文章我们来聊聊从0实现这个小恐龙，别小瞧这一个简单的游戏，在其背后google工程师也是写几千行的js代码, 其背后的逻辑以及设计确实有很多为人称赞之处。在看过源码之后，我用java还实现这个高仿版的小恐龙跳一跳，也是参考 学习google的思路。</p><p>此文章我通过以下六部分来具体讲述，可以说这个简单的小游戏结合了UI，窗口，监听器，面向对象非常适合我们用来练习。</p><h4 id="1背景绘制">1背景绘制</h4><p>首先我们需要明确窗口的概念，JFrame&gt;JPanel&gt;ContentPanel。因此我们从网上找到资源（大家可以直接上我github上下载，链接在文章底部），然后通过设置JFrame的setbounds内置方法来设定窗口的大小。这块有两点需要注意，首先如何更改查看图片的大小，我用的是Mac，通过预览可以直接查看，并且调整图片的大小。</p><p>这里我就不多赘述，我自己测试过很多次之后，在宽734高286pixel是可以达到不错的小显示效果。第二点，setbounds这个函数有四个参数，X，Y，width，height。宽和高就是图片的宽和高，X，Y和我们现实生活的坐标系有一点差别，屏幕的左上顶点就是（0，0）的位置，这个刚开始可能不大适应，写多了就习惯了。然后把屏幕放在剧中的的位置，设置可见，标题。这些都是由内置的函数，可以直接调用，最后给大家看一下效果。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><h4 id="2-绘制小恐龙-踏步-跳跃">2 绘制小恐龙 踏步 跳跃</h4><h5 id="第一步-绘制静态小恐龙">第一步 绘制静态小恐龙</h5><p>和绘制地面背景一样，先找到一个小恐龙的图片，然后根据我们的背景调整小恐龙的大小。然后我们需要调整恐龙的坐标，将其放在陆地上。这些坐标问题感觉让我们一下回到了中学，推敲一个个坐标的位置。然而实际的游戏的开发是有游戏引擎的，所以可以简化位置的摆放，java本身的设计也不是用来写游戏，据我所知游戏还是多用c++的开发，现在可能随着unity的不断更新，cSharp也是不错的选择。我没有引擎，我就通过在本地的画图推算，测试坐标。</p><p>然后我们看一下效果, 这里因为背景图片width 734pixel，height 286pixel。我设定的小恐龙位置在（50，200）x, y分别指的是距离左上定点的像素。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 15.19.14.png" alt="Screenshot 2019-12-08 at 15.19.14" style="zoom:25%; "><h5 id="第二部-如何原地踏步">第二部 如何原地踏步</h5><p>这里就要引入一个图片与视频的概念。其实我们平时所看到的视频，是由一个一个图片快速更替而成。比如常见的24帧，指的是一秒钟扫过24张图片此时我们就感觉图片在动，就是我们平日所看到的视频。所以如何让小恐龙给大家一种原地踏步的感觉，大概思路就是找到两张图片，一张图片左脚着地，另一张图片右脚着地，然后这两张图片不停的交替。所以要实现这个功能我们需要引入一个单独的线程，其实和贪吃蛇差不多，我们需要小恐龙线程每隔10ms就去重新绘制次图片。然后我预设每100ms短腿小恐龙换一次着地腿。每次增加10ms，每次执行时对2取余数，为0则选用左脚着地图片，反之亦然。</p><h5 id="第三步-按下space键-小恐龙跳跃">第三步 按下space键 小恐龙跳跃</h5><p>这里引入一个按键监听器，当我们键盘点击space时，我们将小恐龙设置为跳跃状态，并更换一张新的图片，其实跳跃就是改变小恐龙的y坐标，我也是经过测试后，设置短腿霸王龙的跳跃高度为100像素。这里有一点特别需要注意，小恐龙跳跃一次后需要落地才能进行，下一次跳跃。因此我们设置一个值，每次跳跃了则y坐标变化，让其与地面坐标对比，如果小于等于则说明小恐龙在空中则无法再跳跃，返回地面。如果在地面上则可以再次跳跃。</p><h5 id="3-小恐龙移动">3 小恐龙移动</h5><p>这是一个很关键的一步，实现不难，关键是思想的转化，在我们的认知中我们认为是小恐龙在动通过跳跃躲避障碍。因此我打开了google的trex up做了一个实验，我把鼠标放在小恐龙头上，从始至终小恐龙一直与我的鼠标的y轴成一条垂直地面的直线。这说明小恐龙没有动，那么谁动了呢？答案就是图片在不停的从右向左以一定的速度在变化。</p><p>然而怎么能够实现这个呢，我在这里画一个图片（有点简陋，不要见怪）</p><img src="/2019/12/28/trex-up/pictureloop.png" alt="pictureloop" style="zoom:25%; "><p>如图所示，我们找到两张大小尺寸背景一模一样的图片，然后分别让两个图片的x坐标连接在一起，并且让两张图片一样的速度从右向左移动，当图片2到达x坐标为0时，图片1到达-734，然后我我们再把图片一放到图片二的后面。以此类推，循环往复，我们让背景动，小恐龙在原地。于是就给我们一种小恐龙动起来的感觉。</p><p>然后同样的道理，我们可以设置云彩，月亮，白天黑夜。（这里就不详细说了，感兴趣的小伙伴可以私信我）</p><h5 id="4-障碍物设置">4 障碍物设置</h5><p>现在小恐龙可以动可以跳，可以动，背景可以交替，现在我们就要设置障碍物。首先还是一样找资源，就是找图片。google trex up用到的障碍物是仙人掌和小鸟，我也就去找了仙人掌和小鸟。其中仙人掌有稍高一点的稍矮一点的，三个在一起的单独的。小鸟出现的位置是在大地和天空之间，有一定的飞行速度。然后找到资源后，我们需要对仙人掌进行摆放的测试，或者简单来讲我们可以把仙人掌直接设置为与小恐龙的y坐标相同。小鸟的y坐标我们可以生成一个随机数在大地和天空之间。</p><p>这里有一个关键的问题移动，我自己在开放的时候，看了很久为什么障碍物总是不停的出现在相同的地方。debug，trace之后发现，我设置了图片以3pixel每10ms向左移动，但是仙人掌却一直在原地，因此我需要对仙人掌也设置一个同样的速度。小鸟的话就需要多考虑一点，小鸟的速度比图片走的快，所以我对小鸟的速度，预设的高一点。</p><p>做完这些之后，为了让小鸟出现震动翅膀飞翔的效果，我对小鸟做了和小恐龙原地踏步一样的操作。对于障碍物的出现概率，我使用了和贪吃蛇随机出现桃子，苹果，橙子一样的机制。对不同种类的仙人掌和小鸟做一个概率设计，然后用一个变量代表出现的障碍物是什么。出现不同的障碍物刷新时加载相对应的图像。</p><p>做到这里，程序已经完成了70%，我们看一下效果</p><p>![Screenshot 2019-12-08 at 18.54.45](Screenshot 2019-12-08 at 18.54.45.png)</p><h4 id="5-碰撞检测">5 碰撞检测</h4><p>出现障碍物，我们就要考虑如何让小恐龙通过跳跃的方式躲避障碍物。这里我们就可以将小恐龙和障碍物分别看成两个矩形，然后取交集，如果不为空，则说明撞击了，game over，否则游戏继续。当然在这里，最简单的做法是，我们直接让对两个矩形求重合，这样可行，但对于游戏忠实玩家来说，这样做确实降低了游戏的可玩性，既然做了，我就希望可以做的最好。因此我在这里讲一下，我的做法，当然我也参考了网上的文章。</p><p>首先我们考虑小恐龙撞击障碍物可以假设为头和脚撞击，因此我们可以对小恐龙图片以整数倍放大，然后截取其头部和尾部（尽可能精确）。正如图所示，分别记录下两个矩形到左上顶点的坐标，以及两个矩形的长度和宽。同理对小鸟也进行同样操作，记录小鸟头部的矩形和尾部的矩形。接着对仙人掌取到碰撞区域，然后每次小恐龙遇到障碍物时，我们通过检测其有无重叠从而知道是否成功跨过障碍物。这里在调试的时候，有一个小技巧，我们可以通过填充矩形的方式观察，我们制定的碰撞区域是否合理。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 19.13.52.png" alt="Screenshot 2019-12-08 at 19.13.52" style="zoom:25%; "><img src="/2019/12/28/trex-up/Screenshot 2019-12-28 at 22.45.29.png" alt="Screenshot 2019-12-28 at 22.45.29" style="zoom:25%; "><p>比如，我把小恐龙的头部填充去测试我的碰撞。这一步确实很考验人的耐心。当然在现实生活中的碰撞检测，是有游戏引擎的，他是一个多边形，是有很多物理公式包含在里面，可以精确到像素与像素的碰撞。确实很多游戏引擎也都是机密不公开的，就像任天堂Nintendo</p><h4 id="6-分数计算，-game-over，-重新开始，-游戏暂停">6 分数计算， game over， 重新开始， 游戏暂停</h4><p>最后，我们来对游戏进行一个补充完善。分手计算，我们的方法很多，可以是通过时间，通过障碍物的数量。我就是通过时间计算分数，每隔50ms，增加一次小恐龙的分数。game over就是小恐龙碰撞到障碍物，我们对矩形取交集。如果不为空，则关闭线程，提示给玩家game over。重新开始，还是需要注意一点，就是移除所有旧的组建，新建新组建然后从新开始游戏。暂停，停止刷新游戏界面。分数显示，设置两个5位数，一个是记录，另一个是当前游戏的分数，游戏结束时从新结算，若打破游戏记录则更新。</p><p>到这里我们的小恐龙就做完了。通过这次的开发，除了温习旧知识，也学到了很多新的知识。也还有很多地方做的不够完美，比如没有加按键声音，昼夜交替做的不够平滑，小恐龙刷新的速度没有改变。总体来讲，完成了对于google 80%的仿写。</p><h4 id="源代码与素材均在我的github上">源代码与素材均在我的github上</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>greedy snake</title>
      <link href="/2019/12/28/greedy-snake/"/>
      <url>/2019/12/28/greedy-snake/</url>
      
        <content type="html"><![CDATA[<h4 id="前情提要">前情提要:</h4><p>相信所有人的童年里都玩过贪吃蛇，在那个智能手机还不发达的时代，诺基亚和摩托罗拉还是市场的霸主，那个时候手机大概每款手机里都有个贪吃蛇的游戏。当然，我这个文章不是和大家怀旧，还是本着以技术为主，记录生活的本质。其次，我觉得贪吃蛇这个项目简单有意思，非常适合新手入门学习java。</p><h4 id="开发原因：">开发原因：</h4><p>本周在工作中遇到了Jframe和线程的bug，JFrame应该是一项很老的技术，上学的时候被作为一门教学语言，常常配合着AWT和SWING来用。当然，就目前来讲，桌面应用还是微软的天下（window操作系统），winforms，wpf， uwp这些成型的mvvm框架，开发简洁，尤其是其前端的UI拖拽绘制界面，nuget一键下载各种包确实比JFrame好用很多。当然要是IOS系统，那就是苹果全家桶了，再往下说就太多了。所以回归正题，jframe虽然有点过时，但是由于java仍然还是还是服务端的中流砥柱，其稳定高效跨平台的特点还是被大家所青睐，再加上很多公司java项目存在已久，像替换不是那么简单一句话的事。所以在此复习一下JFrame和线程操作，同时也来重温一下童年。</p><h4 id="开发流程与工具：">开发流程与工具：</h4><p>Eclipse ID<br>Java8， JFrame， Swing，Graphics，Timer线程</p><p>首先我设置了一个1200<em>720pixel的画板， 然后将（25，75） - （850，625）的区域设置为贪吃蛇游戏区域。并把这个区域等分成25</em>25的小格子，长度为34个小盒子，宽为24个小盒子。其中蛇每次可以移动一个小盒子</p><h4 id="第一步：初始化蛇">第一步：初始化蛇</h4><p>刚开始蛇的长度为3，其中蛇头1，蛇身2。蛇头需要考虑到上下左右四个方向，我就依次找到了四个图片代替。对于蛇具体化的实现，二维list，或者listnode都可以，为了简便开发，我就用数组其实主题的逻辑思维都是一样。二维数组分别代表蛇的每一部分在x, y轴对应坐标。我初始化蛇的方向向右，给定蛇的具体坐标。然后我这里调用JPanel自带的Graphic类复写paint方法。分别画出头和身体。<br><img src="/2019/12/28/greedy-snake/initSnake.png" alt="initSnake" style="zoom:25%; "></p><h4 id="第二步：蛇的移动">第二步：蛇的移动</h4><p>这里有一个小的问题，需要大家注意，就是每次移动我们需要先移动身体在移动头。这里有点与现实生活相反，为什么这么做，如果我们先移动头的话，那么头位置改变后，身体指向的位置本应该是原来头的位置，现在却指向现在头的位置从而造成蛇移动后有一条直线变成了一个点。<br>其次就是按键加上监听，上下左右代表移动。<br><img src="/2019/12/28/greedy-snake/snakeMove.png" alt="snakeMove" style="zoom:25%; "></p><h4 id="第三步：吃食物">第三步：吃食物</h4><p>我初始化了四种食物，分别为橙子，桃，苹果，分别代表1，2，3分。还有毒药，吃过吃了毒药则减10分。因为苹果，桃，橙子的分数不同，所以概率也不同。然后蛇每吃掉一个水果后就会更新一个新的水果，如果一定时间内没有碰到毒药毒药则消失，一段时间后再次出现。这里有三点需要注意。</p><h5 id="1">1</h5><p>如何生成概率不同的随机数？这里有个小技巧。生成从1个随机数范围是从1到100，然后如果其小于50则返回橙子1分，大于50小于80则返回桃子2分，大于80小于100则返回苹果3分。其概率分别对应50%，30%和20%</p><h5 id="2">2</h5><p>如何生成水果和毒药？我们需要水果和毒药的坐标，生成两个数字x, y范围分别在（1，34）和（1，24）之间，然后乘25就是对应x，y轴的位置。然后每次需要确认，毒药和水果的位置没有重合, 并且没有和蛇重合。<br>&lt;img src=‘eatFood.png’ alt=‘eatFood’ style:&quot;zoom:25%; &quot; /&gt;</p><h5 id="3">3</h5><p>如何刷新水果和毒药的坐标？当蛇头的x, y坐标等于水果的位置则证明水果被吃掉，此时从新生成新水果。如果毒药被吃掉，看一下分数，小于0则游戏结束，大于等于零则仍可以继续。这里我用到一个timer的线程，每隔1ms观察一次。然后我再建另外一个毒药的timer线程，每隔15s，去看一下毒药是否存在，如果存在则消失一段时间然后再重新刷新位置，如果被吃掉了则直接刷新位置。</p><h4 id="第四步：game-over，-暂停-和-重新开始">第四步：game over， 暂停 和 重新开始</h4><p>有三种可能性造成游戏结束，第一蛇头撞击墙壁，这就是每次移动后，我们取到蛇头的方向，然后分别判断其是否等于边界坐标，如果不等则游戏继续。第二点，蛇头撞击蛇身体，这里我们可以用一次for循环，遍历蛇头和蛇身体坐标，如出现一次蛇身体等于蛇头，则证明重合了游戏结束。最后就是吃了毒药分数小于0，加一个判断条件即可。<br>暂停和重新开始都是按space，预设两个个boolean类型值，分别代表暂停和游戏失败。每次一按spce，先判断是游戏失败还是暂定，如有失败，则重启游戏，若暂停，则游戏继续。这里需要注意，不能在暂停时候移动蛇头，所以要多写一个条件。</p><p>&lt;img src=‘gameover_stop.png’ alt=‘gameover_stop’ style:&quot;zoom:25%; &quot; /&gt;<br>最后，我设置了一个变量作为游戏记录，分数更新则刷新纪录。</p><h4 id="资源及源代码">资源及源代码</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake</a></p><h4 id="展示">展示</h4><p>放上一个视频，看一小效果^*^<br><img src="/2019/12/28/greedy-snake/show.png" alt="show" style="zoom:25%;"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> timer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>battle dev review</title>
      <link href="/2019/12/28/battle-dev-review/"/>
      <url>/2019/12/28/battle-dev-review/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾">前情回顾:</h4><p>周二晚上下班，感觉不是很累，于是颇有兴致的参加了一个叫battle dev的线上比赛，如果要是能拿到前三名，那奖励确实很丰厚，但是茫茫人海中，我也确实意识到自己还有很多待提高的方面。Ò<br>因此仅以下文，回顾并记录自己这次比赛中的收获。</p><h4 id="比赛形式：">比赛形式：</h4><p>时间两小时，题目五道题，难度逐渐增加，必须通过所有的test case测试，才能看到下一个题。编程语言不限定。</p><h4 id="第一题">第一题</h4><img src="/2019/12/28/battle-dev-review/question1.png" alt="question1" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question1.2.png" alt="question1.2" style="zoom:25%; "><p>眨眼一看，题目论述很长，其实是一道热身题，大概意思大家一起去出游，由于天气原因和突发状况，现在有一个人需要睡在没有帐篷的空地上。于是大家决定抽检，抽到最短的人去睡空地。<br>解法很多种，我就说一个我自己的解法。预设一个最小值，然后scanner不断扫描下一行，知道结束为止，如果发现有出现距离比预设值小，那么更换最小距离，并记录姓名，输出。<br>具体代码如下：<br><img src="/2019/12/28/battle-dev-review/solution1.png" alt="solution1" style="zoom:25%; "></p><h4 id="第二题">第二题</h4><img src="/2019/12/28/battle-dev-review/question2.png" alt="question2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question2.2.png" alt="question2.2" style="zoom:25%; "><p>同样也是论述很长，理解之后发现其问题也是不难，但很有意思，需要我们转化一下思维。因为当天我在做题时，也是犯了两次错误，才意识到他究竟想让我们求什么。题目大概说，为了庆祝奶奶的生日，某人决定用纸板去做装饰，告诉我们纸板可以重复使用，宽高都相同，只有长度不等。随机从纸箱中抽取四个纸板，可以对每个纸板裁剪成两半，让后我们保留自己用的一半，另一半扔掉，最后拼成最大一个正方形。问舍弃的面积<br>可以说这个题还是给我们挖了坑，我就是直直的往里跳，其实思路大概相同，四次取出的纸板长度总和再开平方得到的就是最大面积。我也是这么做的，相信第一次很多人和我的想法一样，然而这样做，我们就忽略了一个重要的条件，每次我们要将纸板分成两半，只能留一半。<br>所以需要我们换一个思维，反过来想，当我们舍弃的模板长度最小的时候，剩余的正方形面积则最大。我们每次最少舍弃多少木板，我们来抽象一个最坏的情况：</p><hr><p>First time : 5 cm<br>Second time : 4 cm  5 - &gt; 4.reject 1 cm<br>Third time : 3 cm.4 -&gt; 3  reject 1 cm * 2 + 1 cm<br>Fourth time 2 cm.3 -&gt; 2.reject 1 cm * 3 + 2 cm * 2 + 1 cm</p><hr><p>实际就是四次最小长度，剩下的就是最大正方形。 想到这里，那代码就很简单了，具体如下<br><img src="/2019/12/28/battle-dev-review/solution2.png" alt="solution2" style="zoom:25%; "></p><h4 id="第三题">第三题</h4><img src="/2019/12/28/battle-dev-review/question3.png" alt="question3" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.2.png" alt="question3.2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.3.png" alt="question3.3" style="zoom:25%; "><p>相比前两个题，第三题明显难度就提升了，实话说，当天我也是大概用掉40分钟才解决此问题。首先再读完题，由于之前在leetcode上碰到过一个与之相似问题，253 meeting room。leetcode问的是对于给出的时间表最少需要多少间教室。下一篇文章我会拿meeting room与这个题做对比，顺便复习总结一下优先队列。所以，读完题，我就已经想到要用priotity queue。<br>接下来说说这个题具体问什么，我们有n个电缆和m个request。每个request对应有起始时间和结束时间。问我们n个电缆是否满足m个request。如果满足，则输出电缆的使用顺序，反之亦然。<br>这个题有三点需要我们注意。第一，request是乱序的，所以我们需要用优先队列对其进行排序，用什么排序，按照题意，起始时间小的在前面，如果相同，则终止时间小的优先。第二，电缆数量不一定满足request的需求，所以需要我们在创建一个priority queue去记录电缆的时候用情况，如果有空闲电缆则可以直接使用。如没有则需要我们分类讨论，遍历正在使用的电缆，看看的当前电缆的开始时间前，是否有电缆可以使用完成。如果没有，则返回false，结束程序。第三点，也是最容易被忽视的一点，我也因为这个白白耗费15分钟，题目让我们输出的是电缆使用顺序，我们是要根据优先队列的弹出顺序决定电缆使用顺序，而不是自己顺序排列。<br>综上所述，我放上我自己的代码</p><p><img src="/2019/12/28/battle-dev-review/solution3.png" alt="solution3"></p><h4 id="第四题">第四题</h4><img src="/2019/12/28/battle-dev-review/question4.png" alt="question4" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question4.2.png" alt="question4.2" style="zoom:25%; "><p>当天我也是做到第四题，读题到写代码大概用了25分钟，然后就gg了。确实当时没有做出来，我在这里就说说题目的大概意思，以及我记得思路，这个题题目里给了提示联想背包问题。所以我们可以很快的想到用动态规划解决。但是相比于背包问题，这个题有点特殊，他的粉末可以按克买，所以还需要再去讨论。<br>题目，给出n种宝石，m种粉末，给出每种宝石的重量和价钱（不可拆分），给出每种粉末的价格，可以按照g来买。给定一个重量问怎么能获得对大利益？</p><hr><p>大致思路，二维dp数组dp[i+1][j+1], i代表种类，j代表数量。终止条件超出重量j<br>第一次列出，只用一种宝石的情况，最大的利润。<br>第二到N次，以此类推，max（dp[i][j-1]+Vi*Wi, dp[i][j])</p><hr><p>关键是粉末可以拆分成g，所以数据规模很大，我当时是将每个粉末拆分成g在此讨论可能是超时，没有通过，我会再修改修改更新文章与大家讨论。</p><h4 id="收获">收获:</h4><p>简短的来说，还是意识到自己的不足，第一语言方面，读题理解时间过长，每道题要白白消耗掉10分钟完全用于读题理解，说明语言还需要精进。第二，做不到学以致用，还是缺乏将实际应用问题段时间联想到已知技术。第三，动态规划和graph的问题一直都是自己的短板，需要专项提升。</p>]]></content>
      
      
      <categories>
          
          <category> Programming contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priorityqueue </tag>
            
            <tag> dynamique programming </tag>
            
            <tag> string </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sliding window1</title>
      <link href="/2019/12/28/sliding-window1/"/>
      <url>/2019/12/28/sliding-window1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/12/28/sliding-window1/slidingwindow1.jpeg" alt="slidingwindow1"></p><p>sliding window直译为滑动窗口，大家可能直接会想到我们平时生活中的推拉窗户。在我们实际编程中，他也正是模拟这个生活中的场景，先去拉一个窗户，再去推另一个窗户。这个过程中我们分别用两个变量去代表这两个窗户，一快一慢，一左一右，这也是我们经常提到双指针问题。虽然在java，python，javascript，Csharp… … 等诸如此类的面向对象高级程序语言中，我们已经对指针弱化，将其变为对变量的引用，很大程度上简化了开发，但是指针的思想在我看来却仍然适用，而且加深对其的理解也有助于我们的编程。因此在思考了很久之后，我将sliding window这个主题作为我的第一篇文章。</p><h4 id="导语">导语:</h4><p>首先，sliding window，无论是我们熟知的🇨🇳大厂，百度，腾讯，阿里，头条… 或是美帝的google，amazon，fb，netflix… . 都十分青睐用此类型题目 去考察面试者。回过头想为什么，仅以我现在的知识我觉得，此类型问题本身并不复杂，问题的难点主要在两点 ：1 如何在面试中将问题理解，并能够想到用sliding window去解决这类问题 ，尤其是模拟实际生活的题，更是需要我们融会贯通。2 实现过程中有很多小的细节需要注意，例如窗口的滑动，触发一定的条件，左右指针不断的变化，导致结果随之变化，因此我们在实际手撕代码的过程中，经常出现bug。因此本文从算法分析，思路解析，再结合题目与代码去谈这个问题。。。废话不多说，进入正题。</p><h4 id="算法分">算法分</h4><p>滑动窗口大多数是用双指针求解，也有一些特殊的问题我们会结合一些特殊的数据结构，例如sorted_map（priority queue）或者的dequeue。对于此类特定的题型，我会在第二篇文章中讲述。本文主要讲述一般情况下的sliding window解决思路。</p><p>一般情况下的sliding window会给予我们一个特定数组或者字符串，让我们去找到满足一定条件的子数组或子字符串。比如：<br>找到最短字符串包含特定字符（有重复，无重复）<br>最长的子数组或字符串最多含有k个字符<br>最长的子数组或字符串只含有k个字符<br>一个特定的字符串在长字符串中出现的位置<br>……….</p><p>此类型题的大概时间复杂度为o(n)，需要遍历一次长字符串, 空间复杂度大多为常熟级别，近似于int[128]。之所以称为sliding window是由于，我们分别用快慢两个指针一前一后夹着字符串遍历，类似于一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。</p><h4 id="解题思路">解题思路</h4><p>这类型题的整体思路是设置两个快慢指针。快指针从左向右移动，目的是在每个快指针停留的位置，触发一定的条件，然后慢指针再随之移动，当其满足某种条件后，快指针再移动，周而复始，直到字符串遍历完毕，退出循环。<br>因此重点就在于，什么时候移动窗口，什么时候窗口保持不变。下面我写一个伪代码模版，给大家参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">sildingwindow</span><span class="params">(String [] strs. .. )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理边界条件  参数判断</span></span><br><span class="line">If( condition )</span><br><span class="line"> <span class="keyword">return</span> </span><br><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="comment">//left 代表窗口左边， 慢指针</span></span><br><span class="line"><span class="comment">//count 计数，用于判断何时触发条件</span></span><br><span class="line"><span class="comment">//result 记录结果</span></span><br><span class="line">Int left = <span class="number">0</span>, count = <span class="number">0</span> ,result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//申请一个hash数组, 也可用其他数据结构比如hashmap</span></span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> hash[<span class="number">128</span>]</span><br><span class="line"><span class="comment">//遍历数组，right代表窗口右侧，快指针</span></span><br><span class="line">For(<span class="keyword">int</span> right = <span class="number">0</span>; right&lt;strs.length;right++)&#123;</span><br><span class="line"><span class="comment">//每次移动一个格子后，更新hash</span></span><br><span class="line">Hash[strs[right]]++;</span><br><span class="line"><span class="comment">//更具窗口变更来改变条件</span></span><br><span class="line">If(Hash[strs[right]] = ..)</span><br><span class="line">&#123;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前条件不满足，移动左指针直至条件满足为止 </span></span><br><span class="line"><span class="keyword">while</span> (count &gt; ..) </span><br><span class="line">&#123; </span><br><span class="line">  …</span><br><span class="line">   <span class="keyword">if</span> (…)</span><br><span class="line">  &#123; </span><br><span class="line">​     count—; </span><br><span class="line">   &#125; </span><br><span class="line">   hash[A[l]]++;</span><br><span class="line">​    left++; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//条件根据具体题目要求确定返回结果</span></span><br><span class="line">res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典例题">经典例题</h4><p>leetcode 3 Longest Substring Without Repeating Characters<br>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><strong>Example 3:</strong><br><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is “wke”, with the length of 3.<br>​       Note that the answer must be a <strong>substring</strong>, “pwke” is a <em>subsequence</em> and not a substring.<br>题目很通俗易懂，给一个字符串，让我找到一个最长子字符串，要求其不包含重复元素。<br>解题思路：第一次看到这个题我们，会很快想到brute force解法，两个for循环遍历字符串，外层循环代表其实位置，内层循环代表终止位置，写一个函数判断字符串是否含有重复元素。为了对比出sliding window优势，我也写了此方法做对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = s.length(); </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (allUnique(s, i, j))</span><br><span class="line">ans = Math.max(ans, j - i); </span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">Character ch = s.charAt(i); </span><br><span class="line"><span class="keyword">if</span> (set.contains(ch))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">set.add(ch); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法时间复杂度为O(n^3) 三次遍历<br>但是如果我们要使用sliding window来解决此问题。我们不需要用n^2的时间复杂度去遍历字符串，假如我们已经验证从i - j不存在重复字符，那么我们可以把慢指针指向j，而不需要再从新遍历 i - j。然后通过对比result与快慢指针中间字符串的长度来得到最后结果。<br>以下，为代码示例，通常情况下提到检验重复，我们大多数会用到set。所以，我先写了一个set的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> n = s.length(); </span><br><span class="line">​    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">​    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">​    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">​      <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">​      <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">​        set.add(s.charAt(j++)); </span><br><span class="line">​        ans = Math.max(ans, j - i); </span><br><span class="line">​      &#125;</span><br><span class="line">​      <span class="keyword">else</span> &#123;</span><br><span class="line">​        set.remove(s.charAt(i++)); </span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此解法可以，但是其最坏时间复杂度为2n，就是快慢指针分别都把字符串从头到尾访问一遍。类似于“aabbcc”<br>以下，为通用的sliding window 解法，我们可以引入hashmap，key代表访问字符，value代表字符出现次数。当hashmap中某一个key的值大于1，于是我们尝试移动慢指针，在map中, 把慢指针指向的值的频率减1。在这里有个小技巧，我们可以用一个128长度的int数组来表示，ASCII table 65-92 对应 a-z， 97 - 122 对应A - Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">hash[c[i]]++; </span><br><span class="line"><span class="keyword">while</span> (hash[c[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">hash[c[left]]--; </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">map.put(c[i], map.getOrDefault(c[i], <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (map.get(c[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">map.put(c[left], map.get(c[left]) - <span class="number">1</span>); </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>之后我会陆续在写两篇关于sliding window的文章，列出所有我见过的有意思并且具有代表性的题，归类讲解。当然我不是大神，所以如果文章或者算法上哪里有问题还请各位轻喷多指点！！！<br>示例代码为了便于大家理解，我都写的java，当然我会把c++和python版本的代码放到我的github上。算法题主要是思路，所以语言上基本都是互通，如果大家有需要与其他的语言，Csharp, javascript…私信我，非常乐意把大家debug。</p><p>放上我自己的github：<a href="https://github.com/wuhewuhe/AlgorithmeSource" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
