<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>entry reflect</title>
      <link href="/2020/02/16/entry-reflect/"/>
      <url>/2020/02/16/entry-reflect/</url>
      
        <content type="html"><![CDATA[<p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。上图是java的内存模型，我们关注的点，一个方法区，一个栈，一个堆，初学的时候老师不深入的话只告诉你java的内存分为堆和栈，易懂点吧！</p><p>假如你写了一段代码：Object o=new Object();</p><p>运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p><p>题主想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求哦要用到某个类，哎呀但没加载进jvm，是不是要停下来自己写段代码，new一下，哦启动一下服务器，（脑残）！</p><p>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻，举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！举多个例子，大家如果接触过spring，会发现当你配置各种各样的bean时，是以配置文件的形式配置的，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Method area</title>
      <link href="/2020/02/16/mthod-area/"/>
      <url>/2020/02/16/mthod-area/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java是基于一门虚拟机的语言，所以了解并且熟知虚拟机运行原理非常重要。</p></blockquote><h2 id="方法区">方法区</h2><p>方法区，Method Area， 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p><p>主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><blockquote><p>注意：JDK 6 时，String等字符串常量的信息是置于方法区中的，但是到了JDK 7 时，已经移动到了Java堆。所以，方法区也好，Java堆也罢，到底详细的保存了什么，其实没有具体定论，要结合不同的JVM版本来分析。</p></blockquote><blockquote><h3 id="异常">异常</h3><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。<br>运行时常量池溢出：比如一直往常量池加入数据，就会引起OutOfMemoryError异常。</p></blockquote><h3 id="类信息">类信息</h3><blockquote><ol><li>类型全限定名。</li><li>类型的直接超类的全限定名（除非这个类型是java.lang. Object，它没有超类）。</li><li>类型是类类型还是接口类型。</li><li>类型的访问修饰符（public、abstract或final的某个子集）。</li><li>任何直接超接口的全限定名的有序列表。</li><li>类型的常量池。</li><li>字段信息。</li><li>方法信息。</li><li>除了常量意外的所有类（静态）变量。</li><li>一个到类ClassLoader的引用。</li><li>一个到Class类的引用。</li></ol></blockquote><h2 id="1-常量池">1 常量池</h2><h3 id="1-1-Class文件中的常量池">1.1 Class文件中的常量池</h3><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h3 id="1-2-运行时常量池">1.2 运行时常量池</h3><p>CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h3 id="1-3-常量池的好处">1.3 常量池的好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><blockquote><p>双等号==的含义</p><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul></blockquote><h3 id="1-4-基本类型的包装类和常量池">1.4 基本类型的包装类和常量池</h3><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte, Short, Integer, Long, Character, Boolean。</p><p>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float, Double并没有实现常量池技术。</p><h4 id="Integer与常量池">Integer与常量池</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));  </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="解释：">解释：</h4><ul><li>(1)Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40); ，从而使用常量池中的对象。</li><li>(2)Integer i1 = new Integer(40); 这种情况下会创建新的对象。</li><li>(3)语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。</li></ul><h4 id="String与常量池">String与常量池</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str1 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str1 = <span class="string">"str"</span>;</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;</span><br><span class="line"><span class="built_in">String</span> str4 = str1 + str2;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">String</span> str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="解释：-2">解释：</h4><ul><li><p>(1)new String(“abcd”)是在常量池中拿对象，&quot;abcd&quot;是直接在堆内存空间创建一个新的对象。只要使用new方法，便需要创建新的对象。</p></li><li><p>(2)连接表达式 +</p><p>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。<br>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final String A; &#x2F;&#x2F; 常量A</span><br><span class="line">public static final String B;    &#x2F;&#x2F; 常量B</span><br><span class="line">static &#123;  </span><br><span class="line">   A &#x3D; &quot;ab&quot;;  </span><br><span class="line">   B &#x3D; &quot;cd&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">&#x2F;&#x2F; 将两个常量用+连接对s进行初始化  </span><br><span class="line">String s &#x3D; A + B;  </span><br><span class="line">String t &#x3D; &quot;abcd&quot;;  </span><br><span class="line">if (s &#x3D;&#x3D; t) &#123;  </span><br><span class="line">    System.out.println(&quot;s等于t，它们是同一个对象&quot;);  </span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-3">解释：</h4><p>s不等于t，它们不是同一个对象。</p><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xyz"</span>); <span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure><h4 id="解释：-4">解释：</h4><p>考虑类加载阶段和实际执行时。</p><ul><li>（1）类加载对一个类只会进行一次。”xyz”在类加载时就已经创建并驻留了（如果该类被加载之前已经有”xyz”字符串被驻留过则不需要重复创建用于驻留的”xyz”实例）。驻留的字符串是放在全局共享的字符串常量池中的。</li><li>（2）在这段代码后续被运行的时候，”xyz”字面量对应的String实例已经固定了，不会再被重复创建。所以这段代码将常量池中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s1 持有。</li></ul><p>这条语句创建了2个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String s1 &#x3D; new String(&quot;计算机&quot;);</span><br><span class="line">String s2 &#x3D; s1.intern();</span><br><span class="line">String s3 &#x3D; &quot;计算机&quot;;</span><br><span class="line">System.out.println(&quot;s1 &#x3D;&#x3D; s2? &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">System.out.println(&quot;s3 &#x3D;&#x3D; s2? &quot; + (s3 &#x3D;&#x3D; s2));</span><br><span class="line">&#125;</span><br><span class="line">s1 &#x3D;&#x3D; s2? false</span><br><span class="line">s3 &#x3D;&#x3D; s2? true</span><br></pre></td></tr></table></figure><h4 id="解释：-5">解释：</h4><p>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串, 如果有则返回该字符串的引用, 如果没有则添加自己的字符串进入常量池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line"> String hello = <span class="string">"Hello"</span>, lo = <span class="string">"lo"</span>;</span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == <span class="string">"Hello"</span>) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((other.Other.hello == hello) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+<span class="string">"lo"</span>)) + <span class="string">" "</span>); <span class="comment">//true</span></span><br><span class="line"> System.<span class="keyword">out</span>.println((hello == (<span class="string">"Hel"</span>+lo)) + <span class="string">" "</span>); <span class="comment">//false</span></span><br><span class="line"> System.<span class="keyword">out</span>.println(hello == (<span class="string">"Hel"</span>+lo).intern()); <span class="comment">//true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">package other;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Other</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-6">解释：</h4><p>在同包同类下, 引用自同一String对象.</p><p>在同包不同类下, 引用自同一String对象.</p><p>在不同包不同类下, 依然引用自同一String对象.</p><p>在编译成.class时能够识别为同一字符串的, 自动优化成常量, 引用自同一String对象.</p><p>在运行时创建的字符串具有独立的内存地址, 所以不引用自同一String对象.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> method area </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reflect</title>
      <link href="/2020/02/16/reflect/"/>
      <url>/2020/02/16/reflect/</url>
      
        <content type="html"><![CDATA[<p>反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。</p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple &#x3D; new Apple(); &#x2F;&#x2F;直接初始化，「正射」</span><br><span class="line">apple.setPrice(4);</span><br></pre></td></tr></table></figure><p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p><p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p><p>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);</span><br><span class="line">Method method &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Object object &#x3D; constructor.newInstance();</span><br><span class="line">method.invoke(object, 4);</span><br></pre></td></tr></table></figure><p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect. Apple）。</p><p>所以说什么是反射？</p><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p><h2 id="一个简单的例子">一个简单的例子</h2><p>上面提到的示例程序，其完整的程序代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Apple &#123;</span><br><span class="line"></span><br><span class="line">    private int price;</span><br><span class="line"></span><br><span class="line">    public int getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(int price) &#123;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;正常的调用</span><br><span class="line">        Apple apple &#x3D; new Apple();</span><br><span class="line">        apple.setPrice(5);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + apple.getPrice());</span><br><span class="line">        &#x2F;&#x2F;使用反射调用</span><br><span class="line">        Class clz &#x3D; Class.forName(&quot;com.chenshuyi.api.Apple&quot;);</span><br><span class="line">        Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br><span class="line">        Constructor appleConstructor &#x3D; clz.getConstructor();</span><br><span class="line">        Object appleObj &#x3D; appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, 14);</span><br><span class="line">        Method getPriceMethod &#x3D; clz.getMethod(&quot;getPrice&quot;);</span><br><span class="line">        System.out.println(&quot;Apple Price:&quot; + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple Price:5</span><br><span class="line">Apple Price:14</span><br></pre></td></tr></table></figure><p>从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</p><ul><li>获取类的 Class 对象实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;com.zhenai.api.Apple&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据 Class 对象实例获取 Constructor 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor &#x3D; clz.getConstructor();</span><br></pre></td></tr></table></figure><ul><li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj &#x3D; appleConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>而如果要调用某一个方法，则需要经过下面的步骤：</p><ul><li>获取方法的 Method 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod &#x3D; clz.getMethod(&quot;setPrice&quot;, int.class);</span><br></pre></td></tr></table></figure><ul><li>利用 invoke 方法调用方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, 14);</span><br></pre></td></tr></table></figure><p>到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。</p><p>在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p><h2 id="反射常用API">反射常用API</h2><h3 id="获取反射中的Class对象">获取反射中的Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><p>**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure><p><strong>第二种，使用 .class 方法。</strong></p><p>这种方法只适合在编译前就知道操作的 Class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; String.class;</span><br></pre></td></tr></table></figure><p><strong>第三种，使用类对象的 getClass() 方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">Class clz &#x3D; str.getClass();</span><br></pre></td></tr></table></figure><h3 id="通过反射创建类对象">通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p>第一种：通过 Class 对象的 newInstance() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Apple apple &#x3D; (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure><p>第二种：通过 Constructor 对象的 newInstance() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor();</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Constructor constructor &#x3D; clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple &#x3D; (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure><h3 id="通过反射获取类属性、方法、构造器">通过反射获取类属性、方法、构造器</h3><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz &#x3D; Apple.class;</span><br><span class="line">Field[] fields &#x3D; clz.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="img"></p><p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Delegate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
            <tag> invoke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composite and aggrevgation</title>
      <link href="/2020/02/16/composite-and-aggrevgation/"/>
      <url>/2020/02/16/composite-and-aggrevgation/</url>
      
        <content type="html"><![CDATA[<ul><li>inheritance and delegate</li></ul><p>both of them are the reuse technique in java, and they are importance design in our daily coding, inheritance is represented by Lioskv, his operations and attributes are inherite by subclass from parent class in the context, which is called super class.</p><p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p><p>Delegation can be an alternative to inheritance.<br>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.<br>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.<br>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</p><ul><li>difference between delegate and inheritance?</li></ul><p>inheitance vise to class, bur delegate vise to object</p><ul><li>Why use delegate?</li></ul><p>it can be an alternative way of inheritance, but the primary advantage of delegate is that it’s flexible and change in run time, it doesn’t force you to accept all method of a super class, you just provide some mthod make you sense</p><ul><li>When to use inheritance?</li></ul><p>You want to express relationship (is-a) then you want to use Inheritance.</p><p>You want to be able to pass your class to an existing API expecting A’s then you need to use inheritance.</p><ul><li>when to use delegate?</li></ul><p>You want to enhance A, but A is final and can no further be sub-classed then you need to use <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/" target="_blank" rel="noopener">composition</a> and delegation.</p><p>In this example, there is an Institute which has no. of departments like CSE, EE. Every department has no. of students. So, we make a Institute class which has a reference to Object or no. of Objects (i.e. List of Objects) of the Department class. That means Institute class is associated with Department class through its Object(s). And Department class has also a reference to Object or Objects (i.e. List of Objects) of Student class means it is associated with Student class through its Object(s).<br>It represents a <strong>Has-A</strong> relationship.<br><a href="https://www.geeksforgeeks.org/media.geeksforgeeks.org/wp-content/uploads/Reference.png" target="_blank" rel="noopener"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Reference.png" alt="Aggregation_1"></a></p><p>Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.</p><ul><li>It represents <strong>part-of</strong> relationship.</li><li>In composition, both the entities are dependent on each other.</li><li>When there is a composition between two entities, the composed object <strong>cannot exist</strong> without the other entity.</li></ul><p>In above example a library can have no. of <strong>books</strong> on same or different subjects. So, If Library gets destroyed then All books within that particular library will be destroyed. i.e. book can not exist without library. That’s why it is composition.</p><p><strong>Aggregation vs Composition</strong></p><ol><li><strong>Dependency:</strong> Aggregation implies a relationship where the child <strong>can exist independently</strong> of the parent. For example, Bank and Employee, delete the Bank and the Employee still exist. whereas Composition implies a relationship where the child <strong>cannot exist independent</strong> of the parent. Example: Human and heart, heart don’t exist separate to a Human</li><li><strong>Type of Relationship:</strong> Aggregation relation is <strong>“has-a”</strong> and composition is <strong>“part-of”</strong> relation.</li><li><strong>Type of association:</strong> Composition is a <strong>strong</strong> Association whereas Aggregation is a <strong>weak</strong> Association.</li></ol><p>In case of aggregation, the Car also performs its functions through an Engine. but the Engine is not always an internal part of the Car. An engine can be swapped out or even can be removed from the car. That’ why we make The Engine type field non-final.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deglate </tag>
            
            <tag> inheritance </tag>
            
            <tag> comoposite </tag>
            
            <tag> aggrevgation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID Object Orient Programming pinciples</title>
      <link href="/2020/02/15/solid/"/>
      <url>/2020/02/15/solid/</url>
      
        <content type="html"><![CDATA[<p>this is 5 pinciple of object-oriented programming</p><p>In object-oriented computer programming, <strong>SOLID</strong> is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.</p><ul><li>s = single respoonsibilty principle</li></ul><p>a class should have a single responsibility, one part of software’s specification should be able to affect the specification of class</p><ul><li>open close principle</li></ul><p>Software class should be opened for extension but closed for modifications</p><ul><li>Liskov</li></ul><p>Object in a program should be replaced with instance of their subtype without correctness of that program</p><ul><li>interface segergation</li></ul><p>many client specific interface are better than one general purpose interface</p><ul><li>dependency inversion</li></ul><p>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p><h4 id="single-responsibility">single responsibility</h4><p>A class should have one and only one reason to change, meaning that a class should have only one job.</p><p><strong>example</strong></p><p>First, we create our shapes classes and have the constructors setup the required parameters. Next, we move on by creating the <strong>AreaCalculator</strong> class and then write up our logic to sum up the areas of all provided shapes.</p><p>To use the <strong>AreaCalculator</strong> class, we simply instantiate the class and pass in an array of shapes, and display the output at the bottom of the page.</p><p>All of that logic would be handled by the <strong>AreaCalculator</strong> class, this is what SRP frowns against; the <strong>AreaCalculator</strong> class should only sum the areas of provided shapes, it should not care whether the user wants json or HTML.</p><p>Now, whatever logic you need to output the data to the user is now handled by the <strong>SumCalculatorOutputter</strong> class.</p><h4 id="open-closed-principle">open-closed principle</h4><p>This simply means that a class should be easily extendable without modifying the class itself. Let’s take a look at the <strong>AreaCalculator</strong> class, especially it’s <strong>sum</strong> method.</p><p>If we wanted the <strong>sum</strong> method to be able to sum the areas of more shapes, we would have to add more <strong>if/else blocks</strong> and that goes against the Open-closed principle.</p><p>A way we can make this <strong>sum</strong> method better is to remove the logic to calculate the area of each shape out of the sum method and attach it to the shape’s class.</p><p>The same thing should be done for the <strong>Circle</strong> class, an <strong>area</strong> method should be added. Now, to calculate the sum of any shape provided should be as simple as:</p><p>Now we can create another shape class and pass it in when calculating the sum without breaking our code. However, now another problem arises, how do we know that the object passed into the <strong>AreaCalculator</strong> is actually a shape or if the shape has a method named <strong>area</strong>?</p><p>Coding to an interface is an integral part of <strong>S. O. L. I. D</strong>, a quick example is we create an interface, that every shape implements:</p><p>In our <strong>AreaCalculator</strong> sum method we can check if the shapes provided are actually instances of the <strong>ShapeInterface</strong>, otherwise we throw an exception:</p><h4 id="Liskoc-substitution-principle">Liskoc substitution principle</h4><p>Next up on our list is Liskov substitution, which is arguably the most complex of the 5 principles. Simply put, <strong>if class *A* is a subtype of class *B*, then we should be able to replace *B* with *A* without disrupting the behavior of our program.</strong></p><h4 id="interface-segregation">interface segregation</h4><p><strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>Still using our shapes example, we know that we also have solid shapes, so since we would also want to calculate the volume of the shape, we can add another contract to the <strong>ShapeInterface</strong>:</p><p>Any shape we create must implement the <strong>volume</strong> method, but we know that squares are flat shapes and that they do not have volumes, so this interface would force the <strong>Square</strong> class to implement a method that it has no use of.</p><p><strong>ISP</strong> says no to this, instead you could create another interface called <strong>SolidShapeInterface</strong> that has the <strong>volume</strong> contract and solid shapes like cubes e.t.c can implement this interface:</p><p>This is a much better approach, but a pitfall to watch out for is when type-hinting these interfaces, instead of using a <strong>ShapeInterface</strong> or a <strong>SolidShapeInterface</strong>.</p><p>You can create another interface, maybe <strong>ManageShapeInterface</strong>, and implement it on both the flat and solid shapes, this way you can easily see that it has a single API for managing the shapes. For example:</p><p>Now in <strong>AreaCalculator</strong> class, we can easily replace the call to the <strong>area</strong> method with <strong>calculate</strong> and also check if the object is an instance of the <strong>ManageShapeInterface</strong> and not the <strong>ShapeInterface</strong>.</p><h4 id="dependecy-inversion">dependecy inversion</h4><p><strong>The principle of Dependency Inversion refers to the decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.</strong></p><p>this principle realise the open-close displicine, which means that we don’t need to concentrate which is the shape type exactly, because each shape has his own area and we can call it by the abstraction class.</p><p><strong>in the last, you can find my code in attchement</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square s &#x3D; new Square(&quot;square&quot;, 1);</span><br><span class="line">Circle c &#x3D; new Circle(&quot;circle&quot;, 1);</span><br><span class="line">Shapes[] ss &#x3D; &#123; s, c &#125;;</span><br><span class="line">CalculatorArea ca &#x3D; new CalculatorArea(ss);</span><br><span class="line">System.out.println(ca.sumShapes());</span><br><span class="line">FormatOutputter fo &#x3D; new FormatOutputter(formatter.HTML, ca);</span><br><span class="line">fo.transfer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class CalculatorArea &#123;</span><br><span class="line">private Shapes[] shapes;</span><br><span class="line"></span><br><span class="line">public CalculatorArea(Shapes[] shapes) &#123;</span><br><span class="line">this.shapes &#x3D; shapes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sumShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.area();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int volumeShapes() &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">if (shapes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (Shapes shape : shapes) &#123;</span><br><span class="line">sum +&#x3D; shape.volume();</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shapes &#123;</span><br><span class="line">private int radius;</span><br><span class="line"></span><br><span class="line">public Circle(String name, int radius) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getRadius() &#123;</span><br><span class="line">return radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setRadius(int radius) &#123;</span><br><span class="line">this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return (int) (Math.PI * radius * radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) (Math.PI * radius * 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class FormatOutputter &#123;</span><br><span class="line">private CalculatorArea ca;</span><br><span class="line">private formatter format;</span><br><span class="line"></span><br><span class="line">public FormatOutputter(formatter format, CalculatorArea ca) &#123;</span><br><span class="line">this.format &#x3D; format;</span><br><span class="line">this.ca &#x3D; ca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer() &#123;</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case JSON:</span><br><span class="line">System.out.println(&quot;json transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case HTML:</span><br><span class="line">System.out.println(&quot;html transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case TXT:</span><br><span class="line">System.out.println(&quot;txt transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">case XML:</span><br><span class="line">System.out.println(&quot;xml transfer &quot; + ca.sumShapes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public enum formatter &#123;</span><br><span class="line">XML, JSON, TXT, HTML;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeInterface &#123;</span><br><span class="line">int area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public abstract class Shapes implements ShapeInterface, ShapeVolumInterface &#123;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Shapes(String name) &#123;</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public interface ShapeVolumInterface &#123;</span><br><span class="line">int volume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package solid;</span><br><span class="line"></span><br><span class="line">public class Square extends Shapes &#123;</span><br><span class="line">private int length;</span><br><span class="line"></span><br><span class="line">public Square(String name, int length) &#123;</span><br><span class="line">super(name);</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLength() &#123;</span><br><span class="line">return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLength(int length) &#123;</span><br><span class="line">this.length &#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int area() &#123;</span><br><span class="line">return length * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int volume() &#123;</span><br><span class="line">return (int) Math.pow(length, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solid </tag>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装*必备的linux命令</title>
      <link href="/2020/02/12/linux-command/"/>
      <url>/2020/02/12/linux-command/</url>
      
        <content type="html"><![CDATA[<p>当别人还在鼠标点击的时候，身为geek的你默默打开terminal然后开始你的表演</p><h4 id="常规操作-小试牛刀">常规操作 小试牛刀</h4><p><strong>ls: 类似于dos下的dir命令</strong></p><p>ls最常用的参数有三个： -a -l -F。</p><p>ls –a</p><p>Linux上的文件以. 开头的文件被系统视为隐藏文件，仅用ls命令是看不到他们的，而用ls -a除了显示一般文件名外，连隐藏文件也会显示出来。</p><p>ls –l</p><p>该参数显示更详细的文件信息。</p><p>ls –F</p><p>使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。但是现在基本上所有的Linux发行版本的ls都已经内建了-F参数，也就是说，不用输入这个参数，我们也能看到各种分辨符号。</p><p><strong>cd: 用于切换用户当前工作目录</strong></p><p>cd aaa 进入aaa目录</p><p>cd 命令后不指定目录，会切换到当前用户的home 目录</p><p>cd ~ 作用同cd后不指定目录，切换到当前用户的home 目录</p><p>cd - 命令后跟一个减号，则会退回到切换前的目录</p><p>cd … 返回到当前目录下的上一级目录</p><p><strong>pwd：用于显示用户当前工作目录</strong></p><p><strong>mkdir 和 rmdir</strong></p><p>midir: 创建目录 rmdir: 删除目录</p><p>两个命令都支持-p参数，对于mkdir命令若指定路径的父目录不存在则一并创建，对于rmdir命令则删除指定路径的所有层次目录，如果文件夹里有内容，则不能用rmdir命令</p><p>如下：</p><p>mkdir -p 1/2/3</p><p>rmdir -p 1/2/3</p><p><strong>tar 打包压缩与解压缩</strong></p><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（<a href="http://man.linuxde.net/gzip" target="_blank" rel="noopener">gzip</a> <a href="http://man.linuxde.net/bzip2" target="_blank" rel="noopener">bzip2</a>命令）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file&#x3D;&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br></pre></td></tr></table></figure><p><strong>将文件全部打包成tar包</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log    仅打包，不压缩！ </span><br><span class="line">tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 </span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩</span><br></pre></td></tr></table></figure><p>在选项 <code>f</code> 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 <code>z</code> 选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加 <code>j</code> 选项，则以.tar.bz2来作为tar包名。</p><p><strong>查阅上述tar包内有哪些文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上 <code>z</code> 这个选项了。</p><p><strong>将tar包解压缩</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &#x2F;opt&#x2F;soft&#x2F;test&#x2F;log.tar.gz</span><br></pre></td></tr></table></figure><h4 id="文件操作-装-的核心操作">文件操作 装*的核心操作</h4><p><strong>touch</strong></p><p>inux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>使用指令&quot;touch&quot;修改文件&quot;testfile&quot;的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure><p>执行指令&quot;touch&quot;修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line">$ ls -l testfile                #查看文件的时间属性  </span><br><span class="line">#修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure><p>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件&quot;file&quot;，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure><p><strong>cp：复制命令</strong></p><p>复制一个文件到另一目录：cp 1.txt …/test2</p><p>复制一个文件到本目录并改名：cp 1.txt 2.txt</p><p>复制一个文件夹a并改名为b：cp -r a b</p><p><strong>mv：移动命令</strong></p><p>将一个文件移动到另一个目录：mv 1.txt …/test1</p><p>将一个文件在本目录改名：mv 1.txt 2.txt</p><p>将一个文件一定到另一个目录并改名：mv 1.txt …/test1/2.txt</p><p><strong>rm命令</strong></p><p>rm命令用于删除文件，与dos下的del/erase命令相似，rm命令常用的参数有三个：-i，-r，-f。</p><p>–i ：系统在删除文件之前会先询问确认，用户回车之后，文件才会真的被删除。需要注意，linux下删除的文件是不能恢复的，删除之前一定要谨慎确认。</p><p>–r：该参数支持目录删除，功能和rmdir命令相似。</p><p>–f：和-i参数相反，-f表示强制删除</p><p><strong>cat命令</strong></p><p>cat命令的功能是显示或连结一般的ascii文本文件。cat是concatenate的简写，类似于dos下面的type命令。用法如下：</p><p>cat file1 显示file1文件内容</p><p>cat file1 file2 依次显示file1, file2的内容</p><p>cat file1 file2 &gt; file3 把file1, file2的内容结合起来，再“重定向（&gt;）”到file3文件中。</p><p>&quot;&gt;“是右重定向符，表示将左边命令结果当成右边命令的输入，注意：如果右侧文件是一个已存在文件，其原有内容将会被清空，而变成左侧命令输出内容。如果希望以追加方式写入，请改用”&gt;&gt;&quot;重定向符。</p><p>如果&quot;&gt;&quot;左边没有指定文件，如： cat &gt;file1，将会等用户输入，输入完毕后再按[Ctrl]+[c]或[Ctrl]+[d]，就会将用户的输入内容写入file1。</p><p><strong>echo命令</strong></p><p>echo命令的使用频率不少于ls和cat，尤其是在shell脚本编写中。</p><p>语法：echo [-ne][字符串]</p><p>功能：echo会将输入的字符串送往标准输出，输出的字符串间以空白字符隔开， 并在最后加上换行符。</p><p>参数：</p><p>-n 显示字串时在最后自动换行</p><p>-e 支持以下格式的转义字符， -E 不支持以下格式的转义字符</p><p>/a 发出警告声；</p><p>/b 删除前一个字符；</p><p>/c 最后不加上换行符号；</p><p>/f 换行但光标仍旧停留在原来的位置；</p><p>/n 换行且光标移至行首；</p><p>/r 光标移至行首，但不换行；</p><p>/t 插入tab；</p><p>/v 与/f相同；</p><p>// 插入/字符；</p><p><strong>more，less，clear</strong></p><p>n more，less命令</p><p>这两个命令用于查看文件，如果一个文件太长，显示内容超出一个屏幕，用cat命令只能看到最后的内容，用more和less两个命令可以分页查看。more指令可以使超过一页的文件内容分页暂停显示，用户按键后才继续显示下一页。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，更方便浏览阅读。</p><p>less的常用动作命令：</p><p>回车键 向下移动一行；</p><p>y 向上移动一行；</p><p>空格键 向下滚动一屏；</p><p>b 向上滚动一屏；</p><p>d 向下滚动半屏；</p><p>h less的帮助；</p><p>u 向上洋动半屏；</p><p>w 可以指定显示哪行开始显示，是从指定数字的下一行显示；比如指定的是6，那就从第7行显示；</p><p>g 跳到第一行；</p><p>G 跳到最后一行；</p><p>p n% 跳到n%，比如 10%，也就是说比整个文件内容的10%处开始显示；</p><p>/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词；</p><p>v 调用vi编辑器；</p><p>q 退出less</p><p>!command 调用SHELL，可以运行命令；比如!ls 显示当前列当前目录下的所有文件；</p><p>n clear命令</p><p>clear命令是用来清除当前屏幕显示的，不需任何参数，和dos下的cls命令功能相同。</p><h4 id="读写操作-装-境界更上一层楼">读写操作 装*境界更上一层楼</h4><p><strong>vim 高级文本编辑器</strong></p><p>Vim 经常被认为是 “程序员的编辑器”, 它在程序编写时非常有用，很多人认为它是一个完整的集成开发环境(IDE)。仅管如此，Vim并不只是程序员使用的。Vim可以用于多种文档编辑，从email排版到配置文件编写。</p><p><strong>编辑模式</strong>（Normal）：执行命令，也称为正常模式<br>**插入模式 **（Insert）：输入文本<br><strong>命令模式</strong>：执行 <strong>冒号</strong> 命令</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>按下键 i ，进入 <em>Insert</em> 模式（ 这时候，你可以输入文本）</li><li>按 ESC键，就可退回到<em>Normal</em> 模式下</li></ul><p>在Normal下基本命令操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">Insert</span> 模式，按 <span class="selector-tag">ESC</span>回到 <span class="selector-tag">Normal</span>模式。 <span class="selector-tag">x</span> 删当前光标所在的一个字符。<span class="selector-pseudo">:wq</span> 存盘+退出 (<span class="selector-pseudo">:w</span>存盘, <span class="selector-pseudo">:q</span>退出) （注<span class="selector-pseudo">:w</span> 后可以跟文件名）<span class="selector-pseudo">:q</span> ! 不保存退出 <span class="selector-tag">Shift</span>+<span class="selector-tag">ZZ</span> 退出本文档 <span class="selector-tag">dd</span> 删除当前行，并把删除的行存到剪贴板里 <span class="selector-tag">p</span> 粘贴剪贴板<span class="selector-pseudo">:help</span> 显示相关命令的帮助（<span class="selector-pseudo">:q</span> 退出帮助） 移动光标 <span class="selector-tag">hjkl</span> (←↓↑→)</span><br></pre></td></tr></table></figure><p>简单的光标移动命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       当前行第一列</span><br><span class="line">w       移到下一个单词</span><br><span class="line">^       移动到第一个非空白字符</span><br><span class="line">$       移动到最后一列</span><br><span class="line">g       移动到最后一个非空白字符</span><br><span class="line">%       匹配括号移动，包括 (, &#123;, [。 （把光标先移到括号上）</span><br><span class="line"></span><br><span class="line">*       移动光标到上一个匹配的单词</span><br><span class="line"></span><br><span class="line"><span class="comment">#       移动光标到下一个匹配的单词</span></span><br><span class="line">/pattern搜索   pattern的字符串（如果搜索出多个匹配，可按n键到下一个）</span><br></pre></td></tr></table></figure><p><strong>wc命令</strong></p><p>该命令用于统计指定文件中的字节数、字数、行数。该命令各选项含义如下：</p><p>-l 统计行数</p><p>-w 统计字数</p><p>-c 统计字节数</p><p>这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。</p><p>行数、字数、字节数、文件名</p><p>如果命令行中没有文件名，则输出中不出现文件名。</p><p><strong>grep 命令</strong></p><p>grep是（global search regular expression(RE) and print out the line的缩写，用于从文件面搜索包含指定模式的行并打印出来，它是一种强大的文本搜索工具，支持使用正则表达式搜索文本。grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被””引用，模板后的所有字符串被看作文件名。搜索结果送到屏幕，不影响原文件内容。</p><p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>示例：</p><p>$ ls -l | grep ‘^a’</p><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><p>$ grep ‘test’ d*</p><p>显示所有以d开头的文件中包含test的行。</p><p>$ grep ‘test’ aa bb cc</p><p>显示在aa，bb，cc文件中匹配test的行。</p><p>$ grep ‘[a-z]/{5/}’ aa</p><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><p>$ grep ‘w/(es/)t.*/1’ aa</p><p>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符（.<em>），这些字符后面紧跟着另外一个es（/1），找到就显示该行。如果用egrep或grep -E，就不用&quot;/&quot;号进行转义，直接写成’w(es)t.</em>/1’就可以了。</p><h4 id="进程操作-比肩程序员">进程操作 比肩程序员</h4><p><strong>nohup 挂起操作</strong></p><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。</p><p>nohup command 或者 nohup command &amp;</p><p>这之间的差别是带&amp;的命令行，即使terminal（终端）关闭，或者电脑死机程序依然运行（前提是你把程序递交到服务器上）；</p><p><strong>tip: crl + z 可以切换当前进程到后台运行</strong></p><p><strong>ps 进程</strong></p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><ul><li>ps工具标识进程的5种状态码:</li></ul><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><ul><li>命令参数</li></ul><p>a 显示所有进程</p><p>-a 显示同一终端下的所有程序</p><p>-A 显示所有进程</p><p>c 显示进程的真实名称</p><p>-au 显示较详细的资讯</p><p>-aux 显示所有包含其他使用者的行程</p><ul><li>各相关信息的意义：</li></ul><p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p><p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p><p>UID 程序被该 UID 所拥有</p><p>PID 就是这个程序的 ID ！</p><p>PPID 则是其上级父程序的ID</p><p>C CPU 使用的资源百分比</p><p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p><p>SZ 使用掉的内存大小</p><p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p><p>TTY 登入者的终端机位置</p><p>TIME 使用掉的 CPU 时间。</p><p>CMD 所下达的指令为何</p><p>在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID</p><p><strong>kill</strong></p><p>Linux kill命令用于删除执行中的程序或工作。</p><p>彻底杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 123456(pid)</span><br></pre></td></tr></table></figure><p><strong>head，tail</strong></p><p>n head和tail命令 看log找错误改bug</p><p>都用于查看文本文件，区别在于： head显示文件的头n行，tail显示文件的尾n行，缺省情况n都为10行。可以通过-n方式指定行数，如：</p><p>head -100 file和tail -100 file分别表示显示文件头100行和尾100行内容。</p><p>n tail -f命令</p><p>可以实时查看文件新增内容。</p><h4 id="系统权限与磁盘管理操作-运维聊一聊">系统权限与磁盘管理操作 运维聊一聊</h4><p><strong>df disk free查看分区大小和占用情况</strong></p><p>-l 仅显示本地磁盘(默认）</p><p>-a 显示所有文件系统的磁盘使用情况，包含比如/proc/（查看包括0字节文件）</p><p>-h 以1024进制计算最合适的单位显示磁盘容量</p><p>-H 以1000进制计算最合适的单位显示磁盘容量</p><p>-T 显示磁盘分区类型（各个分区使用的文件系统）</p><p><strong>du disk usage统计磁盘上的文件大小</strong></p><p>-b 以byte为单位统计文件</p><p>-k 以KB为单位统计文件</p><p>-m 以MB为单位统计文件</p><p>-h 以1024进制计算最合适的单位统计文件</p><p>-H 以1000进制计算最合适的单位统计文件</p><p>-s 指定统计目标<br>第一 主分区和扩展分区总数不能超过4个<br>第二 扩展分区最多只能有一个<br>第三 扩展分区不能直接存取数据</p><p><strong>磁盘分区 fdisk</strong></p><ul><li>硬盘分区工具 &quot;fdisk&quot;命令</li></ul><p>使用fdisk分区需要跟一些参数</p><p>分区操作：</p><p>\0.fdisk -l 查看当前系统分区情况</p><p>1.fdisk /dev/sdb 进入分区模式 （fdisk 需要分区的磁盘设备名）</p><ol start="2"><li><p>输入 m 查看命令帮助信息</p></li><li><p>输入 n 添加分区</p></li></ol><p>p：主分区</p><p>e：扩展分区</p><p>l : 逻辑分区</p><p>设置起始和结束</p><p>大小 +数字[k, M, G]</p><p>\4. 输入 p 查看分配逻辑</p><p>\5. 输入 d 删除对应分区逻辑（删除是扩展分区的话，对应的逻辑分区也被删除）</p><p>\6. 输入 w 将分区逻辑实施并退出 fdisk命令</p><p>补充：在fdisk内部操作的分区操作，只是计划，只有当键入 w 时才会进行实际的分区</p><p><strong>chown</strong></p><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h4 id="计算机网络操作-神进化完成">计算机网络操作 *神进化完成</h4><p><strong>netstat 查看网络状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat </span><br><span class="line">    -t  列出TCP协议端口</span><br><span class="line">    -u  列出UDP协议端口</span><br><span class="line">    -n  不适用域名与服务名，而使用IP地址和端口号</span><br><span class="line">    -l  仅列出在监听状态网络服务</span><br><span class="line">    -a  列出所有的网络连接</span><br><span class="line">    -r  列出路由列表，功能和route命令一致</span><br><span class="line">    常用：-tuln –an –rn</span><br></pre></td></tr></table></figure><p><strong>route</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">route</span> –<span class="selector-tag">n</span> 查看路由列表（可以看到网关） <span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">default</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> 临时设定网关</span><br></pre></td></tr></table></figure><p><strong>ifconfig 关闭与启动网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdown 网卡设备名</span><br><span class="line">    禁用该网卡设备</span><br><span class="line">ifup 网卡设备名</span><br><span class="line">    启用该网卡设备</span><br></pre></td></tr></table></figure><p><strong>nslookup 域名解析命令</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nslookup</span> <span class="selector-attr">[主机名或IP]</span> 进行域名与<span class="selector-tag">IP</span>地址解析 <span class="selector-tag">nslookup</span>&gt;<span class="selector-tag">server</span> 查看本机<span class="selector-tag">DNS</span>服务器</span><br></pre></td></tr></table></figure><p><strong>ping 网络测试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ping</span> <span class="selector-attr">[选项]</span> <span class="selector-tag">ip</span>或域名 探测指定<span class="selector-tag">IP</span>或域名的网络状况 <span class="selector-tag">-c</span> 次数：指定<span class="selector-tag">ping</span>报的次数</span><br></pre></td></tr></table></figure><p><strong>SSH 远程连接</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSH命令</span><br><span class="line">    ssh 用户名<span class="meta">@ip</span></span><br><span class="line">        远程管理指定Linux服务器</span><br><span class="line">    scp [-r] 用户名<span class="meta">@ip</span>:文件路径 本地路径</span><br><span class="line">        下载文件到本地</span><br><span class="line">    scp [-r] 本地文件 用户名<span class="meta">@ip</span>:上传路径</span><br><span class="line">        上传文件到远程服务器</span><br></pre></td></tr></table></figure><p><strong>traceroute追踪</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">traceroute</span> <span class="selector-attr">[xuanxiang]</span> <span class="selector-tag">IP</span>或域名 路由跟踪命令 <span class="selector-tag">-n</span> 使用<span class="selector-tag">IP</span>，不使用域名，速度更快</span><br></pre></td></tr></table></figure><h4 id="curl-wget-必杀操作">curl wget 必杀操作</h4><p>当想要直接通过 [Linux] 命令行下载文件，马上就能想到两个工具：wget 和 cURL。它们有很多一样的特征，可以很轻易的完成一些相同的任务，虽然它们有一些相似的特征，但它们并不是完全一样。这两个程序适用与不同的场合，在特定场合下，都拥有各自的特性。</p><p>wget 和 cURL 都可以下载内容。它们的核心就是这么设计的。它们都可以向互联网发送请求并返回请求项。这可以是文件、图片或者是其他诸如网站的原始 HTML 之类。</p><p>这两个程序都可以进行 HTTP POST 请求。这意味着它们都可以向网站发送数据，比如说填充表单什么的。</p><p>由于这两者都是命令行工具，它们都被设计成可脚本化。wget 和 cURL 都可以写进你的 Bash 脚本 ，自动与新内容交互，下载所需内容。</p><p>wget 简单直接。这意味着你能享受它超凡的下载速度。wget 是一个独立的程序，无需额外的资源库，更不会做其范畴之外的事情。</p><p>wget 是专业的直接下载程序，支持递归下载。同时，它也允许你下载网页中或是 FTP 目录中的任何内容。</p><p>wget 拥有智能的默认设置。它规定了很多在常规浏览器里的事物处理方式，比如 cookies 和重定向，这都不需要额外的配置。可以说，wget 简直就是无需说明，开罐即食！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//soft.vpser.net/lnmp/lnmp1.1-full.tar.gz</span></span><br><span class="line">    下载命令</span><br></pre></td></tr></table></figure><p>cURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。</p><p>cURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。</p><p>cURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。</p><p>cURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。</p><p>cURL 同样支持让数据发送变得更容易的 gzip 压缩技术。</p><p>那你应该使用 cURL 还是使用 wget？这个比较得看实际用途。如果你想快速下载并且没有担心参数标识的需求，那你应该使用轻便有效的 wget。如果你想做一些更复杂的使用，直觉告诉你，你应该选择 cRUL。</p><p>cURL 支持你做很多事情。你可以把 cURL 想象成一个精简的命令行网页浏览器。它支持几乎你能想到的所有协议，可以交互访问几乎所有在线内容。唯一和浏览器不同的是，cURL 不会渲染接收到的相应信息。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> file </tag>
            
            <tag> net </tag>
            
            <tag> process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface and class</title>
      <link href="/2020/02/12/interface-and-class/"/>
      <url>/2020/02/12/interface-and-class/</url>
      
        <content type="html"><![CDATA[<p>interface</p><p>contains parameter and method</p><p>method par default is public abstract, we can not concerate but since java 8, default</p><p>parameter par default is public static final</p><p>a interface can extends multi interface, but it should realise all of the parment methods</p><p>abstract class</p><p>abstract class can concentrate method and contains various type : public private static</p><p>abstract class can have static method</p><p>hériter only one class</p><p>1、抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。</p><p>2、当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</p><p>3、当注重代码的扩展性跟可维护性时，应当优先采用接口。①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活; ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interface </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashcode, equals区别与联系</title>
      <link href="/2020/02/12/hashcode-equal/"/>
      <url>/2020/02/12/hashcode-equal/</url>
      
        <content type="html"><![CDATA[<p>有面试官会问：你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。下面我们一起来看一下，它们到底有什么区别，总结一波！</p><p>01、hashCode介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.hashCode());}</code></pre><p>}<br>通过调用hashCode()方法获取对象的hash值。</p><p>02、equals介绍<br>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。</p><p>举个例子</p><p>public class DemoTest {</p><pre><code>public static void main(String[] args) {Object obj = new Object();System.out.println(obj.equals(obj));}</code></pre><p>}<br>03、hashCode() 和 equals() 有什么关系？<br>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我们梳理了一下 “hashCode() 和 equals()的关系”。我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><p>3.1、不会创建“类对应的散列表”<br>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</p><p>equals() 用来比较该类的两个对象是否相等，而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 举个例子</p><p>public class DemoNormalTest {</p><pre><code>public static void main(String[] args) {// 新建2个相同内容的Person对象，// 再用equals比较它们是否相等Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>p1.equals(p3) : false; p1(2018699554) p3(1735600054)<br>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><p>3.2、会创建“类对应的散列表”<br>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, HashTable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的:</p><p>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。<br>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。<br>举个例子</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，    Person p1 = new Person(&quot;eee&quot;, 100);    Person p2 = new Person(&quot;eee&quot;, 100);    Person p3 = new Person(&quot;aaa&quot;, 200);    // 新建HashSet对象     HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();    set.add(p1);    set.add(p2);    set.add(p3);    // 比较p1 和 p2， 并打印它们的hashCode()    System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());     // 打印set    System.out.printf(&quot;set:%s\n&quot;, set); }private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(2018699554) p2(1311053135)<br>set:[(eee, 100), (aaa, 200), (eee, 100)]<br>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>举个例子，我们同时覆盖equals() 和 hashCode()方法。</p><p>public class DemoConflictTest {</p><pre><code>public static void main(String[] args) {// 新建Person对象，Person p1 = new Person(&quot;eee&quot;, 100);Person p2 = new Person(&quot;eee&quot;, 100);Person p3 = new Person(&quot;aaa&quot;, 200);Person p4 = new Person(&quot;EEE&quot;, 100);// 新建HashSet对象HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();set.add(p1);set.add(p2);set.add(p3);set.add(p4);// 比较p1 和 p2， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());// 比较p1 和 p4， 并打印它们的hashCode()System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());// 打印setSystem.out.printf(&quot;set:%s\n&quot;, set);}private static class Person {private String name;private int age;public Person(String name, int age) {super();this.name = name;this.age = age;}/** * 重写toString方法 */@Overridepublic String toString() {return &quot;(&quot; + name + &quot;, &quot; + age + &quot;)&quot;;}/** * 重写equals方法 */@Overridepublic boolean equals(Object obj) {if (obj == null) {return false;}// 如果是同一个对象返回true，反之返回falseif (this == obj) {return true;}// 判断是否类型相同if (this.getClass() != obj.getClass()) {return false;}Person person = (Person) obj;return name.equals(person.name) &amp;&amp; age == person.age;}/** * 重写hashCode方法 */@Overridepublic int hashCode() {int nameHash = name.toUpperCase().hashCode();return nameHash ^ age;}}</code></pre><p>}<br>运行结果：</p><p>p1.equals(p2) : true; p1(68545) p2(68545)<br>p1.equals(p4) : false; p1(68545) p4(68545)<br>set:[(eee, 100), (EEE, 100), (aaa, 200)]</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashcode </tag>
            
            <tag> equals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set家族的对比</title>
      <link href="/2020/02/12/set-hashset-treeset-linkedset/"/>
      <url>/2020/02/12/set-hashset-treeset-linkedset/</url>
      
        <content type="html"><![CDATA[<p>Set接口<br>Set 接口与 List 接口相比没有那么多操作方法，比如：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><p>对比一下Set接口和Collection接口就知道，其实Set接口仅仅对Collection所有方法进行继承而已，而自己没有扩展任何方法，Set接口与Collection接口一样，都是15个方法。</p><img src="/2020/02/12/set-hashset-treeset-linkedset/set.jpg" alt="set" style="zoom:100%; ">Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。这里说的相同元素指的是用 equals() 方法比价后返回 true，当然了如果用 == 也返回true，那肯定也是相同的。一. HashSet特点：<ol><li><p>HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是无序的。</p></li><li><p>HashSet如何保证唯一性？</p></li></ol><p>1). HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2). 确保唯一性的两个方法：hashCode()和equals()方法。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>二. LinkedHashSet<br>特点：</p><ol><li><p>LinkedHashSet中不能有相同元素，可以有一个Null元素，元素严格按照放入的顺序排列。</p></li><li><p>LinkedHashSet如何保证有序和唯一性？</p></li></ol><p>1). 底层数据结构由哈希表和链表组成。</p><p>2). 链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(1)。</p></li><li><p>非线程安全</p></li></ol><p>三. TreeSet<br>特点：</p><ol><li><p>TreeSet是中不能有相同元素，不可以有Null元素，根据元素的自然顺序进行排序。</p></li><li><p>TreeSet如何保证元素的排序和唯一性？</p></li></ol><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><ol start="3"><li><p>添加、删除操作时间复杂度都是O(log(n))</p></li><li><p>非线程安全</p></li></ol><p>四. 总结：<br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collections </category>
          
          <category> Set </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashset </tag>
            
            <tag> linkedhashset </tag>
            
            <tag> treeset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讲清楚Vector vs ArrayList vs LinkedList</title>
      <link href="/2020/02/11/vector-arraylist-linkedlist/"/>
      <url>/2020/02/11/vector-arraylist-linkedlist/</url>
      
        <content type="html"><![CDATA[<p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p></li><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p></li><li><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p></li><li><p>vector是线程（Thread）同步（Synchronized）的，所以它也是线程安全的，而Arraylist是线程异步（ASynchronized）的，是不安全的。如果不考虑到线程的安全因素，一般用Arraylist效率比较高。</p></li><li><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p></li><li><p>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用Linkedlist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p></li><li><p>笼统来说：LinkedList：增删改快，ArrayList：查询快（有索引的存在）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> arraylist </tag>
            
            <tag> linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试高频HashMap VS HashTable</title>
      <link href="/2020/02/11/hashmapVsHashtable/"/>
      <url>/2020/02/11/hashmapVsHashtable/</url>
      
        <content type="html"><![CDATA[<p>在Java 2以前，一般使用Hashtable来映射键值和元素。为了使用Java集合框架，Java对Hashtable进行了重新设计，但是，为了向后兼容保留了所有的方法。Hashtable实现了Map接口，除了Hashtable具有同步功能之外，它与HashMap的用法是一样的。·<br>在使用时一般是用ArrayList代替Vector，LinkedList代替Stack，HashMap代替HashTable，即使在多线程中需要同步，也是用同步包装类。<br>另外在使用上还有一些小的差异，比如：</p><ul><li><p>HashTable的key和value都不允许为null值，而HashMap的key和value则都是允许null值的。这个其实没有好坏之分，只是Sun为了统一Collection的操作特性而改进的。</p></li><li><p>HashTable有一个contains(Object value)方法，功能上与containsValue(Object value)一样，但是在实现上花销更大，现在已不推荐使用。而HashMap只有containsValue(Object value)方法。</p></li><li><p>HashTable使用Enumeration，HashMap使用Iterator。Iterator其实与Enmeration功能上很相似，只是多了删除的功能。用Iterator不过是在名字上变得更为贴切一些。模式的另外一个很重要的功用，就是能够形成一种交流的语言（或者说文化）。有时候，你说Enumeration大家都不明白，说Iterator就都明白了。</p></li></ul><p><strong>不同点</strong></p><h4 id="接口">接口</h4><p><img src="https://pic3.zhimg.com/80/v2-12c49eba132902bbea990a4d77ecce37_hd.jpg" alt="img" style="zoom:50%;"><img src="https://pic3.zhimg.com/80/v2-d7d5449c9638ec4955288a3aa2ba9f13_hd.jpg" alt="img"></p><p>HashMap和Hashtable不仅作者不同，而且连父类也是不一样的。HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口</p><p>Dictionary类是一个已经被废弃的类（见其源码中的注释）。父类都被废弃，自然而然也没人用它的子类Hashtable了。</p><h4 id="线程安全">线程安全</h4><p>线程安全性不同</p><p>Hashtable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步</p><p>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理，</p><p>虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用当中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><h4 id="初始容量大小和每次扩充容量大小的不同">初始容量大小和每次扩充容量大小的不同</h4><p>Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说Hashtable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。</p><h4 id="计算hash值的方法不同">计算hash值的方法不同</h4><p>为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p><p>Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><p><img src="https://pic4.zhimg.com/50/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-df830c3a8054ee1a9f482dc3ccd66bf3_hd.jpg" alt="img"></p><p>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</p><p>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p><p>HashMap的效率虽然提高了，但是hash冲突却也增加了。因为它得出的hash值的低位相同的概率比较高，而计算位运算</p><p>为了解决这个问题，HashMap重新根据hashcode计算hash值后，又对hash值做了一些运算来打散数据。使得取得的位置更加分散，从而减少了hash冲突。当然了，为了高效，HashMap只做了一些简单的位处理。从而不至于把使用2 的幂次方带来的效率提升给抵消掉。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Interview </category>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
            <tag> hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2分钟说清楚shell和batch文件</title>
      <link href="/2020/02/11/shellandbatch/"/>
      <url>/2020/02/11/shellandbatch/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.linuxnix.com/wp-content/uploads/2010/01/windows-os-vs-linux-os.jpg" alt="Batch Programming (Dos Scripting) VS Shell Scripting" style="zoom:50%; ">Batch file</p><p>batch programming vs shell programming</p><p><img src="http://www.gonet.com.cn/~editor/eweditor/uploadfile/20171027141729471.png" alt="区别"></p><p>由于我们普通人接触UNIX的比较少，就不在多说。今天主要来说说WINDOWS系统和LINUX及苹果操作系统的区别。首先这三个系统设计上有本质的区别。最大的区别在于WINDOWS是一个成熟的商业操作系统，拿过来就能用，而LINUX不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。</p><img src="https://img-blog.csdn.net/20180619102423833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVfQXlt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="表格" style="zoom:%; "><p>When I started my career in IT field, I have landed into windows world, as I know that no companies give chance to a fresher to work on production Linux/Unix servers. Its a good experience to work on <strong>DOS scripts(aka Batch programming).</strong> There are many <strong>similarities/differences/advantages/disadvantages</strong> between <strong>Batch programming</strong> and <strong>Shell scripting</strong>. Lets see what they are.</p><p><strong>Similarities</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Sequential execution of group commands in a batch file</td><td>Sequential execution of group command in shell scripts</td></tr><tr><td>2</td><td>Can read inputs from users</td><td>Can read inputs from users</td></tr><tr><td>3</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td><td>Has control structures such as for, if, while, switch for better automating/scripting</td></tr><tr><td>4</td><td>Supports advanced features such as Functions and Arrays</td><td>Supports advanced features such as Functions and Arrays</td></tr><tr><td>5</td><td>Supports regular expressions(using findstr)</td><td>Supports regular expressions</td></tr><tr><td>6</td><td>Can include other programming codes such as perl(ie…in middle of dos script we can include some other programming language code for effective scripting to get our desired output)</td><td>Can include other programming codes such as Perl, AWK, SED etc.</td></tr></tbody></table><p><strong>Differences</strong></p><table><thead><tr><th>Sl. No</th><th>Batch programming</th><th>Shell script</th></tr></thead><tbody><tr><td>1</td><td>Lack of richness of tools/commands</td><td>Have good number of tools(as of my knowledge there are more than 75000 commands in Linux/Unix)</td></tr><tr><td>2</td><td>Supports only one vendor(i.e.windows)</td><td>Supports for number of vendors such as Sun/apple/IBM AIX/HP-UX/GNU Linux etc.</td></tr><tr><td>3</td><td>No other variants for DOS</td><td>There are number of variants such as bash, ksh, csh, zsh etc…</td></tr><tr><td>4</td><td>Low capabilities of integrating with other programming code in batch scripting</td><td>Good capabilities of integrating other programming code in shell script</td></tr><tr><td>5</td><td>Cannot handle complex regular expressions</td><td>Can handle complex regular expressions.</td></tr><tr><td>6</td><td>A batch file should always end with .bat</td><td>There is no such concept like file extension, but a shell script file permission should be set to executable.</td></tr><tr><td>7</td><td>To execute a batch program just enter the file name at CLI</td><td>To execute a shell script, here are the ways to execute it 1)chmod +x <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a>; ./shellscript.sh 2)sh <a href="http://shellscript.sh" target="_blank" rel="noopener">shellscript.sh</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> batch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由String浅谈Immutable不可变对象设计模式</title>
      <link href="/2020/02/11/java-immutable/"/>
      <url>/2020/02/11/java-immutable/</url>
      
        <content type="html"><![CDATA[<h1>什么是Immutable</h1><p>Immutable意为不可改变的，如果一个对象定义成了不可变的（即Immutable Object），就意味着该对象在初始化完成之后它的属性是不能够被修改的。在并发编程中我们可以将对象设计成Immutable Object从而<strong>不用加锁实现线程安全</strong>，因为不可变对象一定是线程安全的，同时由于不需要用一些锁机制等保证内存一致性问题也减少了同步开销。<br>谈到Immutable Object会让很多Javaer联想到Java语言中的final关键字，final关键字可以修饰属性、方法和类。final的作用为</p><blockquote><p>final 修饰的 class 代表该类不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p></blockquote><p>那是不是被final修饰的对象就可以认为是Immutable Object呢？当然不是。请看下面的例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strList = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">strList.add(<span class="string">"ONE"</span>);  <span class="comment">//ok</span></span><br><span class="line">strList.add(<span class="string">"TWO"</span>);  <span class="comment">//ok</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; unmodifiableStrList = Collections.unmodifiableList(strList);</span><br><span class="line">unmodifiableStrList.add(<span class="string">"THREE"</span>); <span class="comment">//throw UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p>这个例子中 <code>strList</code> 声明成final，只能说明strList变量指向的地址空间不能改变但是该地址空间指向的内容是可以修改的。</p><h1>如何定义Immutable Object</h1><p>Java 语言目前还没有原生的不可变对象的支持，但在<a href="https://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener">Java™ Tutorials</a>中给出的如何定义一个不可变对象的方法。</p><p>类中的属性不提供&quot;setter&quot;方法；</p><p>类中所有的属性声明成private和final类型；</p><p>类也声明成final的，以防止类被继承；</p><p>如果有属性是引用类型的，也要防止引用类型的属性被调用方修改了，如通过构造器初始化所有成员，尤其是引用对象要进行深拷贝(deep copy，符合copy-on-write 原则)；</p><p>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，也要深拷贝，创建私有的 copy。</p><p>下面是一个Immutable Object的例子，该对象可以用在并发环境下而没有线程安全问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name,String address)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getAddress() &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看上面示例中使用到的 <code>Collections.unmodifiableList()</code> 方法是如何将一个可变的对象变成不可变对象</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; unmodifiableList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里传入的list是ArrayList，他是RandomAccess的实例</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(<span class="keyword">list</span>) :</span><br><span class="line">            <span class="keyword">new</span> UnmodifiableList&lt;&gt;(<span class="keyword">list</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UnmodifiableRandomAccessList对象是Collections的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableRandomAccessList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    UnmodifiableRandomAccessList(<span class="keyword">List</span><span class="meta">&lt;?</span> extends E&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">        super(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnmodifiableList</code> 是 <code>UnmodifiableRandomAccessList</code> 的父类，它们两个都是 <code>Collections</code> 的静态内部类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;E&gt; <span class="title">extends</span> <span class="title">UnmodifiableCollection</span>&lt;E&gt;</span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List</span>&lt;E&gt; &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;? extends E&gt; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    UnmodifiableList(List&lt;? extends E&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        super(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">list</span> = <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">list</span>.get(index);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List unmodifiableStrList = Collections.unmodifiableList(strList);</code> 语句执行之后unmodifiableStrList变量实际指向的类型会变成 <code>UnmodifiableList</code> 。然后再执行add方法的时候就会抛出 <code>UnsupportedOperationException</code> 异常。<br>除了 <code>unmodifiableList()</code> 方法之外， <code>Collections</code> 中还定义了将其他集合修饰成不可变对象的方法。</p><ul><li>Collections.unmodifiableCollection()</li><li>Collections.unmodifiableMap()</li><li>Collections.unmodifiableSortedMap()</li><li>Collections.unmodifiableSet()</li><li>Collections.unmodifiableSortedSet()</li></ul><p>其基本实现思路和 <code>unmodifiableList()</code> 方法是一样的，另外 <code>Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;);</code> 返回的List对象也是不可变的。</p><h1>String对象的不可变性</h1><p><code>String</code> 是典型的 Immutable 类，被声明成为 final class，它的属性基本都是 final 的。由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。下面是String源码的部分摘录，可以看到它是符合Immutable Object的定义规则的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D;</span><br><span class="line">        new ObjectStreamField[0];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 进行深拷贝来构造引用类型的成员变量 *&#x2F;</span><br><span class="line">    public String(char value[]) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public String(StringBuilder builder) &#123;</span><br><span class="line">        this.value &#x3D; Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">    &#125;</span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen &#x3D; str.length();</span><br><span class="line">        if (otherLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; value.length;</span><br><span class="line">        char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        return new String(buf, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> public char[] toCharArray() &#123;</span><br><span class="line">        &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues</span><br><span class="line">        char result[] &#x3D; new char[value.length];</span><br><span class="line">        System.arraycopy(value, 0, result, 0, value.length);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可见，string是线程安全的，java中string对象需要慎用尤其是我们有大量的字符串拼接修改删除增加的操作时，这会造成大量的内存开销，由此我们可以考虑使用stringbuilder。如果需要同步，则可以使用stringbuffer</p><p>那就要分别看看它们的 <code>append()</code> 源码了；</p><p>StringBuilder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder中的append方法没有使用synchronized关键字，意味着多个线程可以同时访问这个方法。那么问题就来了额，如果两个线程同时访问到这个方法，那么AbstractStringBuilder中的count是不是就是相同的，所以这两个线程都是在底层char数组的count位置开始append添加，那么最终的结果肯定就是在后执行的那个线程append进去的数据会将前面一个覆盖掉。因此我们的控制台输出才会出现StringBuilder一直都是小于1000的。然而StringBuffer却不会发生这种情况。</p><h2 id="总结">总结</h2><ol><li>StringBuilder相比StringBuffer效率更高，但多线程不安全；</li><li>在单线程中字符串的频繁拼接使用StringBuilder效率更高，对于多线程使用StringBuffer则更安全；</li><li>字符串简单操作时没必要使用上述两者，还是用String类型提高速度；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> immutable </tag>
            
            <tag> stringbuilder </tag>
            
            <tag> stringbuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话说Serializable</title>
      <link href="/2020/02/10/transient-java/"/>
      <url>/2020/02/10/transient-java/</url>
      
        <content type="html"><![CDATA[<p>大白话定义：</p><p>序列化是将对象变为可传输内容的过程, 反序列化则是将可传输内容转化为对象的过程.</p><p><strong>切记序列化不考虑static变量</strong></p><p>Java原生序列化方式是通过实现Serializable接口实现的. 不实现该接口会导致无法序列化, 抛出异常如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException</span><br></pre></td></tr></table></figure><p>序列化的应用场景：</p><blockquote><p>将对象转换为字节流, 用于网络传输, 例如用于RPC远程调用。</p><p>将对象保存到磁盘中</p></blockquote><p>Java原生序列化是通过IO包中的ObjectInputStream和ObjectOutputStream实现的。ObjectOutputStream类负责实现序列化, ObjectInputStream类负责实现反序列化。</p><h4 id="Java序列化反序列化实例">Java序列化反序列化实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Person [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class testPerson &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transient">transient</h4><p>出于安全问题，有时候不会把指定字段进行序列化保存，例如密码, 此处以Person对象的pwd字段为例, 为pwd字段添加transient修饰后，默认序列化机制会忽略它。</p><p>对比结果如下 尽管我们对pwd初始化为mdp，但是由于transient关键字，则pwd不被序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;);</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;null]</span><br></pre></td></tr></table></figure><p>如果transient修饰的字段也需要序列化和反序列化，可以使用readObject和writeObject方法。</p><p>我们只需要在当前 Person 类中添加 readObject() 和 writeObject() 方法，在 writeObject 方法中实现对 pwd 的字段赋值，就可以使pwd字段被序列化到字节流中；在 readObject 方法中实现对 pwd 字段读取，并赋值给Person对象即可。<br>添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private transient String pwd;</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream s) throws Exception &#123;</span><br><span class="line">s.defaultReadObject();</span><br><span class="line">this.pwd &#x3D; (String) s.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream s) throws Exception &#123;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">this.pwd &#x3D; &quot;pwd&quot;;</span><br><span class="line">s.writeObject(this.pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPwd(String pwd) &#123;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readObject和writeObject在本文后段内容会讲解.</p><p>这里的defaultWriteObject方法作用是序列化非transient字段以及非静态字段; 这里的defaultReadObject方法作用是反序列化非transient字段以及非静态字段; 当类中含有非transient字段时, 一定要加上这两个方法.</p><p>如果被序列化的类中存在多个transient的字段, 序列化时需要如下操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package serialisation;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class TransientPerson implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private transient Integer age;</span><br><span class="line">private transient String name;</span><br><span class="line">private transient Integer money;</span><br><span class="line"></span><br><span class="line">public TransientPerson(Integer age, String name, Integer money) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">this.age &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.money &#x3D; (Integer) stream.readObject();</span><br><span class="line">this.name &#x3D; (String) stream.readObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeObject(ObjectOutputStream stream) throws Exception &#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeObject(this.age);</span><br><span class="line">stream.writeObject(this.money);</span><br><span class="line">stream.writeObject(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(Integer age) &#123;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Integer getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMoney(Integer money) &#123;</span><br><span class="line">this.money &#x3D; money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;TransientPerson [age&#x3D;&quot; + age + &quot;, name&#x3D;&quot; + name + &quot;, money&#x3D;&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;transientperson.txt&quot;);</span><br><span class="line">ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">TransientPerson person &#x3D; new TransientPerson(3, &quot;abc&quot;, 123);</span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">TransientPerson newPerson &#x3D; (TransientPerson) readObject;</span><br><span class="line">System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc, money &#x3D; 123]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><hr><p>这里writeObject和readObject的使用是有顺序的, 例如第一次writeObject是将age作为Object写入, 所以第一次调用readObject读到的对象就一定是age; 所以, 写入的顺序是age, money, name, 读取时候的顺序一定也要是age, money, name.</p><p>上面理论上会写入了四个对象, 第一个是defaultWriteObject写入的Person对象, 之后写入的是age(Integer对象), money(Integer), name(String).</p><p>当然这里defaultWriteObject没有写入, 因为所有成员字段都是transient修饰, 所以实际上只有三个对象(age, money, name). 换句话说, 当所有字段被transient修饰时, 可以不用defaultWriteObject和defaultReadObject.</p><h4 id="serialVersionUID">serialVersionUID</h4><p>当person对象被序列化保存到person.txt文件时, 在Person对象中添加新的属性address, 只执行反序列化代码, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;mac&#x2F;eclipse&#x2F;eclipse-workspace&#x2F;AlgorithmeSource&#x2F;person.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">&#x2F;&#x2F;Person person &#x3D; new Person(3, &quot;abc&quot;, &quot;mdp&quot;, &quot;paris&quot;);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.writeObject(person);</span><br><span class="line">&#x2F;&#x2F;objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">Object readObject &#x3D; objectInputStream.readObject();</span><br><span class="line">objectInputStream.close();</span><br><span class="line"></span><br><span class="line">Person newPerson &#x3D; (Person) readObject;</span><br><span class="line">&#x2F;&#x2F;System.out.println(person &#x3D;&#x3D; newPerson); &#x2F;&#x2F; Person [age&#x3D;3, name&#x3D;abc]</span><br><span class="line">System.out.println(newPerson);</span><br></pre></td></tr></table></figure><p>输出结果依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person [age&#x3D;3, name&#x3D;abc, pwd&#x3D;pwd, address&#x3D;null]</span><br></pre></td></tr></table></figure><p>但是我们删除serialVersionUID字段后再次执行, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private Integer age;</span><br><span class="line">private String name;</span><br><span class="line">private transient String pwd;</span><br><span class="line">private String address; &#x2F;&#x2F; 新添加的属性</span><br><span class="line"></span><br><span class="line">public Person(Integer age, String name, String pwd, String address) &#123;</span><br><span class="line">super();</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.pwd &#x3D; pwd;</span><br><span class="line">this.address &#x3D; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: wotest.test.Person;  local class incompatible: stream classdesc serialVersionUID &#x3D; 1,  local class serialVersionUID &#x3D; 3229018537912438741</span><br></pre></td></tr></table></figure><p>原因:</p><blockquote><p>没有定义serialVersionUID值, 反序列化可能会出现 <code>local class incompatible</code> 异常, 是Java的安全机制.</p><p>当序列化对象时, 如果该对象所属类没有serialVersionUID, Java编译器会对jvm中该类的Class文件进行摘要算法生成一个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; serialVersionUID(version1), 并保存在序列化结果中. </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当反序列化时, jvm会再次对jvm中Class文件摘要生成一个serialVersionUID(version2). 当且仅当version1=version2时, 才会将反序列化结果加载入jvm中, 否则jvm会判断为不安全, 拒绝载入并抛出 <code>local class incompatible</code> 异常.</p><p>这样存在的问题就是, 当对象被序列化后, 其所属类只要进行过类名称, 它所实现的接口的名称, 以及所有成员名称的修改, 会导致摘要算法算出的serialVersionUID变化.</p></blockquote><p>从而version1 != version2导致抛出异常.</p><blockquote><p>例如序列化对象存储在磁盘中后, jvm停止, 对其所属类进行修改. 再次启动jvm, 对该对象序列化时就会抛异常.</p></blockquote><p>由此可知, 反序列化时会通过比较serialVersionUID进行 <code>判断反序列化内容是否安全</code> , 所以添加如下声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; 3229018537912438741L;</span><br></pre></td></tr></table></figure><p>将serialVersionUID值固定下来, 可以防止这种情况下的反序列化失败.</p><p><strong>另外, 如果 User 对象升级版本，修改了结构，而且不想兼容之前的版本，那么只需要修改下 serialVersionUID 的值就可以了。</strong></p><p>建议，每个需要序列化的对象，都要添加一个 serialVersionUID 字段。</p><p><strong>最后延伸一下，HashMap中重写的writeObject和readObject</strong></p><h5 id="HashMap序列化存在的问题">HashMap序列化存在的问题</h5><p>HashMap有必须重写它们的理由, 因为序列化会导致字节流在不同的jvm中传输, 而序列化基本要求就是反序列化后的对象与序列化之前的对象是一致的.</p><p>HashMap中，由于Entry的存放位置是根据Key的Hash值计算, 对于同一个Key，在不同的jvm中计算得出的Hash值可能是不同的.</p><p>Hash值不同导致HashMap对象反序列化的结果与序列化之前不一致. 有可能序列化之前Key=’name’的元素放在数组的第0个位置, 而反序列化后在数组第2个位置.</p><h5 id="HashMap的解决方式">HashMap的解决方式</h5><ul><li><p>将可能造成数据不一致的元素使用transient修饰，然后重写writeObject/readObject方法, 在该方法中操作这些敏感元素, 避免默认序列化方法的干扰。被transient修饰的元素有: Entry[] table, size, modCount。</p></li><li><p>首先，HashMap序列化的时候会屏蔽掉负载因子, 只把不为空的key和value进行序列化. 传送到新的jvm反序列化时, 根据新的jvm处的规则重新对key进行hash算法, 重新填充一个数组. 这样避免了对象的不一致.</p></li></ul><h5 id="HashMap源码">HashMap源码</h5><p>writeObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    int buckets &#x3D; capacity();</span><br><span class="line">    &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s); &#x2F;&#x2F; 将有效的键值对进行了序列化.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到writeObject中序列化了buckets和size, 之后又通过internalWriteEntries方法将有效的键值对进行了序列化.</p><p>之后在readObject方法中反序列化时也要按照这个顺序.</p></blockquote><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                &#x2F;&#x2F; Read and ignore number of buckets</span><br><span class="line">    int mappings &#x3D; s.readInt(); &#x2F;&#x2F; Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; &#x2F;&#x2F; (if zero, use defaults)</span><br><span class="line">        &#x2F;&#x2F; Size the table using given load factor only if within</span><br><span class="line">        &#x2F;&#x2F; range of 0.25...4.0</span><br><span class="line">        float lf &#x3D; Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc &#x3D; (float)mappings &#x2F; lf + 1.0f;</span><br><span class="line">        int cap &#x3D; ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;&#x3D; MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft &#x3D; (float)cap * lf;</span><br><span class="line">        threshold &#x3D; ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab &#x3D; (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table &#x3D; tab;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key &#x3D; (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value &#x3D; (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按照顺序依次读出了:</p><ul><li>对象中非transient以及非static字段(defaultReadObject方法);</li><li>buckets, 但是被忽略了(见注释: Read and ignore number of buckets);</li><li>size(int mappings = s.readInt());</li><li>根据size遍历读取键值对(for (int i = 0; i &lt; mappings; i++)).</li></ul></blockquote><p>遍历读取的键值对最终依据新的规则保存到了新的map中, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key &#x3D; (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value &#x3D; (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList重写writeObject和readObject">ArrayList重写writeObject和readObject</h4><p>值得注意的是, ArrayList重写writeObject和readObject. 是因为在ArrayList中的数组容量基本上都会比实际的元素的数大, 为了避免序列化没有元素的数组而重写.</p><ul><li>writeObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read in capacity</span><br><span class="line">    s.readInt(); &#x2F;&#x2F; ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a &#x3D; elementData;</span><br><span class="line">        &#x2F;&#x2F; Read in all elements in the proper order.</span><br><span class="line">        for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] &#x3D; s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serialisation </tag>
            
            <tag> deserialisation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态委托</title>
      <link href="/2020/02/04/delegate-avance/"/>
      <url>/2020/02/04/delegate-avance/</url>
      
        <content type="html"><![CDATA[<p>接着上一篇的内容<br>大家看这个可能觉得有些抽象，我在github上传了一个更加具体的例子，比如三星和华为各自有自己品牌和屏幕，富士康与华为合作，默认是华为的品牌和屏幕，但是委托小米生产线，决定用三星的屏幕和技术，这就是一个典型的代理例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;技术方法</span><br><span class="line">public interface OledTch &#123;</span><br><span class="line">&#x2F;&#x2F; 技术名称</span><br><span class="line">public void tchName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 色彩饱和度</span><br><span class="line">public void colorSaturation();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;三星</span><br><span class="line">public class Sumsung implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;98%NTSC - Sumsung OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;华为</span><br><span class="line">public class Huawei implements OledTch &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;Huawei OLED&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;富士康</span><br><span class="line">public class Fotconn implements OledTch &#123;</span><br><span class="line">private OledTch oledMap; &#x2F;&#x2F;富土康的OLED生产图纸</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：甲方指定用哪家的图纸就用哪家的图纸</span><br><span class="line">public Fotconn(OledTch oledMap) &#123;</span><br><span class="line">this.oledMap &#x3D; oledMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数：默认情况下，用华为的生产图纸</span><br><span class="line">public Fotconn() &#123;</span><br><span class="line">this.oledMap &#x3D; new Huawei();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void tchName() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">oledMap.tchName();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void colorSaturation() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">System.out.print(&quot;| 富土康生产的——&quot;);</span><br><span class="line">                oledMap.colorSaturation();</span><br><span class="line">System.out.print(&quot; |&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class Xiaomi_Pipeline &#123;</span><br><span class="line"></span><br><span class="line">public void oled() &#123;</span><br><span class="line">Sumsung sumsung &#x3D; new Sumsung(); &#x2F;&#x2F; 确定使用三星的OLED技术</span><br><span class="line">Fotconn fotconn &#x3D; new Fotconn(sumsung);&#x2F;&#x2F; 告诉乙方 富土康：“我要三星图纸生产的OLED”</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小米正在生产: &quot;);</span><br><span class="line">fotconn.tchName();</span><br><span class="line">fotconn.colorSaturation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testXiaomi8() &#123;</span><br><span class="line">Xiaomi_Pipeline xiaomi8 &#x3D; new Xiaomi_Pipeline();</span><br><span class="line">xiaomi8.oled();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.39.03.png" alt="屏幕快照 2020-02-04 22.39.03" style="zoom:33%; "><p>我想讲一下我今天新学到的这个思路，就是动态代理，假象一个环境，我们用schduler来调控我们的任务，然后每一个任务对应不同的service，每个service我们有具体的实现方法，这时我们可以用到invoke的动态委托，我来画一个图。</p><img src="/2020/02/04/delegate-avance/屏幕快照 2020-02-04 22.04.13.png" alt="屏幕快照 2020-02-04 22.04.13" style="zoom:50%; "><h4 id="使用动态代理">使用动态代理</h4><h4 id="定义接口">定义接口</h4><p>下面我们用Vendor类代表生产厂家，BusinessAgent类代表微商代理，来介绍下动态代理的简单实现，委托类和代理类都实现了Sell接口，Sell接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 委托类和代理类都实现了Sell接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Sell &#123; </span><br><span class="line">    void sell(); </span><br><span class="line">    void ad();</span><br></pre></td></tr></table></figure><h4 id="InvocationHandler接口">InvocationHandler接口</h4><p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 调用处理程序</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface InvocationHandler &#123; </span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。下面我们来一步一步具体实现它。</p><h4 id="委托类的定义">委托类的定义</h4><p>动态代理方式下，要求委托类必须实现某个接口，这里我们实现的是Sell接口。委托类Vendor类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Vendor implements Sell &#123; </span><br><span class="line">    public void sell() &#123; </span><br><span class="line">        System.out.println(&quot;In sell method&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        System,out.println(&quot;ad method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中介类">中介类</h4><p>上面我们提到过，中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。中介类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123; </span><br><span class="line">    &#x2F;&#x2F;obj为委托类对象; </span><br><span class="line">    private Object obj; </span><br><span class="line"> </span><br><span class="line">    public DynamicProxy(Object obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @Override </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span><br><span class="line">        System.out.println(&quot;before&quot;); </span><br><span class="line">        Object result &#x3D; method.invoke(obj, args); </span><br><span class="line">        System.out.println(&quot;after&quot;); </span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看到，中介类持有一个委托类对象引用，在invoke方法中调用了委托类对象的相应方法</p><h3 id="动态生成代理类">动态生成代理类</h3><p>动态生成代理类的相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123; </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建中介类实例 </span><br><span class="line">        DynamicProxy inter &#x3D; new DynamicProxy(new Vendor()); </span><br><span class="line">        &#x2F;&#x2F;加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取代理类实例sell </span><br><span class="line">        Sell sell &#x3D; (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter)); </span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;通过代理类对象调用代理类方法，实际上会转到invoke方法调用 </span><br><span class="line">        sell.sell(); </span><br><span class="line">        sell.ad(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br></pre></td></tr></table></figure><p>复制代码方法的三个参数含义分别如下：<br>loader：定义了代理类的ClassLoder;<br>interfaces：代理类实现的接口列表<br>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例<br>我们运行一下，看看我们的动态代理是否能正常工作。我这里运行后的输出为</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cbbd27e07f9a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="代理模式">代理模式</h3><p>这个应该是设计模式中最简单的一个了，类图</p><p>代理模式最大的特点就是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作</p><p>Java动态代理其实内部也是通过Java反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后作一些相应的处理，这样说的比较笼统，举个简单的例子</p><p>比如我们在应用中有这样一个需求，在对某个类的一个方法的调用前和调用后都要做一下日志操作，</p><p>一个普通的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AppService &#123;  </span><br><span class="line">    public boolean createApp(String name);  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该接口的默认实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AppServiceImpl implements AppService &#123;  </span><br><span class="line">    public boolean createApp(String name) &#123;  </span><br><span class="line">        System.out.println(&quot;App[&quot;+name+&quot;] has been created.&quot;);  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>日志处理器（实质充当了中介类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 注意需实现Handler接口  </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LoggerInterceptor implements InvocationHandler &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;目标对象的引用，这里设计成Object类型，更具通用性  </span><br><span class="line">    public LoggerInterceptor(Object target)&#123;  </span><br><span class="line">        this.target &#x3D; target;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] arg)  throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;Entered &quot;+target.getClass().getName()+&quot;-&quot;+method.getName()+&quot;,with arguments&#123;&quot;+arg[0]+&quot;&#125;&quot;);  </span><br><span class="line">        Object result &#x3D; method.invoke(target, arg);&#x2F;&#x2F;调用目标对象的方法  </span><br><span class="line">        System.out.println(&quot;Before return:&quot;+result);  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>外部调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AppService target &#x3D; new AppServiceImpl();&#x2F;&#x2F;生成目标对象  </span><br><span class="line">        &#x2F;&#x2F;接下来创建代理对象  </span><br><span class="line">        AppService proxy &#x3D; (AppService) Proxy.newProxyInstance(  </span><br><span class="line">                target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), new LoggerInterceptor(target));  </span><br><span class="line">        proxy.createApp(&quot;Kevin Test&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delegate </tag>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈java中的委托和继承</title>
      <link href="/2020/02/04/delagate-java/"/>
      <url>/2020/02/04/delagate-java/</url>
      
        <content type="html"><![CDATA[<p>上学的时候听到过委托这个词，写程序的时候自己用到过这种方式，面试的时候被问到过，做题的时候也有相关的练习，今天工作的时候debug看到我们自己也用到了delegate这个设计模式作为基类，所以就在这里总结一下。</p><p>为了区分继承 Inheritance，在这里将两者对比</p><h5 id="概念">概念</h5><p><strong>delegate和inheritance都可以提高代码的复用性</strong></p><ul><li><p>delegate：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象</p></li><li><p>继承：利用extends来扩展一个基类。</p></li></ul><hr><h5 id="Delegation（委托）">Delegation（委托）</h5><p>首先我们来看委托： 委托分为委托方和依赖方，他要求特定的方法在运行时调用不同的代码，这就是委托依赖与动态绑定，例如我们看一下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">void foo() &#123;</span><br><span class="line">this.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">System.out.println(&quot;a.bar&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在B类中，不使用继承，而是利用委托结合A，达到复用A类中代码的效果，其实平常我们在编程中也写过很多这样的例子只是不知道这种设计模式就是委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package delegate;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a &#x3D; a; </span><br><span class="line">    &#125;</span><br><span class="line">    void foo() &#123;</span><br><span class="line">        a.foo(); &#x2F;&#x2F; call foo() on the a-instance &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;b.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面代码的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    A a &#x3D; new A();</span><br><span class="line">    B b &#x3D; new B(a); </span><br><span class="line">    b.foo();</span><br><span class="line">    b.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易地看出来结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.bar</span><br><span class="line">b.bar</span><br></pre></td></tr></table></figure><p>这就是一种简单的委派机制。</p><p>当然在当下IDP（控制反转：这里不多赘述了，之前也提到过这是spring的核心之一）的时代，接口才是王道，所以我们可以换另一种方式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoggingList&lt;E&gt; implements List&lt;E&gt;&#123;</span><br><span class="line"> private final List&lt;E&gt; list1;</span><br><span class="line">    public LoggingList(List&lt;E&gt; list) &#123; </span><br><span class="line">        this.list1 &#x3D; list; </span><br><span class="line">    &#125; </span><br><span class="line">    public boolean add(E e) &#123; </span><br><span class="line">        System.out.println(&quot;Adding &quot; + e); </span><br><span class="line">        return list1.add(e); </span><br><span class="line">    &#125; </span><br><span class="line">    public E remove(int index) &#123; </span><br><span class="line">        System.out.println(&quot;Removing at &quot; + index); </span><br><span class="line">        return list1.remove(index); </span><br><span class="line">    &#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">list1.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这就相当于我们重写add，remove和clear三个方法，但是没有继承</p><h4 id="委派的几种类型归纳">委派的几种类型归纳</h4><ul><li>Use (A use B)</li><li>Composition/aggregation (A owns B)</li><li>Association (A has B)</li></ul><h4 id="Dependency（依赖）-临时性的delegation">Dependency（依赖）: 临时性的delegation</h4><ul><li>在这种关系中，一个类使用另一个类而不将其作为一个属性。</li><li>两类之间的这种关系称为“uses-a”关系。例如，它可以是一个参数，或者在一个方法中本地使用，参考下面的代码：</li></ul><p>首先新建一个课程类：</p><p>public class Course {}</p><p>在课表类总使用课程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CourseSchedule &#123;</span><br><span class="line">    List&lt;Course&gt; courses &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public void add (Course c) &#123;</span><br><span class="line">        courses.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove (Course c) &#123;</span><br><span class="line">        courses.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，并没有将Course类作为CourseSchedule类的属性来使用，而是作为迭代器中的元素和方法中的参数来使用。</p><h4 id="Association（关联）-永久性的delegation">Association（关联）: 永久性的delegation</h4><p>关联是类之间的持久关系，允许一个对象实例让另一个对象实例代表它自己做其他事。<br>这种关系属于has-a的关系，是结构化的，因为它指定了一种对象与另一种对象相连接，并且不代表行为，即不在该类的方法中使用另一个类的方法，只是简单的将不同的对象连接起来。</p><p>下面展示一下关联的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Teacher &#123;    </span><br><span class="line">private Student [] students;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;    </span><br><span class="line">private Teacher teacher;    </span><br><span class="line">Course[] selectedCourses; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在两个类中（Student和Teacher）互相都有彼此的实例，而且没有使用继承，就直接将这几个不同的类相连接，这就是利用了Association方式。</p><h4 id="Composition-更强的delegation">Composition: 更强的delegation</h4><p>组合是将简单对象或数据类型组合成更复杂的方法的一种方法。<br>这种关系是a-part-of关系，一个类有另一个属性或实例变量——实现了一个对象包含另一个对象。<br>let s show 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Heart &#123;&#125;</span><br><span class="line">class Person &#123; </span><br><span class="line">    private Heart heart &#x3D; new Heart();</span><br><span class="line">    public void operation () &#123; </span><br><span class="line">        heart.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式理解起来就很简单了，直接在该类中实例化一个其他类，然后该调用方法调用方法，对这个实例想怎么用怎么用，十分灵活。<br>不过需要注意的是：<br>这里的实例是private的，也就是说，外界访问不到，这样的话，更改其值只能在该方法中；而且每次创建该类的对象时，就已经创建好这个类中的实例；也就是说一旦创建好该类的对象，其中的属性指向便已经创建好。</p><h4 id="Aggregation">Aggregation</h4><p>聚集：对象存在于另一个之外，是在外部创建的，所以它作为一个参数传递给构造函数。<br>这种关系是has-a的关系，区别于</p><p>让我们看一个这个例子的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;&#125;</span><br><span class="line">class Course &#123; </span><br><span class="line">    private Student[] students; </span><br><span class="line">    public addStudent (Student s) &#123; </span><br><span class="line">        studtents.append(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这里，内部的属性是可以在外部指定的，而不是完全依赖该类。</p><h4 id="Composition-vs-Aggregation">Composition vs. Aggregation</h4><p>组合和聚集是最常用的两种delegation方式，可以说，其中的使用包括了依赖和关联方式，并在其上做了进一步的扩展。二者很相似，但又有很多不同之处，这里举一个例子看一下二者的最大不同之处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer(HttpListener listener, RequestProcessor processor) &#123;</span><br><span class="line">        this.listener &#x3D; listener;</span><br><span class="line">        this.processor &#x3D; processor;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class WebServer &#123; </span><br><span class="line">    private HttpListener listener; </span><br><span class="line">    private RequestProcessor processor; </span><br><span class="line">    public WebServer() &#123; </span><br><span class="line">        this.listener &#x3D; new HttpListener(80); </span><br><span class="line">        this.processor &#x3D; new RequestProcessor(“&#x2F;www&#x2F;root”);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inheritance（继承）">Inheritance（继承）</h4><p>继承就很好说了，直接是一个类利用extends扩展其父类，而且一个类只能扩展一个父类，但是可以多层扩展。<br>参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        this.bar(); </span><br><span class="line">    &#125;</span><br><span class="line">    void bar() &#123;</span><br><span class="line">        System.out.println(&quot;A.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    public B() &#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void foo() &#123; </span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        System.out.println(&quot;B.bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以猜一下下面代码的输出的结果，比较有趣：</p><p>B b = new B();<br>b.foo();<br>我这里运行的结果是</p><p>B.bar<br>可以看到，在继承中，子类拥有父类所有的方法，而且还可以继续增加父类中没有的方法。</p><h4 id="适用于不同场合">适用于不同场合</h4><p>总而言之，委派和继承都是为了代码复用，只是方式不同。</p><ul><li>委托可以被看作是对象级别的重用机制，而继承是类级别的重用机制。</li><li>此外，如果子类只需要复用父类中的一小部分方法，可以不需 要使用继承，而是通过委派机制来实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delegate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rmi_java_springboot</title>
      <link href="/2020/01/30/rmi-java-springboot/"/>
      <url>/2020/01/30/rmi-java-springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker vs VM 与 web url的关系</title>
      <link href="/2020/01/26/computerwebadnresources/"/>
      <url>/2020/01/26/computerwebadnresources/</url>
      
        <content type="html"><![CDATA[<h3 id="1-What-Happens-When-You-Type-in-a-URL">1 What Happens When You Type in a URL?</h3><p>1 enter url in browser</p><p>2 browser look up ip address of domaine via dns</p><p>3 browser send a request to server</p><p>4 server returns a http response</p><p>5 browser rends html</p><p>6 browser need css js images then repeat 3-5</p><p>7 finish loading, send futur async request</p><h3 id="2-How-Web-Browsers-and-Web-Servers-Communicate">2 How Web Browsers and Web Servers Communicate?</h3><p>Web browsers and servers communicate using TCP/IP. Hypertext Transfer Protocol is the standard application protocol on top of TCP/IP supporting web browser requests and server responses</p><p>Web browsers also rely on DNSto work with URLs. These protocol standards enable different brands of web browsers to communicate with different brands of web servers without requiring special logic for each combination.</p><p>1 A person specifies a URL in a browser.</p><p>2  The browser initiates a TCP connection to the web server or server pool (using port 80 by default). As part of this process, the browser also makes DNS lookup requests to convert the URL to an IP address.</p><p>3 After the server completes acknowledgment of its side of the TCP connection, the browser sends HTTP requests to the server to retrieve the content.</p><p>4 after the server replies with content for the page, the browser retrieves it from the HTTP packets and displays it accordingly. Content can include embedded URLs for advertising banners or other external content, that in turn triggers the browser to issue new TCP connection requests to those locations. The browser may also save temporary information about its connections to local files on the client computer called <em>cookies</em>.</p><p>5 Any errors encountered during the request for the content might be shown as http status error line</p><h3 id="3-what-is-microservice-architecture">3 what is microservice architecture?</h3><p>A microservices architecture takes this same approach and extends it to the loosely coupled services which can be developed, deployed, and maintained independently. Each of these services is responsible for discrete task and can communicate with other services through simple APIs to solve a larger complex business problem.</p><p>Once developed, these services can also be deployed independently of each other and hence its easy to identify hot services and scale them independent of whole application. Microservices also offer improved fault isolation whereby in the case of an error in one service the whole application doesn’t necessarily stop functioning. When the error is fixed, it can be deployed only for the respective service instead of redeploying an entire application.</p><p>Another advantage which a microservices architecture brings to the table is making it easier to choose the technology stack (programming languages, databases, etc.) which is best suited for the required functionality (service) instead of being required to take a more standardized, one-size-fits-all approach.</p><h3 id="4-Difference-between-docker-and-vm">4 Difference between docker and vm?</h3><p>Docker is virtual machine that was more lightweight, economical, and scalable. Docker is a container-based technology that lets you develop distributed applications</p><p>**A virtual machine is a system which acts exactly like a computer.**In simple terms, it makes it possible to run what appears to be on many separate computers on hardware, that is one computer. Each virtual machine requires its underlying operating system, and then the hardware is virtualized.</p><p>**Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container</p><p><strong>. Docker is a tool that uses containers to make creation, deployment, and running of application a lot easier. It binds application and its dependencies inside a container.</strong></p><img src="https://geekflare.com/wp-content/uploads/2019/09/traditional-vs-new-gen.png" alt="Traditional vs New Gen" style="zoom:60%; "><p>The operating system support of Virtual machine and Docker container is very different. From the image above, you can see each virtual machine has its guest operating system above the host operating system, which makes virtual machines heavy. While on the other hand, Docker containers share the host operating system, and that is why they are lightweight.</p><p>Sharing the host operating system between the containers make them very light and helps them to boot up in just a few seconds. Hence, the overhead to manage the container system is very low compared to that of virtual machines.</p><p>The docker containers are suited for situations where you want to run multiple applications over a single operating system kernel.<strong>But if you have applications or servers that need to run on different operating system flavors, then virtual machines are required.</strong></p><p><strong>Security</strong></p><p>The virtual machine does no share operating system, and there is strong isolation in the host kernel. Hence, they are more secure as compared to Containers. A container have a lot of security risks, and vulnerabilities as the containers have shared host kernel.</p><p><strong>Portability</strong></p><p>Docker containers are easily portable because they do not have separate operating systems. A container can be ported to a different OS, and it can start immediately. On the other hand, virtual machines have separate OS, so porting a virtual machine is difficult as compared to containers, and it also takes a lot of time to port a virtual machine because of its size.</p><p>For development purposes where the applications must be developed and tested in different platforms, Docker containers are the ideal choice.</p><p><strong>Performance</strong></p><p>Comparing Virtual machines and Docker Containers would not be fair because they both are used for different purposes. But the lightweight architecture of docker its less resource-intensive feature makes it a better choice than a virtual machine. As a result, of which containers can startup very fast compared to that of virtual machines, and the resource usage varies depending on the load or traffic in it.</p><p>Unlike the case of virtual machines, there is no need to allocate resources permanently to containers. Scaling up and duplicating the containers is also an easy task compared to that of virtual machines, as there is no need to install an operating system in them.</p><table><thead><tr><th><strong>Virtual Machine</strong></th><th><strong>Docker Container</strong></th></tr></thead><tbody><tr><td>Hardware-level process isolation</td><td>OS level process isolation</td></tr><tr><td>Each VM has a separate OS</td><td>Each container can share OS</td></tr><tr><td>Boots in minutes</td><td>Boots in seconds</td></tr><tr><td>VMs are of few GBs</td><td>Containers are lightweight (KBs/MBs)</td></tr><tr><td>Ready-made VMs are difficult to find</td><td>Pre-built docker containers are easily available</td></tr><tr><td>VMs can move to new host easily</td><td>Containers are destroyed and re-created rather than moving</td></tr><tr><td>Creating VM takes a relatively longer time</td><td>Containers can be created in seconds</td></tr><tr><td>More resource usage</td><td>Less resource usage</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring高频面试题</title>
      <link href="/2020/01/26/springBootMVC/"/>
      <url>/2020/01/26/springBootMVC/</url>
      
        <content type="html"><![CDATA[<h3 id="基本常识">基本常识</h3><hr><p>使用Spring框架的好处是什么？**</p><ul><li>**轻量：**Spring是轻量的，基本的版本大约2MB。</li><li>**控制反转：**Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li>**面向切面的编程(AOP)：**Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li>**容器：**Spring包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li>**事务管理：**Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li>**异常处理：**Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛出的）转化为一致的unchecked异常。</li></ul><p><strong>Spring由哪些模块组成?</strong></p><p>以下是Spring框架的基本模块：</p><ul><li><p>Coremodule</p><p>spring core模块是spring的核心容器，它实现了<strong>ioc</strong>模式，提供了spring框架的基础功能。此模块中包含的beanfactory类是spring的核心类，负责javabean的配置与管理。它采用factory模式实现了ioc即依赖注入。</p></li><li><p>Beanmodule</p><p>谈到javabean，它是一种 java 类，它遵从一定的设计模式，使它们易于和其他开发工具和组件一起使用。定义 javabean 是一种java 语言写成的可重用组件。要编写javabean，类必须是具体类和公共类，并且具有无参数的构造器。</p></li><li><p>Contextmodule</p><p>pring context模块继承beanfactory（或者说spring核心）类，并且添加了事件处理、国际化、资源装载、透明装载、以及数据校验等功能。它还提供了框架式的bean的访问方式和很多企业级的功能，如jndi访问、支持ejb、远程调用、集成模板框架、email和定时任务调度等。</p></li><li><p>ExpressionLanguagemodule</p></li><li><p>dao模块</p></li></ul><p>dao是 data access object的缩写，dao模式思想是将业务逻辑代码与数据库交互代码分离，降低两者耦合。通过dao模式可以使结构变得更为清晰，代码更为简洁。dao模块提供了jdbc的抽象层，简化了数据库厂商的异常错误（不再从sqlexception继承大批代码），大幅度减少代码的编写，并且提供了对声明式事务和编程式事务的支持。</p><ul><li>orm映射模块</li></ul><p>spring orm 模块提供了对现有orm框架的支持，各种流行的orm框架已经做得非常成熟，并且拥有大规模的市场，spring没有必要开发新的orm工具，它对hibernate提供了完美的整合功能，同时也支持其他orm工具。注意这里spring是提供各类的接口（support），目前比较流行的下层数据库封闭映射框架，如 ibatis, hibernate等</p><p><strong>为什么说Spring是一个容器？</strong></p><p>因为用来形容它用来存储单例的bean对象这个特性。</p><p><strong>Spring配置文件</strong></p><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><p><strong>什么是SpringIOC容器？</strong></p><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p><strong>IOC的优点是什么？</strong></p><p>IOC或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><p><strong>ApplicationContext通常的实现是什么?</strong></p><ul><li>**FileSystemXmlApplicationContext：**此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li><li>**ClassPathXmlApplicationContext：**此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li>**WebXmlApplicationContext：**此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><h3 id="依赖注入">依赖注入</h3><hr><p>什么是Spring的依赖注入？**</p><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><ul><li><p>**构造器依赖注入：**构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 强制依赖</p></li><li><p>**Setter方法注入：**Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 可选依赖</p></li></ul><h3 id="Springbeans">Springbeans</h3><hr><p><strong>什么是Springbeans?</strong></p><p>Springbeans是那些形成Spring应用的主干的java对象。它们被SpringIOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean>的形式定义。</bean></p><p>Spring框架定义的beans都是单件beans。在beantag中有个属性”singleton”，如果它被赋为TRUE，bean就是单件，否则就是一个prototypebean。默认是TRUE，所以所有在Spring框架中的beans缺省都是单件。</p><p><strong>Spring框架中的单例bean是线程安全的吗?</strong></p><p>不，Spring框架中的单例bean不是线程安全的。</p><p><strong>解释Spring框架中bean的生命周期。</strong></p><ul><li>Spring容器从XML文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware接口，Spring传递bean的ID到setBeanName方法。</li><li>如果Bean实现了BeanFactoryAware接口，Spring传递beanfactory给setBeanFactory方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors和bean关联，这些bean的postProcessAfterInitialization()方法将被调用。</li><li>如果bean实现了DisposableBean，它将调用destroy()方法。</li></ul><p><strong>哪些是重要的bean生命周期方法？你能重载它们吗？</strong></p><p>有两个重要的bean生命周期方法，第一个是setup，它是在容器加载bean的时候被调用。第二个方法是teardown它是在容器卸载类的时候被调用。</p><p>Thebean标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><p><strong>什么是Spring的内部bean？</strong></p><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义innerbean，在Spring的基于XML的配置元数据中，可以在<property>或<constructor-arg>元素内使用<bean>元素，内部bean通常是匿名的，它们的Scope一般是prototype。</bean></constructor-arg></property></p><p><strong>在Spring中如何注入一个java集合？</strong></p><p>Spring提供以下几种集合的配置元素：</p><ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为String类型。</props></li></ul><p><strong>什么是bean装配?</strong></p><p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><p><strong>什么是bean的自动装配？</strong></p><p>Spring容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p><p><strong>自动装配有哪些局限性?</strong></p><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p>**模糊特性：**自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><p><strong>解释不同方式的自动装配。</strong></p><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ul><li><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref属性来进行装配。</li><li>**byName：**通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li>**byType:：**通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li><strong>constructor：这个方式类似于</strong>byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>**autodetect：**首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><h3 id="Spring-注解">Spring 注解</h3><hr><p><strong>什么是基于Java的Spring注解配置? 给一些注解的例子.</strong></p><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration注解为例，它用来标记类可以当做一个bean的定义，被SpringIOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><p><strong>什么是基于注解的容器配置?</strong></p><p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p><p>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p><p><strong>怎样开启注解装配？</strong></p><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<a href="context:annotation-config/">context:annotation-config/</a>元素。</p><p><strong>@Required注解</strong></p><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p><p><strong>@Autowired注解</strong></p><p>@Autowired注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p><p><strong>@Qualifier注解</strong></p><p>当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p><h3 id="Spring-数据访问">Spring 数据访问</h3><hr><p><strong>在Spring框架中如何更有效地使用JDBC?</strong></p><p>使用SpringJDBC框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements和queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><p>Add jDBC dependency -&gt; Instance class -&gt; DaoInterface -&gt; JDBCObjectImp</p><p><strong>JdbcTemplate</strong></p><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><p><strong>pring对DAO的支持</strong></p><p>Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，HibernateorJDO结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p><p><strong>使用Spring通过什么方式访问Hibernate?</strong></p><p>在Spring中有两种方式访问Hibernate：</p><p>控制反转HibernateTemplate和Callback。</p><p>继承HibernateDAOSupport提供一个AOP拦截器。</p><p><strong>Spring支持的ORM</strong></p><p>Spring支持以下ORM：</p><ul><li>Hibernate</li><li>iBatis</li><li>JPA(JavaPersistenceAPI)</li><li>TopLink</li><li>JDO(JavaDataObjects)</li><li>OJB</li></ul><p><strong>Spring支持的事务管理类型</strong></p><p>Spring支持两种类型的事务管理：</p><p>· <strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>· **声明式事务管理：**这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><p><strong>你更倾向用那种事务管理类型？</strong></p><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p><h4 id="Spring面向切面编程（AOP）"><strong>Spring面向切面编程（AOP）</strong></h4><hr><p><strong>解释AOP</strong></p><p>面向切面的编程，或AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p><p><strong>Aspect切面</strong></p><p>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在SpringAOP中，切面通过带有@Aspect注解的类实现。</p><p><strong>在SpringAOP中，关注点和横切关注的区别是什么？</strong></p><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p><strong>通知</strong></p><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用五种类型的通知：</p><p><strong>before</strong>：前置通知，在一个方法执行前被调用。</p><p>**after:**在方法执行之后调用的通知，无论方法执行是否成功。</p><p>**after-returning:**仅当方法成功完成后执行的通知。</p><p>**after-throwing:**在方法抛出异常退出时执行的通知。</p><p>**around:**在方法执行之前和之后调用的通知。</p><p><strong>什么是代理?</strong></p><p>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的</p><p><strong>解释基于XMLSchema方式的切面实现。</strong></p><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h4 id="Spring的MVC"><strong>Spring的MVC</strong></h4><hr><p><strong>什么是Spring的MVC框架？</strong></p><p>Spring配备构建Web应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p><p><strong>DispatcherServlet</strong></p><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><p><strong>WebApplicationContext</strong></p><p>WebApplicationContext继承了ApplicationContext并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的servlet。</p><p><strong>什么是SpringMVC框架的控制器？</strong></p><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><p><strong>@Controller注解</strong></p><p>该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用ServletAPI。</p><p><strong>@RequestMapping注解</strong></p><p>该注解是用来映射一个URL到一个类或一个特定的方处理法上。</p><p><strong>返回Json用什么注解？</strong></p><p>@ResponseBody</p><h4 id="Spring事务支持的隔离级别">Spring事务支持的隔离级别</h4><hr><p>Spring 事务上提供以下的隔离级别:</p><ul><li>ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别</li><li>ISOLATION_READ_UNCOMMITTED　: 允许读取未提交的数据变更，可能会导致脏读，幻读或不可重复读</li><li>ISOLATION_READ_COMMITTD : 允许读取为提交数据, 可以阻止脏读，当时幻读或不可重复读仍可能发生</li><li>ISOLATION_REPEATABLE_READ: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生</li><li>ISOLATION_SERIALIZABLE :　完全服从ACID</li></ul>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode SQL 175-185整理</title>
      <link href="/2020/01/26/leetcodeSQL/"/>
      <url>/2020/01/26/leetcodeSQL/</url>
      
        <content type="html"><![CDATA[<p>SQL 例题整理 查询用mysql实现</p><h3 id="175-Combine-Two-Tables组合两个表">175. Combine Two Tables组合两个表</h3><img src="/2020/01/26/leetcodeSQL/sql175.png" alt="sql175" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT P.FirstName, P.LastName, A.City, A.State</span><br><span class="line">FROM Person AS P LEFT JOIN Address AS A</span><br><span class="line">ON P.PersonId &#x3D; A.PersonId;</span><br></pre></td></tr></table></figure><h3 id="176-Second-Highest-Salary-第二高的薪水">176. Second Highest Salary 第二高的薪水</h3><img src="/2020/01/26/leetcodeSQL/sql176.png" alt="sql176" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">select </span><br><span class="line">(SELECT DISTINCT</span><br><span class="line">    Salary </span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">ORDER BY Salary DESC</span><br><span class="line">LIMIT 1 OFFSET 1) as SecondHighestSalary</span><br><span class="line"></span><br><span class="line">2 </span><br><span class="line">select max(salary) as SecondHighestSalary</span><br><span class="line">from employee</span><br><span class="line">where salary &lt; (select max(salary) from employee);</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) AS SecondHighestSalary</span><br></pre></td></tr></table></figure><h3 id="177-Nth-Highest-Salary">177. Nth Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql177.png" alt="sql177" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    declare m int;</span><br><span class="line">    set m &#x3D; n-1;</span><br><span class="line"> RETURN (</span><br><span class="line">   select distinct salary from employee order by salary desc limit m,1</span><br><span class="line"> );</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="178-rank-scores">178.rank scores</h3><img src="/2020/01/26/leetcodeSQL/sql178.png" alt="sql178" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(distinct Score) FROM Scores WHERE Score &gt;&#x3D; s.Score) Rank</span><br><span class="line">FROM Scores s</span><br><span class="line">ORDER BY Score desc</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">  Score,</span><br><span class="line">  (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) as tm WHERE s &gt;&#x3D; Score) as Rank</span><br><span class="line">FROM Scores</span><br><span class="line">ORDER BY Score desc</span><br></pre></td></tr></table></figure><h3 id="180-Consecutive-number">180. Consecutive number</h3><img src="/2020/01/26/leetcodeSQL/sql180.png" alt="sql180" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    l1.Num AS ConsecutiveNums</span><br><span class="line">FROM</span><br><span class="line">    Logs l1,</span><br><span class="line">    Logs l2,</span><br><span class="line">    Logs l3</span><br><span class="line">WHERE</span><br><span class="line">    l1.Id &#x3D; l2.Id - 1</span><br><span class="line">    AND l2.Id &#x3D; l3.Id - 1</span><br><span class="line">    AND l1.Num &#x3D; l2.Num</span><br><span class="line">    AND l2.Num &#x3D; l3.Num</span><br></pre></td></tr></table></figure><h3 id="181-Employees-Earning-More-Than-Their-Managers超过经理收入的员工">181. Employees Earning More Than Their Managers超过经理收入的员工</h3><img src="/2020/01/26/leetcodeSQL/sql181.png" alt="sql181" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT E1.Name AS Employee</span><br><span class="line">FROM Employee AS E1 INNER JOIN Employee AS E2</span><br><span class="line">ON E1.ManagerId &#x3D; E2.Id</span><br><span class="line">WHERE E1.Salary &gt; E2.Salary;</span><br></pre></td></tr></table></figure><h3 id="182-Duplicate-Emails查找重复的电子邮箱">182. Duplicate Emails查找重复的电子邮箱</h3><img src="/2020/01/26/leetcodeSQL/sql182.png" alt="sql182" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email</span><br><span class="line">FROM Person</span><br><span class="line">GROUP BY Email</span><br><span class="line">HAVING COUNT(Id) &gt; 1;</span><br></pre></td></tr></table></figure><h3 id="183-Customers-Who-Never-Order">183. Customers Who Never Order</h3><img src="/2020/01/26/leetcodeSQL/sql183.png" alt="sql183" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select c.name as Customers</span><br><span class="line">from customers as c</span><br><span class="line">where c.id not in (select o.CustomerId from orders as o)</span><br></pre></td></tr></table></figure><h3 id="184-Department-Highest-Salary">184. Department Highest Salary</h3><img src="/2020/01/26/leetcodeSQL/sql184.png" alt="sql184" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    Department.name AS &#39;Department&#39;,</span><br><span class="line">    Employee.name AS &#39;Employee&#39;,</span><br><span class="line">    Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department ON Employee.DepartmentId &#x3D; Department.Id</span><br><span class="line">WHERE</span><br><span class="line">    (Employee.DepartmentId , Salary) IN</span><br><span class="line">    (   SELECT</span><br><span class="line">            DepartmentId, MAX(Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        GROUP BY DepartmentId</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="185-Departement-top-3-salary">185. Departement top 3 salary</h3><img src="/2020/01/26/leetcodeSQL/sql185.png" alt="sql185" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee e1</span><br><span class="line">        inner JOIN</span><br><span class="line">    Department d ON e1.DepartmentId &#x3D; d.Id</span><br><span class="line">WHERE</span><br><span class="line">    3 &gt; (SELECT</span><br><span class="line">            COUNT(DISTINCT e2.Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee e2</span><br><span class="line">        WHERE</span><br><span class="line">            e2.Salary &gt; e1.Salary</span><br><span class="line">                AND e1.DepartmentId &#x3D; e2.DepartmentId</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id></h3>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring, Spring MVC, SpringBoot介绍</title>
      <link href="/2020/01/26/spring/"/>
      <url>/2020/01/26/spring/</url>
      
        <content type="html"><![CDATA[<p>浅谈spring springMVC Springboot三者</p><blockquote><p>The <strong>Spring Framework</strong> is an application framework and inversion of control container for the Java platform. The framework’s core features can be used by any Java application, but there are extensions for building web applications on top of the Java EE (Enterprise Edition) platform. Although the framework does not impose any specific programming model, it has become popular in the Java community as an addition to, or even replacement for the Enterprise JavaBeans (EJB) model. The Spring Framework is open source.</p></blockquote><h4 id="什么是Spring">什么是Spring</h4><p>我们说到Spring，一般指代的是Spring Framework，它是一个开源的应用程序框架，提供了一个简易的开发方式，<strong>通过这种开发方式，将避免那些可能致使代码变得繁杂混乱的大量的业务/工具对象，说的更通俗一点就是由框架来帮你管理这些对象，包括它的创建，销毁等</strong>，比如基于Spring的项目里经常能看到的 <code>Bean</code> ，它代表的就是由Spring管辖的对象。</p><p>而在被管理对象与业务逻辑之间，Spring通过IOC（控制反转）架起使用的桥梁，IOC也可以看做Spring最核心最重要的思想，通过IOC能带来什么好处呢？首先来看一个实际开发中的典型应用场景，假设我们有一个基于MVC分层结构的应用，通过controller层对外提供接口，而通过service层提供具体的实现，在service层中有一个 <code>WelcomeService</code> 服务接口，一般情况下都是通过 <code>WelcomeService service = new WelcomeServiceImpl();</code> 创建实例并进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> WelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后发现一切正常，此时，功能提交，需要进行测试，而由于实际应用环境与测试环境有所区别，需要替换 <code>WelcomeServiceImpl</code> 为一个 <code>MockWelcomeServiceImpl</code> ，以方便测试，怎么办？没有其他办法，只有改代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service = <span class="keyword">new</span> MockWelcomeServiceImpl();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试OK后再将代码改回去，这种方式太过于繁琐，且对代码的侵入性很强；<br>下面看通过Spring的IOC如何实现，首先将 <code>WelcomeService</code> 交由Spring管理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.WelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后在业务代码处通过Spring IOC拿到具体对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WelcomeService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/welcome"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String welcome() &#123;</span><br><span class="line">        <span class="keyword">return</span> service.retrieveWelcomeMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，只需要更改配置文件，将 <code>WelcomeService</code> 对应的实现改为 <code>MockWelcomeServiceImpl</code> 即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"WelcomeService"</span> <span class="keyword">class</span>=<span class="string">"XXX.XXX.XXX.service.impl.MockWelcomeServiceImpl"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这种方式对业务代码没有任何侵入，<strong>它有效的实现松耦合</strong>，大家都知道紧耦合的代码是业务发展的噩梦；同时，Spring IOC提供的远不止这些，如通过单例减少创建无用的对象，通过延迟加载优化初始化成本等</p><p><strong>纵览Spring的结构，你会发现Spring Framework 本身并未提供太多具体的功能，它主要专注于让你的项目代码组织更加优雅，使其具有极好的灵活性和扩展性，同时又能通过Spring集成业界优秀的解决方案</strong></p><h4 id="什么是Spring-MVC？">什么是Spring MVC？</h4><p>Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件），<strong>主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易</strong>，一个典型的Spring MVC应用开发分为下面几步：<br>首先通过配置文件声明Dispatcher Servlet：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.qgd.oms.web.common.mvc.OmsDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过配置文件声明servlet详情，如MVC resource，data source，bean等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/css/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">location</span>=<span class="string">"/static/views/"</span> <span class="attr">cache-period</span>=<span class="string">"21600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/fonts/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/js/lib/ueditor/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/**/*"</span> <span class="attr">location</span>=<span class="string">"/static/img/"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.validationQuery&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultAutoCommit"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxOpenPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"configService"</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.ConfigService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configStore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.qgd.oms.web.common.service.impl.DbConfigStore"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskScheduler"</span> <span class="attr">ref</span>=<span class="string">"defaultScheduler"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"refreshInterval"</span> <span class="attr">value</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若需添加其它功能，如security，则需添加对应配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/css/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/js/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/views/**/*.html"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/fonts/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/ueditor/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">pattern</span>=<span class="string">"/img/**/*"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">use-expressions</span>=<span class="string">"true"</span> <span class="attr">entry-point-ref</span>=<span class="string">"omsAuthenticationEntryPoint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logout</span> <span class="attr">logout-url</span>=<span class="string">"/omsmc/authentication/logout/*"</span> <span class="attr">success-handler-ref</span>=<span class="string">"omsLogoutSuccessHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">logout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/omsmc/authentication/login*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/ms/**/*'</span> <span class="attr">access</span>=<span class="string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">'/**'</span> <span class="attr">access</span>=<span class="string">"authenticated"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;security:form-login /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-filter</span> <span class="attr">ref</span>=<span class="string">"omsUsernamePasswordAuthenticationFilter"</span> <span class="attr">position</span>=<span class="string">"FORM_LOGIN_FILTER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remember-me</span> <span class="attr">services-ref</span>=<span class="string">"omsRememberMeServices"</span> <span class="attr">key</span>=<span class="string">"yfboms"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure><p>增加业务代码，如controller，service，model等，最后生成war包，通过容器进行启动</p><h4 id="什么是Spring-Boot？">什么是Spring Boot？</h4><p>初期的Spring通过代码加配置的形式为项目提供了良好的灵活性和扩展性，但随着Spring越来越庞大，其配置文件也越来越繁琐，太多复杂的xml文件也一直是Spring被人诟病的地方，特别是近些年其他简洁的WEB方案层出不穷，如基于Python或Node. Js，几行代码就能实现一个WEB服务器，对比起来，大家渐渐觉得Spring那一套太过繁琐，此时，Spring社区推出了Spring Boot，它的目的在于<strong>实现自动配置，降低项目搭建的复杂度</strong>，如需要搭建一个接口服务，通过Spring Boot，几行代码即可实现，请看代码示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入spring-boot-starter-web依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-starter-web&lt;/</span>artifactId&gt;</span><br><span class="line">&lt;<span class="regexp">/dependency&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明Spring Boot应用，直接写业务逻辑即可</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"how are you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MockServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为 <code>spring-boot-starter-web</code> 模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是<strong>约定优于配置</strong>原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，Spring Boot一样支持</p><p>在Spring Boot中，你会发现你引入的所有包都是<em>starter</em>形式，如：</p><ul><li><code>spring-boot-starter-web-services</code> ，针对SOAP Web Services</li><li><code>spring-boot-starter-web</code> ，针对Web应用与网络接口</li><li><code>spring-boot-starter-jdbc</code> ，针对JDBC</li><li><code>spring-boot-starter-data-jpa</code> ，基于hibernate的持久层框架</li><li><code>spring-boot-starter-cache</code> ，针对缓存支持</li></ul><p>Spring Boot对starter的解释如下：</p><blockquote><p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</p></blockquote><h1>Spring，Spring MVC，Spring Boot 三者比较</h1><p>其实写到这里，很多读者应该已经清楚，这三者专注的领域不同，解决的问题也不一样；总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能，下面用一张图来描述三者的关系：</p><img src="/2020/01/26/spring/mvc_spring_boot.png" alt="mvc_spring_boot" style="zoom:33%;"><p>最后一句话总结：<strong>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql高频概念</title>
      <link href="/2020/01/25/sqlExecuteProcess/"/>
      <url>/2020/01/25/sqlExecuteProcess/</url>
      
        <content type="html"><![CDATA[<h4 id="SQL">SQL</h4><blockquote><p>SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system.</p></blockquote><h4 id="sql语法的分析是从右到左">sql语法的分析是从右到左</h4><p>1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。<br>2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。<br>3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。<br>5）选择优化器，不同的优化器一般产生不同的“执行计划”<br>6）选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。<br>7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。<br>8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>9）运行“执行计划”</p><h4 id="select-语句执行顺序">select 语句执行顺序</h4><p>1 from子句组装来自不同数据源的数据；</p><p>2 where子句基于指定的条件对记录行进行筛选；</p><p>3 group by子句将数据划分为多个分组；</p><p>4 使用聚集函数进行计算；</p><p>5 使用having子句筛选分组；</p><p>6 计算所有的表达式；</p><p>7 select 的字段；</p><p>8 使用order by对结果集进行排序。<br>SQL语言不同于其他编程语言的最明显特征是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语句中，第一个被处理的子句式FROM，而不是第一出现的SELECT。SQL查询处理的步骤序号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)SELECT (9) DISTINCT (11) &lt;TOP_specification&gt; &lt;select_list&gt;</span><br><span class="line">(1)  FROM &lt;left_table&gt;</span><br><span class="line">(3) &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(2) ON &lt;join_condition&gt;</span><br><span class="line">(4) WHERE &lt;where_condition&gt;</span><br><span class="line">(5) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6) WITH &#123;CUBE | ROLLUP&#125;</span><br><span class="line">(7) HAVING &lt;having_condition&gt;</span><br><span class="line">(10) ORDER BY &lt;order_by_list&gt;</span><br></pre></td></tr></table></figure><h4 id="where与having的区别">where与having的区别</h4><p>对需要进行分组的数据进行限制，汇总函数不能用在 WHERE 子句中，而是要用HAVING 子句 。HAVING子句允许你将汇总函数作为条件。</p><h4 id="UNION与UNION-ALL合并">UNION与UNION ALL合并</h4><p>UNION将返回两个查询的结果并去除其中的重复部分，UNION ALL与UNION一样对表进行了合并，但是它不去掉重复的记录。</p><h4 id="数据定义语言">数据定义语言</h4><p>Data definition language</p><blockquote><p>A <strong>data definition</strong> or <strong>data description language</strong> (<strong>DDL</strong>) is a syntax similar to a computer <a href="https://en.wikipedia.org/wiki/Programming_language" target="_blank" rel="noopener">programming language</a> for defining <a href="https://en.wikipedia.org/wiki/Data_structure" target="_blank" rel="noopener">data structures</a>, especially <a href="https://en.wikipedia.org/wiki/Database_schema" target="_blank" rel="noopener">database schemas</a>. DDL statements create and modify database objects such as tables, indexes, and users. Common DDL statements are CREATE, ALTER, and DROP</p></blockquote><p>类似于我们编程的数据结构，用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束，DDL不需要commit.</p><h4 id="数据操作语言">数据操作语言</h4><p><strong>DML</strong>（<strong>Data Manipulation Language</strong>）<strong>数据操纵语言</strong>statements are used for managing data within schema objects.</p><p>由DBMS提供，用于让用户或程序员使用，实现对数据库中数据的操作。<br>DML分成交互型DML和嵌入型DML两类。<br>依据语言的级别，DML又可分成过程性DML和非过程性DML两种。<br>需要commit.<br>SELECT<br>INSERT<br>UPDATE<br>DELETE<br>MERGE<br>CALL<br>EXPLAIN PLAN<br>LOCK TABLE</p><h4 id="数据库控制语言"><strong>数据库控制语言</strong></h4><p><strong>DCL</strong>（<strong>Data Control Language</strong>）<strong>数据库控制语言</strong> 授权，角色控制等<br>GRANT 授权<br>REVOKE 取消授权</p><h4 id="TCL-（Transaction-Control-Language）-事务控制语言">TCL**（<strong>Transaction Control Language</strong>）**事务控制语言</h4><p>SAVEPOINT 设置保存点<br>ROLLBACK 回滚<br>SET TRANSACTION</p><h4 id="Turncate-和-drop">Turncate 和 drop</h4><p>turncate只删除表中的数据，不触碰表的结构。drop删除整个表，<strong>小心使用drop与turncate，因为他们是数据定义语言，不能roll back</strong></p><h4 id="MINUS相减">MINUS相减</h4><p>返回的记录是存在于第一个表中但不存在于第二个表中的记录。如果解释器不支持一般用table_name1 t2 LEFT OUTER JOIN table_name2 t2 WHERE t2.col_name IS NULL;</p><h4 id="关于空值【高频】"><strong>关于空值【高频】</strong></h4><p>SQL中的空值是NULL，空值是不能用等号来比较的，而是要用IS NULL或者IS NOT NULL来判断值是否为空值。</p><p>面试的时候往往需要在输出结果中对空值进行处理，这时候最好用的就是IFNULL函数和ISNULL函数了。<strong>IFNULL</strong>是当SQL查询某个字段为空的时候，查询结果中设置其值为默认值。<strong>ISNULL</strong>使用指定的替换值替换 NULL：<br>ISNULL (检查的对象, 如果为空值替换的值)</p><p>可惜，MySQL中ISNULL只是用来判断是否为空，不能实现替换功能，所以用IFNULL代替，语法和上面的ISNULL一样。</p><h4 id="返回前几行【高频】"><strong>返回前几行【高频】</strong></h4><p>MySQL的LIMIT+数字和TOP子句是等价的，并非所有的数据库系统都支持 TOP 子句。所以我们来简单看一下limit+offset的用法。以下这两句都合乎语法，但是有区别：</p><p>select * from table_name limit 3,1;        # 跳过前3条数据，从数据库中第4条开始查询，取一条数据，即第4条数据<br>select * from table_name limit 3 offset 1;   # 从数据库中的第2条数据开始查询3条数据，即第2条到第4条</p><p>记住这两句，再加上order by column_name (desc) 就能应付“消费第二多的客户”、“点击量第5到20名”之类的问题的。</p><h4 id="条件语句【中频】"><strong>条件语句【中频】</strong></h4><p>条件语句考得并不多，但是如果很久不用MySQL就容易忘记。MySQL里常用的条件语句是Case。Case语句分为两种：简单Case函数和Case搜索函数。</p><p>- 简单Case函数：<br>CASE gender WHEN ‘0’ THEN ‘male’ WHEN ‘1’ THEN ‘female’ ELSE ‘others’ END<br>- Case搜索函数：<br>CASE WHEN age &lt; 18 THEN ‘未成年人’ WHEN age &lt; 60 THEN ‘成年人’ ELSE ‘老年人’ END</p><p>Case语句只返回第一个符合条件的结果，剩下的条件会被自动忽略，比如上例中一个数据的age为16，那么它就在第一个case中被返回，不会进入第二个when中进行判断，因此返回’未成年人’而不是’成年人’。</p><h4 id="随机抽样【低频】"><strong>随机抽样【低频】</strong></h4><p>有时候面试会考到如何在SQL表中随机抽样，这时候就要用到RAND()函数。</p><p>通常被面试者的第一反应是：SELECT * FROM table ORDER BY RAND() LIMIT 10000，这样来抽取一万个样本。但是如果数据量很大，上述的做法太慢了：它对于每一行都用了RAND()函数，这一步复杂度是O(n)；然后再排序，这一步的复杂度O(nlogn)。</p><p>所以可以改用这个方法：SELECT * FROM table WHERE RAND() &lt;= .3，这样可以抽出约30%的数据，然后再用TOP或者LIMIT子句。</p><h4 id="自然连接和内链接区别">自然连接和内链接区别</h4><p>自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列，但是相同列的数量不能大于1</p><h4 id="subquery和join的对比">subquery和join的对比</h4><p>与子查询相比，join的查询效率还是比子查询高，因为使用子查询时，数据库还要建一张临时表</p><h4 id="子查询执行顺序">子查询执行顺序</h4><p>带有子查询时，先执行子查询在执行主查询</p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20道SQL 面试题帮你拿到第一个offer</title>
      <link href="/2020/01/25/sql20questions/"/>
      <url>/2020/01/25/sql20questions/</url>
      
        <content type="html"><![CDATA[<h3 id="基本语法">基本语法</h3><p><strong>创建表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE table_name (</span><br><span class="line"> column1 datatype null or not null(optional),</span><br><span class="line"> column2 datatype null or not null(optional),</span><br><span class="line"> column3 datatype null or not null(optional),</span><br><span class="line">  ....</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure><p><strong>删除表中数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure><p><strong>修改：添加列，删除列，修改列名，数据类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ADD column_name datatype;</span><br><span class="line"></span><br><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">DROP COLUMN DateOfBirth;</span><br><span class="line"></span><br><span class="line">-- 修改列名</span><br><span class="line">alter table table_name </span><br><span class="line">rename column oldname to newname</span><br><span class="line"></span><br><span class="line">-- 修改列的数据类型</span><br><span class="line">ALTER TABLE table_name</span><br><span class="line">ALTER COLUMN column_name datatype;</span><br></pre></td></tr></table></figure><h4 id="常见问题">常见问题</h4><p><strong>1 查询姓“孟”老师的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(教师号)</span><br><span class="line">from teacher</span><br><span class="line">where 教师姓名 like &#39;孟%&#39;;</span><br></pre></td></tr></table></figure><p><strong>2 查询课程编号为“0002”的总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sum(成绩)</span><br><span class="line">from score</span><br><span class="line">where 课程号 &#x3D; &#39;0002&#39;;</span><br></pre></td></tr></table></figure><p><strong>3 查询选了课程的学生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct 学号) as 学生人数 </span><br><span class="line">from score;</span><br></pre></td></tr></table></figure><h4 id="练习-分组">练习 分组</h4><p><strong>4 查询各科成绩最高和最低的分， 以如下的形式显示：课程号，最高分，最低分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号,max(成绩) as 最高分,min(成绩) as 最低分</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>5 查询每门课程被选修的学生</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, count(学号)</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p><strong>6 查询男生、女生人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 性别,count(*)</span><br><span class="line">from student</span><br><span class="line">group by 性别;</span><br></pre></td></tr></table></figure><h4 id="分组结果的条件">分组结果的条件</h4><p><strong>注意使用group by  having</strong></p><p><strong>7 查询平均成绩大于60分学生的学号和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, avg(成绩)</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having avg(成绩)&gt;60;</span><br></pre></td></tr></table></figure><p><strong>8 查询student表中重名的学生，结果包含id和name，按name, id升序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,name</span><br><span class="line">from student</span><br><span class="line">where name in (</span><br><span class="line">select name from student group by name having(count(*) &gt; 1)</span><br><span class="line">) order by name;</span><br></pre></td></tr></table></figure><p><strong>9 在student_course表中查询平均分不及格的学生，列出学生id和平均分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sid,avg(score) as avg_score</span><br><span class="line">from student_course</span><br><span class="line">group by sid having(avg_score&lt;60);</span><br></pre></td></tr></table></figure><p><strong>10 查询至少选修两门课程的学生学号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学号, count(课程号) as 选修课程数目</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><p><strong>11查询不及格的课程并按课程号从大到小排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号 </span><br><span class="line">from score </span><br><span class="line">where score &lt; 60 </span><br><span class="line">group by 课程号desc</span><br></pre></td></tr></table></figure><p><strong>12 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 课程号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">group by 课程号</span><br><span class="line">order by 平均成绩 asc,课程号 desc;</span><br></pre></td></tr></table></figure><p><strong>13 查询两门以上不及格课程的同学的学号及其平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号， avg（成绩） as 平均成绩</span><br><span class="line">from score</span><br><span class="line">where score &lt; 60</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;&#x3D;2;</span><br></pre></td></tr></table></figure><h4 id="复杂查询-子查询">复杂查询 : 子查询</h4><p><strong>14 查询所有课程成绩小于60分学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in （ select 学号</span><br><span class="line">from student</span><br><span class="line">where score &lt; 60)</span><br></pre></td></tr></table></figure><p><strong>15 查询没有学全所有课的学生的学号、姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号) &lt; (select count(课程号) from course))</span><br></pre></td></tr></table></figure><p><strong>16 查询出只选修了两门课程的全部学生的学号和姓名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 学号，姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from course</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&#x3D;2）;</span><br></pre></td></tr></table></figure><h4 id="多表查询">多表查询</h4><h5 id="区分概念">区分概念</h5><p>表A记录如下：</p><p>aID　　　　　aNum<br>1　　　　　a20050111<br>2　　　　　a20050112<br>3　　　　　a20050113<br>4　　　　　a20050114<br>5　　　　　a20050115</p><p>表B记录如下:<br>bID　　　　　bName<br>1　　　　　2006032401<br>2　　　　　2006032402<br>3　　　　　2006032403<br>4　　　　　2006032404<br>8　　　　　2006032408</p><p><strong>nature join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from A,B</span><br><span class="line">where A.aID &#x3D; B.bId</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>inner join</strong></p><img src="/2020/01/25/sql20questions/innerjoin.png" alt="innerjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">innerjoin B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404</p><p><strong>left join</strong></p><img src="/2020/01/25/sql20questions/leftjoin.png" alt="leftjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">left join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL</p><p><strong>right join</strong></p><img src="/2020/01/25/sql20questions/rightjoin.png" alt="rightjoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">right join B</span><br><span class="line">on A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>结果如下:<br>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>NULL　　　　　NULL　　　　　8　　　　　2006032408</p><p><strong>full join</strong></p><img src="/2020/01/25/sql20questions/fulljoin.png" alt="fulljoin" style="zoom:33%; "><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM A</span><br><span class="line">FULL OUTER JOIN B</span><br><span class="line">ON A.aID &#x3D; B.bID</span><br></pre></td></tr></table></figure><p>aID　　　　　aNum　　　　　bID　　　　　bName<br>1　　　　　a20050111　　　　1　　　　　2006032401<br>2　　　　　a20050112　　　　2　　　　　2006032402<br>3　　　　　a20050113　　　　3　　　　　2006032403<br>4　　　　　a20050114　　　　4　　　　　2006032404<br>5　　　　　a20050115　　　　NULL　　　　　NULL　　　　　NULL　　　　NULL　　　　　82006032408</p><p><strong>17 查询所有学生的学号、姓名、选课数、总成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selecta.学号,a.姓名,count(b.课程号) as 选课数,sum(b.成绩) as 总成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号;</span><br></pre></td></tr></table></figure><p><strong>18 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select a.学号,a.姓名, avg(b.成绩) as 平均成绩</span><br><span class="line">from student as a </span><br><span class="line">left join score as b on a.学号 &#x3D; b.学号</span><br><span class="line">group by a.学号</span><br><span class="line">having avg(b.成绩)&gt;85;</span><br></pre></td></tr></table></figure><p><strong>19 查询学生的选课情况：学号，姓名，课程号，课程名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.学号, a.姓名, c.课程号,c.课程名称</span><br><span class="line">from student a inner join score b on a.学号&#x3D;b.学号</span><br><span class="line">inner join course c on b.课程号&#x3D;c.课程号;</span><br></pre></td></tr></table></figure><p><strong>20 查询出每门课程的及格人数和不及格人数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select 课程号,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 及格人数,</span><br><span class="line">sum(case when 成绩 &lt;  60 then 1 </span><br><span class="line"> else 0 </span><br><span class="line">    end) as 不及格人数</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure><p>使用分段[100-85], [85-70], [70-60], [&lt;60]来统计各科成绩，分别统计：各分数段人数，课程号和课程名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select a.课程号,b.课程名称,</span><br><span class="line">sum(case when 成绩 between 85 and 100 </span><br><span class="line"> then 1 else 0 end) as &#39;[100-85]&#39;,</span><br><span class="line">sum(case when 成绩 &gt;&#x3D;70 and 成绩&lt;85 </span><br><span class="line"> then 1 else 0 end) as &#39;[85-70]&#39;,</span><br><span class="line">sum(case when 成绩&gt;&#x3D;60 and 成绩&lt;70  </span><br><span class="line"> then 1 else 0 end) as &#39;[70-60]&#39;,</span><br><span class="line">sum(case when 成绩&lt;60 then 1 else 0 end) as &#39;[&lt;60]&#39;</span><br><span class="line">from score as a right join course as b </span><br><span class="line">on a.课程号&#x3D;b.课程号</span><br><span class="line">group by a.课程号,b.课程名称;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始手把手教大家如何制作网站（进阶版）</title>
      <link href="/2020/01/18/setupSiteImprove/"/>
      <url>/2020/01/18/setupSiteImprove/</url>
      
        <content type="html"><![CDATA[<p>第一次知道hexo，next风格是在刷算法题时看一些回复，然后无意中看到了一个名为<a href="https://tding.top/" target="_blank" rel="noopener">小丁的博客</a>的网站，对比了一下他和我最初自己写blog网站，感觉自己的low爆了，于是就决定去重新做一个炫酷的</p><img src="/2020/01/18/setupSiteImprove/ding.png" alt="ding" style="zoom:33%; "><p>通过上一片文章，我们对hexo博客框架有了基本的认识，然而要想做出一些炫酷的效果，我们可以从这一篇文章中找到自己想要的摘取</p><h4 id="附加选项">附加选项</h4><p>1 动态背景</p><p>2 鼠标点击气球爆炸效果</p><p>3 右上角加加入github装横</p><p>4 RSS xml 全览</p><p>5 小图标链接</p><p>6 加入订阅 打赏功能</p><p>7 评论功能</p><p>8 个性化侧边栏</p><p>9 原创声明</p><p>10 网站访问量人数，次数，阅读数统计</p><h4 id="1-动态背景">1 动态背景</h4><p><strong>具体实现方法</strong></p><p>注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格）<br>打开 /next/_config.yml, 在里面添加如下代码：(可以放在最后面)</p><p>打开 <code>/next/_config.yml</code> , 在里面添加如下代码：(可以放在最后面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># --------------------------------------------------------------</span><br><span class="line"># background settings</span><br><span class="line"># --------------------------------------------------------------</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https:&#x2F;&#x2F;github.com&#x2F;hustcc&#x2F;canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure><p><strong>实现效果图</strong></p><p><a href="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/5308475-ef603580be708882.gif?imageMogr2/auto-orient/strip" alt="img"></a></p><p><strong>如果你感觉默认的线条太多的话 可以这么设置</strong></p><p>在上一步修改 <code>_layout.swig</code> 中，把刚才的这些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;</span><br><span class="line">color&#x3D;&quot;0,0,255&quot; opacity&#x3D;&#39;0.7&#39; zIndex&#x3D;&quot;-2&quot; count&#x3D;&quot;99&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>配置项说明</strong></p><ul><li><code>color</code> ：线条颜色, 默认: <code>'0,0,0'</code> ；三个数字分别为(R, G, B)</li><li><code>opacity</code> : 线条透明度（0~1）, 默认: <code>0.5</code></li><li><code>count</code> : 线条的总数量, 默认: <code>150</code></li><li><code>zIndex:</code> 背景的z-index属性，css属性用于控制所在层的位置, 默认: <code>-1</code></li></ul><h4 id="2-鼠标点击气球爆炸效果">2 鼠标点击气球爆炸效果</h4><img src="/2020/01/18/setupSiteImprove/ballon.png" alt="ballon" style="zoom:33%; "><p><strong>具体实现方法</strong></p><p>首先在 <code>themes/next/source/js/src</code> 里面建一个叫fireworks.js的文件，然后粘贴如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;;</span><br></pre></td></tr></table></figure><p>打开 <code>themes/next/layout/_layout.swig</code> , 在最底部的 <code>&lt;/body&gt;</code> 上面粘贴如下如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.fireworks %&#125;</span><br><span class="line">   &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>打开主题配置文件，在里面最后写下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Fireworks</span><br><span class="line">fireworks: true</span><br></pre></td></tr></table></figure><h4 id="3-右上角加加入github装横">3 右上角加加入github装横</h4><h4 id="img-src-hautdroite-png-alt-hautdroite-style-zoom-50"><img src="/2020/01/18/setupSiteImprove/hautdroite.png" alt="hautdroite" style="zoom:50%; "></h4><p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">这里</a>挑选自己喜欢的样式，然后复制代码：</p><p>我自己选择的是这个样式：</p><img src="/2020/01/18/setupSiteImprove/folkgithub.png" alt="folkgithub" style="zoom:50%; "><p>然后粘贴刚才复制的代码到 <code>themes/next/layout/_layout.swig</code> 文件中(放在<code> </code>的下面)，并把<code> href</code>改为你的github地址, 例如我的<em>github链接是</em>： <strong><a href="https://github.com/wuhewuhe" target="_blank" rel="noopener">https://github.com/wuhewuhe</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe&quot; class&#x3D;&quot;github-corner&quot; aria-label&#x3D;&quot;View source on GitHub&quot;&gt;&lt;svg width&#x3D;&quot;80&quot; height&#x3D;&quot;80&quot; viewBox&#x3D;&quot;0 0 250 250&quot; style&#x3D;&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;path d&#x3D;&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill&#x3D;&quot;currentColor&quot; style&#x3D;&quot;transform-origin: 130px 106px;&quot; class&#x3D;&quot;octo-arm&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill&#x3D;&quot;currentColor&quot; class&#x3D;&quot;octo-body&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;&#x2F;a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h4 id="4-RSS-xml-全览">4 RSS xml 全览</h4><img src="/2020/01/18/setupSiteImprove/rss.png" alt="rss" style="zoom:50%; "><p><strong>具体实现</strong></p><p>安装 Hexo 插件：(这个插件会放在 <code>node_modules</code> 这个文件夹里)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>进入根目录下的*_config.yml*, 修改如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line"></span><br><span class="line">## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line"></span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p>然后打开next主题文件夹里面的 <code>_config.yml</code> , 在里面配置为如下样子：(就是在 <code>rss:</code> 的后面加上 <code>/atom.xml</code> , <strong>注意</strong>在冒号后面要加一个空格)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&#39;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure><p>配置完之后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>重新生成一次，你会在 <code>./public</code> 文件夹中看到 <code>atom.xml</code> 文件</p><h4 id="5-小图标链接">5 小图标链接</h4><img src="/2020/01/18/setupSiteImprove/icon.png" alt="icon" style="zoom:50%; "><p><strong>具体实现</strong></p><p>编辑Next主题下的_config.yml文件，next主题对应四种不同的布局Muse是紧凑型，Mist的默认sidebar在上面，Pisces和Gemini除了sidebar位置没发现特别大的区别。我习惯把菜单栏放在左边，所以用了Gemini的sechema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><p>然后找到下面的<em>social link</em>选项，进行如下格式编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe || github</span><br><span class="line">  E-Mail: mailto:dachichiwuhe@gmail.com || envelope</span><br><span class="line">  Linkedin: https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;he-wu-15321b137&#x2F; ||  linkedin</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100013356700523 || facebook</span><br><span class="line">  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  YouTube: https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC3brgfzjExkGq-qkp3vNNrw || youtube</span><br><span class="line">  Instagram: https:&#x2F;&#x2F;www.instagram.com&#x2F;wu.6971&#x2F; || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><p>||的意思是前面为对应链接，后面为图标</p><p>最后设置下面的social icon</p><p>social_icons:<br>enable: true<br>icons_only: false<br>transition: false</p><h4 id="6-加入订阅打赏功能">6 加入订阅打赏功能</h4><img src="/2020/01/18/setupSiteImprove/donate.png" alt="donate" style="zoom:33%;"><p>如果大家使用的next主题5.1版本之上的的话，那么编辑next下的_config.yml文件如下：</p><h1>Wechat Subscriber</h1><p>wechat_subscriber:<br>enabled: true<br>qcode: /images/wechat-qrcode.png<br>description: subscribe to my blog by scanning my public wechat account</p><h1>Reward</h1><p>reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！<br>wechatpay: /images/wechat.jpeg<br>alipay: /images/ali.jpeg<br>#bitcoin: /images/bitcoin.png</p><p>添加自己微信二维码照片到next下的images文件下，然后修改相应的提示语</p><img src="/2020/01/18/setupSiteImprove/images.png" alt="images" style="zoom:33%;"><h4 id="7-评论功能">7 评论功能</h4><img src="/2020/01/18/setupSiteImprove/Comments.png" alt="Comments" style="zoom:33%;"><p>这个功能有不同的实现方法和插件，像valine，gitment，gitalk，那么以我为准，我就讲我的方法(<strong>很不幸的发现现在很久没人维护，不能使用了</strong>)</p><blockquote><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p></blockquote><p><strong>使用 <code>Gitment</code></strong></p><ul><li><p>首先要有github帐号</p></li><li><p>接着<a href="https://github.com/settings/profile" target="_blank" rel="noopener">注册 OAuth Application</a></p><img src="/2020/01/18/setupSiteImprove/ouath.png" alt="ouath" style="zoom:33%;"></li><li><p>要确保填入正确的 callback URL（一般是网站的域名，如 <a href="https://wuhewuhe.github.io/">https://wuhewuhe.github.io/</a>)</p></li><li><p>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。</p></li><li><p>这个页面，你还可以知道application拥有者：owner</p></li></ul><p>打开Next主题的 <code>_config.yml</code> 文件, 在评论相关设置的区域添加下面的代码, 并根据 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment 文档</a>说明来添加相应的值</p><img src="/2020/01/18/setupSiteImprove/gitment.png" alt="gitment" style="zoom:33%;"><p>确认 <code>next/layout/_partials/comments.swig</code> 是否有如下代码：</p><img src="/2020/01/18/setupSiteImprove/comment.png" alt="comment" style="zoom:50%;"><h4 id="8-个性化侧边栏">8 个性化侧边栏</h4><img src="/2020/01/18/setupSiteImprove/sidebar.png" alt="sidebar" style="zoom:33%;"><p><strong>具体实现</strong></p><p>我们可以根据自己需要添加左侧menu，比如我自定义about，photo和commonweal三个界面</p><p>首先，编辑next主题下的_config.yml文件，</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> </span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> </span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> </span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> </span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || /sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> </span><br><span class="line">  <span class="comment">#top: /top/ || signal</span></span><br><span class="line">  <span class="attr">photo:</span> <span class="string">/photo/</span></span><br></pre></td></tr></table></figure><p>然后分别生成三个文章，注意关掉评论，没有分类和标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n 404</span><br><span class="line">hexo n about</span><br><span class="line">hexo n photo</span><br></pre></td></tr></table></figure><h4 id="9-原创声明">9 原创声明</h4><img src="/2020/01/18/setupSiteImprove/invent.png" alt="invent" style="zoom:50%; "><p><strong>具体实现</strong></p><p>在目录 <code>next/layout/_macro/下</code> 添加 <code>my-copyright.swig</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;post-copyright&quot;&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-author&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.author&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; post.author | default(config.author) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-link&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.link&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&quot;post-copyright-license&quot;&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(&#39;post.copyright.license_title&#39;) + __(&#39;symbol.colon&#39;) &#125;&#125; &lt;&#x2F;strong&gt;</span><br><span class="line">    &#123;&#123; __(&#39;post.copyright.license_content&#39;, theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，post的预定义link是用的根目录下的url所以需要确定url对应的是自己的网站地址：如下图所示：</p><img src="/2020/01/18/setupSiteImprove/post_url.png" alt="post_url" style="zoom:50%; "><p>然后编辑next主题下的_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;3.0&#x2F;</span><br></pre></td></tr></table></figure><h4 id="10-网站访问量人数，次数，阅读数统计">10 网站访问量人数，次数，阅读数统计</h4><img src="/2020/01/18/setupSiteImprove/visit.png" alt="visit" style="zoom:45%; "><p><strong>具体实现</strong></p><p>关于网站访问人数这块我也是踩过很多的雷，出现了好几次改了之后没效果的情况，这里我为大家一一细说。</p><p><strong>改法1</strong> 使用next主题 5.1版本以上</p><p>打开主题的配置文件 <code>/theme/next/_config.yml</code> ，找到如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: false</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 的值由 <code>false</code> 改为 <code>true</code> ，便可以看到页脚出现访问量，上述配置表示：</p><ul><li><p><code>site_uv</code> 表示是否显示整个网站的UV数</p></li><li><p><code>site_pv</code> 表示是否显示整个网站的PV数</p></li><li><p><code>page_pv</code> 表示是否显示每个页面的PV数</p></li></ul><p>表示是否显示每个页面的PV数</p><p>当然，对于不蒜子的配置可以随意更改，一下附上本人的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: 访客数</span><br><span class="line">  site_uv_footer: 人</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: 总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;  阅读数</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>使用 <code>hexo s</code> 部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用 <code>localhost:4000</code> 进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p><p><strong>改法2</strong> 引用busuanzi脚本 同用法通用法</p><p>要使用不蒜子必须在页面中引入 <code>busuanzi.js</code> ，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>本人使用的是next主题，所以在 <code>themes/next/layout/_third-party/analytic/busuanzi-count.swig</code> 中添加上述脚本，也可以把脚本添加在footer或者header中，如果使用的是其他主题，大致也是一样的，不过可能后缀是ejs，没有影响。</p><figure class="highlight plain"><figcaption><span>*if* theme.busuanzi_count.site_uv %&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;span *class*&#x3D;&quot;site-uv&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125;</span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.site_pv %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;span *class*&#x3D;&quot;site-pv&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">     &#123;&#123; theme.busuanzi_count.site_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br><span class="line"></span><br><span class="line"> &#123;% *if* theme.busuanzi_count.page_pv %&#125;</span><br><span class="line"></span><br><span class="line">   &lt;span *class*&#x3D;&quot;page_pv&quot;&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_header&#125;&#125; </span><br><span class="line"></span><br><span class="line">     &lt;span *class*&#x3D;&quot;busuanzi-value&quot; *id*&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &#123;&#123; theme.busuanzi_count.page_pv_footer&#125;&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% *endif* %&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>hexo确实是一个功能很强大，高度集成的框架，插件非常多，像我使用过的还有热度搜索，文章推荐，文章链接等，大家可以去<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>一一探索, 网站支持中文确实方便大家阅读。以上两篇文章是我自己的学习笔记，也同样是我对hexo的一点点小小见解</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始手把手教大家如何制作网站（基础版）</title>
      <link href="/2020/01/15/how-to-setup-site/"/>
      <url>/2020/01/15/how-to-setup-site/</url>
      
        <content type="html"><![CDATA[<p>随着互联网浪潮的翻腾，国内外涌现出越来越多优秀的网站，自媒体人，blog。他们凭借这自己独到的见解，以及在某一方面的建树，瞬间圈粉，成为了我们所谓的网红。如果你是一个不甘寂寞的人，那么你可曾想过做一个属于自己的网站。</p><p>很多人觉着做一个网站是一个很繁琐的过程，从域名，到服务器，再到各种协议，前端，后台，数据库，测试，上线部署… . 以上都是大型的企业级项目，其实如果我们很好的借助现成的工具，那么无论你是不是计算机专业，懂不懂编代码，记住几条命令，改一些配置，不花一分钱，你就拥有属于自己的个性化网站。</p><h4 id="工具">工具</h4><p>hexo 框架, Next主题，github服务器，markdown编辑器</p><p>以上这四个工具，就足够我们做出一个精美的网站。</p><h4 id="Hexeo">Hexeo</h4><img src="/2020/01/15/how-to-setup-site/Hexo.jpg" alt="Hexo" style="zoom:25%; "><blockquote><blockquote><p><em>Hexo</em> is a fast, simple &amp; powerful <em>blog</em> framework powered by Node.js.</p></blockquote></blockquote><p>这是hexo官网给出的简介，确实hexo是全球最大的同性恋网站，但是其也是一个由node js编写的，非常快捷好用的博客协同框架。其优点就是：</p><ul><li>部署简单 ： 一条指令就完成</li><li>速度快： 快速生成文章，渲染几百个页面几秒钟搞定</li><li>开源 ：非常多的插件，强大的api，庞大的讨论区</li><li>支持markdow语法 ： 之前写过一期md语法的介绍，高效书写，很好的和github，简书兼容</li></ul><p>读完本文，实践作出一个属于自己的网站，你就会发现hexo的优点。</p><h5 id="hexo-基本操作">hexo 基本操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo -version #查看版本</span><br><span class="line">hexo clean #清空</span><br><span class="line">hexo g #generate 生成</span><br><span class="line">hexo s #server 本地调试</span><br><span class="line">hexo d #deploy 部署</span><br><span class="line">hexo list &lt;type&gt; #列出资料 page，tags，categories</span><br><span class="line">hexo --save #安全模式 遇到问题重新执行</span><br><span class="line">hexo --debug #debug 显示log</span><br><span class="line">hexo --silent</span><br></pre></td></tr></table></figure><h4 id="Github">Github</h4><img src="/2020/01/15/how-to-setup-site/github.png" alt="github" style="zoom:20%; "><p>Github，想起了一句忘记从哪里听到的话<strong>你和大神之间就只差一个github</strong>，他本来就是一个托管代码的大仓库，相信每一个程序的新手毕竟之路都是有github的陪伴，有了他我们再也不用担心不小心删了代码，或者把某一个地方改崩了，大家还能协同开发各司其职。同时git也是github的唯一版本库管理工具，我也专门做了一起git的使用从进阶到入门，感兴趣的小伙伴可以在往期内容查看。当然github也分为个人和企业，收费与免费版，github的初衷就是开源，大家都可以看到源代码，做出自己的贡献，有很多炙手可热，家喻户晓的项目都在github上开源：</p><ul><li>React ReactMobile （github仓库下载量贡献第一的repository，由facebook维护）</li><li>Linux （操作系统之父）</li><li>Swift （Apple 发布的原生编程语言）</li></ul><p>当然，初次之外，github还有很多其他的功能，比如我们今天用到的服务器域名。</p><h4 id="搭建步骤">搭建步骤</h4><h5 id="基本步骤">基本步骤</h5><p>1 安装npm，node js</p><p>2 下载 安装 hexo框架</p><p>3 发布文章</p><p>4 下载 Next主题</p><p>5 修改配置（人性化图片，title，分类，标签）</p><p>6 文章字数统计 阅读时间</p><p>7 网站运行时间</p><p>8 加入搜索功能</p><p>9 Github 获取域名</p><p>10 绑定域名 部署</p><h5 id="附加选项">附加选项</h5><p>1 动态背景</p><p>2 鼠标点击气球爆炸效果</p><p>3 右上角加加入github装横</p><p>4 评论功能</p><p>5 小图标链接</p><p>6 加入微信 支付宝打赏</p><p>7 RSS xml 全览</p><p>8 文章底角加入微信公众号推送</p><p>9 防止转载</p><p>10 网站访问量人数和次数统计</p><h5 id="安装npm-nodejs">安装npm nodejs</h5><p><a href="https://www.npmjs.com/get-npm%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%86%8D%E7%82%B9%E5%87%BBdownload" target="_blank" rel="noopener">https://www.npmjs.com/get-npm点击进入链接，再点击download</a> node js and npm，勾选本地安装。安装结束后，打开终端，分别输入<strong>node -v</strong>和 <strong>npm -v</strong> 查看npm和node是否成功安装以及其对应版本。</p><img src="/2020/01/15/how-to-setup-site/npm.png" alt="npm" style="zoom:50%; "><h5 id="下载-安装-hexo框架">下载 安装 hexo框架</h5><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，命名为Blog_life，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中，copy文件夹路径进入终端依次输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>执行完这两句话后，打开<strong>localhost：4000</strong>可以看到如下图所示</p><img src="/2020/01/15/how-to-setup-site/hexoinit.jpeg" alt="hexoinit" style="zoom:100%; "><h5 id="发布文章">发布文章</h5><p>这里带大家熟悉一下hexo的几条常用命令，掌握这几条大家就可以基本完成文章的发布与删除</p><p><code>hexo new &quot;gitTuto&quot;</code></p><p>可以简写为 hexo n “文章题目”</p><h5 id="下载next主题">下载next主题</h5><p>本文默认大家电脑已经安装了git，如果需要熟悉安装<a href="https://wuhewuhe.github.io/2020/01/18/gitTuto/#more">git介绍，安装，基本操作</a>。hexo有100多个主题，大家可以在官网上看到挑选自己喜欢的，这里为大家展示Next主题，主要是因为其黑白风格简明耐看，而且社区庞大，及时更新，有问题好解决，而且next也是hexo最出名的主题之一。</p><p>这里建议老鸟下载最新版，但是新手还是使用稳定版的比较好，我本人使用的5.1.4，如果为了避免错误大家可以全程和我同步。</p><p><code>git clone https://github.com/iissnan/hexo-theme-next</code></p><p>下载完成后，进入blog目录下的theme文件，发现多了一个next主题，进入根目录的_config.yml文件，将找到theme关键字修改问<strong>theme ：next</strong>注意空格，重新执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后大家后看到如下效果：</p><img src="/2020/01/15/how-to-setup-site/next.png" alt="next" style="zoom:50%; "><h5 id="修改配置">修改配置</h5><p><strong>网站的titile 与 subttile</strong></p><p>进入根目录下的*_config.yml*，编辑此文件，自定义title和subtitle</p><img src="/2020/01/15/how-to-setup-site/title.png" alt="title" style="zoom:33%; "><p><strong>编辑照片</strong></p><p>找到一张我们想要的照片jpg，jpeg，png格式不限，调整大小至215*215 pixel放到themes/next/source/images下，进入next主题下的_config.yml, 查找关键字avatar编辑</p><img src="/2020/01/15/how-to-setup-site/avatar.png" alt="avatar" style="zoom:33%; "><p><strong>文章分类</strong></p><p>分档归类，方便自己管理管理博客，同时也能方便读者阅读，这也是hexo的特性之一</p><p>打开分类功能：</p><p><code>hexo new page categories</code></p><p>这说你的source目录下生成 categories/index.md 文件，我们将其打开，把它改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;categories&quot; </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这时候你就可以给你的文章归类存档了，使用方式就是在你的文章的头部加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - 分类1 </span><br><span class="line"> - 分类2</span><br></pre></td></tr></table></figure><p>注意yml格式的文件编写是一定注意空格，否则不识别</p><p><strong>文章标签</strong></p><p>同上所示，首先大概标签功能，在对其md文件进行编辑，修改其类型和关闭评论功能，添加标签。</p><p>注意这里大家为了区分标签和分类，可以定义自己熟悉的语法格式，比如我的分类都是首字母大写，标签首字母小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">type: &quot;categories&quot;  </span><br><span class="line">comments: false</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br></pre></td></tr></table></figure><p>最后回到根目录的*_config.yml*文件中检查，tag_dir和category_dir是否被激活，如下图所示</p><img src="/2020/01/15/how-to-setup-site/tag.png" alt="tag" style="zoom:33%; "><p>另外，Markdown 的语法是写作最优雅最简洁最简单的，如果之前没用过的建议去学一下<a href="https://wuhewuhe.github.io/2019/12/29/markdown/#more">Markdown语法简介</a>。</p><h5 id="文章字数统计-阅读时间">文章字数统计 阅读时间</h5><p>如果没有安装 hexo-wordcount 插件，先安装该插件：</p><p><strong>npm i --save hexo-wordcount</strong></p><p>next主题已经集成此功能，我们直接修改配置就好</p><p>要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true         # 单篇 字数统计</span><br><span class="line">  min2read: true          # 单篇 阅读时长</span><br><span class="line">  totalcount: false       # 网站 字数统计</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/words.png" alt="words" style="zoom:33%; "><h5 id="网站运行时间">网站运行时间</h5><p>找到 \themes\next\layout_partials\ 下面的footer.swig文件</p><p>找到<span id="sitetime">在其后面加入如下代码</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    function siteTime()&#123;</span><br><span class="line">        window.setTimeout(&quot;siteTime()&quot;, 1000);</span><br><span class="line">        var seconds &#x3D; 1000</span><br><span class="line">        var minutes &#x3D; seconds * 60</span><br><span class="line">        var hours &#x3D; minutes * 60</span><br><span class="line">        var days &#x3D; hours * 24</span><br><span class="line">        var years &#x3D; days * 365</span><br><span class="line">        var today &#x3D; new Date()</span><br><span class="line">        var todayYear &#x3D; today.getFullYear()</span><br><span class="line">        var todayMonth &#x3D; today.getMonth()</span><br><span class="line">        var todayDate &#x3D; today.getDate()</span><br><span class="line">        var todayHour &#x3D; today.getHours()</span><br><span class="line">        var todayMinute &#x3D; today.getMinutes()</span><br><span class="line">        var todaySecond &#x3D; today.getSeconds()</span><br><span class="line">        var t1 &#x3D; Date.UTC(2017,4,18,11,00,00)</span><br><span class="line">        var t2 &#x3D; Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond)</span><br><span class="line">        var diff &#x3D; t2-t1</span><br><span class="line"></span><br><span class="line">        var diffYears &#x3D; Math.floor(diff&#x2F;years)</span><br><span class="line">        var diffDays &#x3D; Math.floor((diff&#x2F;days)-diffYears*365)</span><br><span class="line">        var diffHours &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days)&#x2F;hours)</span><br><span class="line">        var diffMinutes &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)&#x2F;minutes)</span><br><span class="line">        var diffSeconds &#x3D; Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)&#x2F;seconds)</span><br><span class="line">        document.getElementById(&quot;sitetime&quot;).innerHTML&#x3D;&quot; this site has runnned &quot;+diffYears+&quot; year &quot;+diffDays+&quot; day &quot;+diffHours+&quot; hour &quot;+diffMinutes+&quot; minute &quot;+diffSeconds+&quot; second&lt;br&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    siteTime()</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/runtime.png" alt="runtime" style="zoom:33%; "><h5 id="搜索功能">搜索功能</h5><p>安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>全局配置文件_config.yml，新增如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;flashlab&#x2F;hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><img src="/2020/01/15/how-to-setup-site/search.png" alt="search" style="zoom:33%;"><h5 id="Github-获取域名">Github 获取域名</h5><p>为了让全世界的人都可以访问到你的网站，接着创建一个public的仓库，比如我<strong><a href="http://wuhewuhe.github.io">wuhewuhe.github.io</a></strong>那么到时我就可以通过此网址来访问我的网站了。 创建完成之后，那么你就有自己的 Git 地址了。然后进入setting选项，找到github pages一栏</p><p>这里为什么建议大家新建一个以自己github名字命名的仓库，这里我踩过雷，给大家提议个醒，因为在_config.yml中有一个选项</p><img src="/2020/01/15/how-to-setup-site/url.png" alt="url" style="zoom:33%; "><p>说的是如果我们建了一个二级仓库需要从新修改deploy的url</p><img src="/2020/01/15/how-to-setup-site/githubUrl.png" alt="githubUrl" style="zoom:33%; "><h5 id="绑定域名-部署">绑定域名 部署</h5><p>从终端进入到blog根目录下，执行如下语句用于安装hexo-deploy-git插件</p><p><code>npm install hexo-deployer-git --save</code></p><p>修改根目录下的_config.yml下的deploy选下如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;wuhewuhe&#x2F;wuhewuhe.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装成功后，进入到pack.json文件中可以到其版本</p><p><code> &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;,</code><br>重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>成功后，访问到**<a href="https://wuhewuhe.github.io/**%E5%B0%B1%E5%AE%8C%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%A7%81%E4%BA%BA%E7%9A%84%E7%BD%91%E7%AB%99%E5%8F%91%E5%B8%83">https://wuhewuhe.github.io/**就完成了我们自己私人的网站发布</a></p><h4 id="总结">总结</h4><p>到这里，我们就已经基本熟悉了hexo框架，next主题，github仓库的使用以及运作流程，如果大家感兴趣想添加更多的特效，是网站更加多姿多彩请看下一章<a href="https://wuhewuhe.github.io/2020/01/18/setupSiteImprove/#more">从零开始手把手教大家如何制作网站(进阶版)</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有路径问题浅谈动态规划</title>
      <link href="/2020/01/05/path-dp/"/>
      <url>/2020/01/05/path-dp/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是动态规划">什么是动态规划</h3><p>在网上找到一个很形象的例子，猿爸爸把 1+1+1+1+1+1+1+1 = 写在纸上，问小猿（咦）：<br>「它们加起来是多少哇？」</p><p>（数了一会…）「8 ！」</p><p>猿爸爸在左边又加了个 1+，再问一次小猿：<br>「现在呢？」</p><p>（迅速地）「9 ！」</p><p>「为什么小猿这么快就知道了呢？」</p><p>「因为你刚刚加了 1 啊~」</p><p>「所以只要记得之前的结果，就不用再计一次数啦。」</p><p>嗯，动态规划就是一种「先记住些事，方便后面节约时间」的神奇方法</p><hr><h3 id="定义">定义</h3><blockquote><p>Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.</p></blockquote><p>以上GeeksforGeeks对动态规划的诠释，于我而言，我认为动态规划的核心思想就是如何将原有的问题拆分成字问题。<strong>如果这个问题我们要是可以用滴归来解决，那么我们一般可以通过动态规划的思路来降低时间复杂度。</strong></p><hr><h3 id="动态规划套路">动态规划套路</h3><p>我认为动态规划总体来讲可以分为三个步骤：</p><ul><li>设定状态</li><li>初始化</li><li>状态转移方程</li></ul><p>具体这三步指的是什么，我将通过路径问题来向大家逐一介绍。</p><p>网上有很多大神总结动态规划可以分为自下而上和自上而下，这一块我天资愚钝，没有领悟得很透彻，就不过多深入去说。</p><hr><h3 id="例题">例题</h3><p>本题是我从leetcode上的第62题，可以说是一道非常经典的动态规划入门题：</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 16.49.32.png" alt="Screenshot 2020-01-05 at 16.49.32" style="zoom:50%; "><p>题目让我们找到从图的左上角到右下角的所有路径，告诉我们只能向下或者向右走。</p><h3 id="题目分析">题目分析</h3><p>首先这个题是一个<strong>计数</strong>问题，提到计数这个关键词，那么很快我们就可以联想到程序猿爸爸让儿子1+1+1… .</p><ul><li>状态</li></ul><p>我们可以将这个题转化为一个m*n的矩阵，矩阵上的每一个格子的值就代表从左上到达该格子的所有路径总和。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.10.53.png" alt="Screenshot 2020-01-05 at 17.10.53" style="zoom:25%; "><p>如图所示，由A到B最多有两个路径： 1 右 下 2 下右。 所以B对应的状态为2，A对应的状态为1</p><ul><li><p>初始化</p><p>明确了状态之后，我们需要对矩阵初始化，为了题目给定了矩阵的长和宽，那么我们就可以创建一个对应的m*n的矩阵，然后我们知道初始位置是左上角，所以其初始值为1，然后最上面的一行和最左面的一行值也都为1。因为我们只有一种方式可以到达他们。</p><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.17.33.png" alt="Screenshot 2020-01-05 at 17.17.33" style="zoom:25%; "></li><li><p>状态转换方程</p><p>回到图中，我们已经已知了初始值，那么我们如何求解到问号位置的值呢？<br><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.19.54.png" alt="Screenshot 2020-01-05 at 17.19.54" style="zoom:25%; "><br>我们发现到达？位置的路径总和就是等于到达？位置上方和左边的值相加。因为题目告诉我们只有两种移动方式。对应的方程就是 <code>res[i][j] = res[i - 1][j] + res[i][j - 1];</code></p></li></ul><h3 id="结果展示">结果展示</h3><img src="/2020/01/05/path-dp/Screenshot 2020-01-05 at 17.26.00.png" alt="Screenshot 2020-01-05 at 17.26.00" style="zoom:50%; ">所以如果我们给出一个4*4的矩阵，那么一共存在20种走法从左上走到右下<h3 id="代码实现">代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">&#x2F;&#x2F;corner case</span><br><span class="line">if (m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 0)</span><br><span class="line">return 0;</span><br><span class="line">if (m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1)</span><br><span class="line">return 1;</span><br><span class="line">&#x2F;&#x2F; init state </span><br><span class="line">int[][] res &#x3D; new int[m][n];</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">res[i][0] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">res[0][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; loop the matrix </span><br><span class="line">for (int i &#x3D; 1; i &lt; m; i++) &#123;</span><br><span class="line">for (int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">&#x2F;&#x2F; state change equation</span><br><span class="line">res[i][j] &#x3D; res[i - 1][j] + res[i][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是m<em>n, 空间复杂度也是m</em>n。 这里可以通过滚动数组将时间复杂度优化到n。</p><h3 id="follow-up">follow up</h3><p>为什么说动态规划是对递归的的一种优化，其实这个题，我们用深度优先搜索也可以做。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths2(int m, int n) &#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0 &amp;&amp; n&#x3D;&#x3D;0)</span><br><span class="line">        return 0;</span><br><span class="line">    return dfs(0,0,m,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int dfs(int i,int j,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&#x3D;&#x3D;m-1 &amp;&amp; j&#x3D;&#x3D;n-1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(i&gt;&#x3D;m || j&gt;&#x3D;n)</span><br><span class="line">        return 0;</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    sum+&#x3D;dfs(i,j+1,m,n)+dfs(i+1,j,m,n);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们会发现搜索是超过时间限制的，为什么因为搜索的时间复杂度是2^(m+n)。<br>因为搜索的数据结构就是二叉树，好比我们要想知道4<em>4矩阵的结果，就先把4</em>4拆分成对应的（3，4）与（4，3）相加，再将（3，4）拆分成（2，4）和（3，3）以此类推不停地拆分直到（0，0）的初始位置，然后我们发现这个过程中出现了很多重复的问题，并且每一个点都可以拆分成两个点。所以当m，n越大，起花费时间也越多。</p><h3 id="总结">总结</h3><p>动态规划和递归一直以来都是我算法的弱项，和平铺直叙的线性思维不同，递归和动态规划是通过对问题的拆分，很多时候是逆向思维。我发现此类问题都是代码量很小，但是需要想的很周全。之后，我会多通过练习来加深自己对其的认识。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2019/12/29/markdown/"/>
      <url>/2019/12/29/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈markdown语法">浅谈markdown语法</h2><p><strong>文章需要2分钟阅读 适用于每一个拥有电脑的你</strong><br>本期我将用最短的时间，向大家介绍一个码字的神奇，不用排版，只要记住几个symbol就能高效快捷的记录。</p><h4 id="介绍">介绍</h4><p>markdown 可能很多人听起来有点陌生，他就是类似于我们常使用的word或者wpf，是一种轻量级的标记语言。很多的网络作者，现代的编辑，还有程序猿背景的工作者大多数都青睐于此文本格式用于写作。向我们经常看到的论坛：简书，github，stackoverflow都是支持并推广markdown语法。</p><h4 id="起源">起源</h4><p>Markdown 由 John Gruber 在2004年创建，至今已经是12年的时间。关于Markdown最初的定义如下：</p><blockquote><p>a plain text formatting syntax<br>a software tool, written in Perl, that converts the plain text formatting to HTML</p></blockquote><p>指明markdown是一个纯文本语言，转化为html，html就是我们每天在各式各样网站上浏览看的文字图片对应的代码。</p><p>最初的设计理念：</p><blockquote><p>The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions.</p></blockquote><p>设计初衷就是markdown这种语法非常的简便易读，省去传统word大规模反锁的排版，而是然作者专注于内容的书写。</p><h4 id="常用的-markdown语法">常用的 markdown语法</h4><ul><li><p>标题</p><p><strong>语法</strong></p><img src="/2019/12/29/markdown/title.png" alt="title" style="zoom:50%; "><p><strong>效果</strong></p><img src="/2019/12/29/markdown/titleShow.png" alt="titleShow" style="zoom:50%; "></li><li><p>列表</p></li></ul><p><strong>语法</strong></p><img src="/2019/12/29/markdown/order.png" alt="order" style="zoom:50%; "><p>**效果 **</p><img src="/2019/12/29/markdown/orderShow.png" alt="orderShow" style="zoom:50%; "><ul><li><p>插入图片</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;MD.png&quot; alt&#x3D;&quot;MD&quot; style&#x3D;&quot;zoom:50%;&quot; &#x2F;&gt;</span><br><span class="line">or </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![MD](MD.png)</span><br></pre></td></tr></table></figure><pre><code>这里可以直接写绝对路径，但是大多数浏览器都是支持相对路径。如果不行的话肯定也有相应的插件支持。zoom代表图片的大小。使用topora这样的编译器可以直接拖拽图片到编辑区域。</code></pre><p><strong>效果</strong><br><img src="/2019/12/29/markdown/MD.png" alt="MD" style="zoom:50%; "></p><ul><li><p>链接</p><p><strong>语法</strong><br><code>`[baidu](https://www.baidu.com)`</code><br><strong>效果</strong><br><a href="https://www.baidu.com" target="_blank" rel="noopener">baidu</a></p></li><li><p>引用</p><p><strong>语法</strong><br><img src="/2019/12/29/markdown/reference.png" alt="reference" style="zoom:50%;"></p></li></ul><p><strong>效果</strong></p><img src="/2019/12/29/markdown/Screenshot 2019-12-30 at 00.34.56.png" alt="Screenshot 2019-12-30 at 00.34.56" style="zoom:25%;"><ul><li>代码</li><li><ul><li><p>单行代码</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96; print(&quot;hello world&quot;);&#96;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><code>print(&quot;hello world&quot;);</code></p><ul><li><ul><li><p>代码块</p><p><strong>语法</strong></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​```c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);<span class="built_in">print</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**效果**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br><span class="line">print(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>斜体 粗体</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***斜粗体***</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><em>斜体</em><br><strong>粗体</strong><br><em><strong>斜粗体</strong></em></p><ul><li><p>分隔符</p><p><strong>语法</strong><br><code>三个连续的+，*或者- </code><br><strong>效果</strong></p></li></ul><hr><ul><li><p>表格（不推荐）</p><p><strong>语法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><h4 id="优缺点">优缺点</h4><h5 id="优点：">优点：</h5><p>说了这么多，markdown的优点我相信大家也都感受到了，比如</p><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开</li><li>让你专注于文字而不是排版</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等</li><li>Markdown 的标记语法有极好的可读性</li></ul><h5 id="缺点：">缺点：</h5><ul><li>没有完全统一的标准</li></ul><blockquote><p>这里可以说一则趣事，早些时候由tack Overflow 创始人和几个互联网巨头联合起来想制订一个统一的标准叫做Standard Markdown。结果这个事儿被创始人知道了，老爷子不开心，说你不能用standard这么官方的名字，因为我就没想让它统一。后来这个计划更名为Common Markdown。</p></blockquote><ul><li><p>作为一个中间语言，没有html丰富的功能</p><blockquote><p>html全称hypertext markup language，是一种超文本标记语言，他集成了很多的功能，是markdown语法所不具备的。比如其上传视频，改变布局… …</p></blockquote></li><li><p>对于一定的格式写法有些复杂</p></li></ul><blockquote><p>相信所有熟悉markdown写法的人都知道，markdown语法更改字体颜色，剧中右对齐是做不到的，需要插入html代码，虽然说排版已经违背了设计的初衷，但我们也不能一点都不修边幅。还有就是markdown始终对于插入表格是个硬伤，始终要注意index对其。</p></blockquote><h4 id="markdown-编译器">markdown 编译器</h4><p>如果你看了我的文章想尝试一下mardown语言，我在这里为大家列出一些当前比较流行的mardown编译器。</p><ul><li>typora  (良心安利，免费好用，实时预览，macos/window兼容)</li><li>Mou （功能强大，插件很多，<strong>但是收费</strong>）</li><li>印象笔记 （不错的选择，手机电脑可以通过云来同步）</li><li>sublime （书写方便，快捷，但是不能预览）</li><li>visualstudio （同理sublime）</li></ul><h4 id="总结">总结</h4><p>一个技术的存在可以达到hot or popular一定是有其的道理。markdown语言我认为非常适合写技术博客，经常码字追求流畅的文字工作者，<strong>如果一个东西能够大幅度的提升我们的工作效率，那么我们为什么不用它</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> writing skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU</title>
      <link href="/2019/12/28/LRU/"/>
      <url>/2019/12/28/LRU/</url>
      
        <content type="html"><![CDATA[<h2 id="LRU-Least-Recently-Used-页面置换算法">LRU(Least Recently Used) 页面置换算法</h2><p>本篇文章阅读时间 5 分钟， 技术实现 java， javascript。</p><h4 id="概述">概述</h4><p>这一周本来是想将Mario（马里奥）做完，但是周三晚上下班看了一眼React，于是一发不可收拾，之前是听同学，朋友，同事说react的香，一直没有感觉到，真是自己从头学了一下才感受到他火确实是有道理。因为自己的学习笔记还没有整理完，mario的进度推迟了。正巧在自己做网站的时候，看到react-router里面有一个封装好的内置类history，自己在写的时候遇到了浏览记录的问题。正巧室友说在国内面试时被问到这个问题。这期，临时决定写一写这个LRU页面置换算法。</p><h4 id="算法缘由">算法缘由</h4><p>第一次听到这个页面置换算法应该是大三的操作系统课，但是当时也就是考试复习随便瞟一眼，也没仔细看。字如其名，其本质就是选择调出用户想要的页面，好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。这是官方给出的解释，白话说，假如浏览器只能同时加载显示三个页面，那么我们应该通过一种最合理的方式显示出我们最常用的三个，而将不常用的替换掉。常见的置换算法像是OPT，FIFO，CLOCK，LRU。我自己认为LRU是最贴近现实生活，同时也是最常考到。</p><h4 id="例题展示">例题展示</h4><p>为了更好的讲述这个题，我就从leetcode上面直接拔下来一个题。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.24.22.png" alt="Screenshot 2019-12-22 at 21.24.22" style="zoom:25%; "><p>题目说的什么意思呢，就是让我们自己通过数据结构设计一个类并指定缓存的最大存储量，类表示的就是我们浏览器的缓存，类里面有两个方法，分别为get和put。get的意思就是，如果此时缓存记录里有我要找的东西，那么直接返回结果。没有就输出一个-1。put的意思就是，每次我们访问一个新的网页，将这个网页放入到我们的缓存中，如果该网页已经存在于缓存中，则对其内容进行替换。若不存在，加入到缓存中。</p><p>他这里有一个follow up：问我们怎么能够用常数的时间复杂度完成所有的操作。（就是优的解决方案）</p><h4 id="分析：">分析：</h4><p>首先读完这个题目，并结合我们的我们的生活常识，很快，我就想到根据我们需要用一个固定长度的数据结构去存储用户的访问记录。然后再看到put方法key，value键值对，我想到了hashtable。我们可以用hashtable的key设置为数字，代表用户的浏览记录标示；value作为内容。并且hashtable的查找时间复杂度为O（1）。再之后，我们会发现这个题单纯一个hashmap数据结构还不能满足我们的所有需求，比如从技术层面出发，我们知道hashmap的添加和删除操作都是o（logn）的时间复杂度。应用层面上，单纯只用hashmap，我们怎么做到对内容的更新与调度。于是，在这里我们可以在引入一个双向节点，这里有很多做法比如用deque，linkedlist。我是从题目本身出发，自己写了一个Node类，他有四个属性，分别是prev（前一个节点），next（下一个节点），key（页面表示），value（内容）。这样设计的好处就是，我们在执行添加和删除的操作时，只需要改变指针的方向不需要便利整个list到达了最优的时间复杂度。</p><p>这里，可能文字还是有些拗口，尤其是针对分计算机专业的童鞋们，我付上一个图片更能清晰直观的描述设计思路，以及运行过程。</p><p><strong>模型</strong></p><table><thead><tr><th><strong>Hash table - capacity</strong>**（<strong><strong>2</strong></strong>）****- head(0, 0)**</th></tr></thead><tbody><tr><td>Node 1 key = 1, value = 1, prev = head, next = Node2</td></tr><tr><td>Node 2 key = 1, value = 1, prev = Node1, next = tail</td></tr></tbody></table><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 21.45.19.png" alt="Screenshot 2019-12-22 at 21.45.19" style="zoom:25%; "><p>假设我们模拟执行 例题中给的几步</p><h5 id="Step-1-LRUCache-cache-new-LRUCache-2-cache-put-1-1">Step 1 : LRUCache cache = new LRUCache(2); cache.put(1, 1);</h5><p>首先我们初始化了一个缓存对象，并设置他的最大容量为2。</p><p>此时我们将第一个元素放进来。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.27.png" alt="Screenshot 2019-12-29 at 00.26.27" style="zoom:25%; "><h5 id="Step2-cache-put-2-2">Step2 : cache.put(2, 2);</h5><p>检测是否超过最大容量。再将第二元素放到队伍头节点</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.30.png" alt="Screenshot 2019-12-29 at 00.26.30" style="zoom:25%; "><h5 id="Step3-cache-get-1">Step3 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。发现有则返回value。并交换节点（2，2）和（1，1）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.34.png" alt="Screenshot 2019-12-29 at 00.26.34" style="zoom:25%; "><h5 id="Step4-cache-put-3-3">Step4 : cache.put(3, 3);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（2，2）删除，再把新的节点（3，3）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.38.png" alt="Screenshot 2019-12-29 at 00.26.38" style="zoom:25%; "><h5 id="Step5-cache-get-2">Step5 : cache.get(2);</h5><p>检测缓存中是否有id为2的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.41.png" alt="Screenshot 2019-12-29 at 00.26.41" style="zoom:25%; "><h5 id="Step6-cache-put-4-4">Step6 : cache.put(4, 4);</h5><p>检测已经超过最大容量，因为我们将队尾的节点（1，1）删除，再把新的节点（4，4）放到头部</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.44.png" alt="Screenshot 2019-12-29 at 00.26.44" style="zoom:25%; "><h5 id="Step7-cache-get-1">Step7 : cache.get(1);</h5><p>检测缓存中是否有id为1的内容，对节点队列进行遍历。没有返回-1</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.48.png" alt="Screenshot 2019-12-29 at 00.26.48" style="zoom:25%; "><h5 id="Step8-cache-get-3">Step8 :cache.get(3);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.52.png" alt="Screenshot 2019-12-29 at 00.26.52" style="zoom:25%; "><h5 id="Step9-cache-get-4">Step9 : cache.get(4);</h5><p>检测缓存中是否有课id为3的内容，对节点队列进行遍历。发现有则返回value。并交换节点（4，4）和（3，3）的位置。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-29 at 00.26.55.png" alt="Screenshot 2019-12-29 at 00.26.55" style="zoom:25%; "><h4 id="代码实现">代码实现</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.04.26.png" alt="Screenshot 2019-12-22 at 22.04.26" style="zoom:25%; "><p>为了方便编程，避免空指针，便于调试。我自己设置了一个头节点和尾节点。在LRU里面自定义一个内部节点类。LRU的结构为hashmap套node。</p><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.07.26.png" alt="Screenshot 2019-12-22 at 22.07.26" style="zoom:25%; "><p>添加到头部，因为是双向所以需要改变两次。这里要插入头部，所以先保存一下原有的头节点，再让原有的头节点与新添加节点做操作。1 新添加节点的下一个指向原有头节点。2 head的下一个指向新添加节点。3 原有头节点的上一个指向新添加节点。 4新添加节点的上一个指向head。 建议大家在做指针指向问题的时候画草图，并且想改变好一个方向再去改变另外的方向。</p><p>删除，也是把前一个节点的下一个节点指向要删除节点的下一个。再把删除节点下一个的前一个指向删除节点的前一个。<img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.15.39.png" alt="Screenshot 2019-12-22 at 22.15.39" style="zoom:25%; "></p><p>get 操作：检测hashmap是否含有key值。若存在，取出node节点，删除原有的node节点，再从新插入到头部。返回value。没有直接返回-1。</p><p>put操作 ：检测hashmap是否含有key值，若存在，取出node节点。取出node节点，删除原有的node节点，再从新插入到头部。若没有，先判断，hashmap是否达到自己的最大容量，若达到，删除队尾节点，在将新节点插入头部。如没达到容量直接插入。</p><h4 id="测试结果">测试结果</h4><img src="/2019/12/28/LRU/Screenshot 2019-12-22 at 22.03.57.png" alt="Screenshot 2019-12-22 at 22.03.57" style="zoom:25%; "><h4 id="源码仓库：">源码仓库：</h4><p><a href="https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem" target="_blank" rel="noopener">https://github.com/wuhewuhe/LeetcodeNotes/tree/master/src/RealLifeProblem</a></p><h4 id="总结">总结</h4><p><strong>LRU</strong>最近最久未使用页面置换算法，无论是在面试中作为一个程序设计题的高频出现，还是其cache思想贴近实际生活都是我认为很重要的一个点。希望自己的见解都初学者有帮助，对非it领域算是一个扩展知识的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> page replacement </tag>
            
            <tag> lru </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tetris</title>
      <link href="/2019/12/28/tetris/"/>
      <url>/2019/12/28/tetris/</url>
      
        <content type="html"><![CDATA[<h2 id="俄罗斯方块Tetris">俄罗斯方块Tetris</h2><h4 id="背景回顾">背景回顾:</h4><p>我觉俄罗斯方块在游戏领域的地位，有点像乔丹打篮球。为什么这么说，EA对过去30年的游戏评点，俄罗斯方块这样一个仅在当时老毛子开发出来做检测效率的东西，列在榜单首位。在那个遥远寒冷的西伯利亚，俄罗斯工程师发布这个名为Tetris后，在那个人口还没有爆炸增长，电脑还没普及的时候，先后有5亿人对此游戏下载。甚至毫不夸张的说，很多人第一次听到俄罗斯就是通过俄罗斯方块这个小游戏。时至今日，俄罗斯方块早已下架，但是以任然保持着9项吉尼斯世界纪录，同样也在影视，医疗领域做出了不小的贡献。</p><h4 id="程序界面设计-：">程序界面设计 ：</h4><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.31.12.png" alt="Screenshot 2019-12-25 at 17.31.12" style="zoom:25%; "><h4 id="程序开发设计：">程序开发设计：</h4><h5 id="创建主题窗口，设置游戏界面，画边框">创建主题窗口，设置游戏界面，画边框</h5><p>同其他类型小游戏一样，我们第一步要做的就是创建一个frame设置其大小，是否可见，相对位置。然后在主体frame中插入一个jpanel，实现游戏的所有逻辑细节。可能对于不同的游戏项目，我们可能需要上网找资源，但是俄罗斯方块我们可以直接用java自带的graphic包里面的drawRect方法来绘制正方体就足矣。因为之前已经写过如何设置推算调试窗体大小，这里就不过多赘述。</p><p>我设置每个小方框的边长为20pxl，主题窗口的宽为400pxl，高度为500pxl。游戏界面，容器的高度为21行，宽度为12行。其中第一列和最后一列还有最后一行是墙壁。唯一一点需要考虑的是用什么去存出游戏的地图，这里我看网上有的人有list，map，我更倾向于2位数组。原因很简单，长度固定，数组的访问修改快，通过一些边界条件，程序效率也高。因此在我的程序里，二维数组第一位代表列，就是对应二维坐标系的x；第二维代表行，就是二维坐标系的y。准备工作都做好后，我们初始化地图，设置边框。</p><p>来看一下第一步结束的效果图：</p><img src="/2019/12/28/tetris/Step1.png" alt="Step1" style="zoom:25%; "><h5 id="方块的绘制">方块的绘制:</h5><p>俄罗斯方块从字面意义上我们就知道方块是这游戏的操作的主体，所以我认为这一步也是整个游戏开发中最重要的环节。首先我们需要确定游戏中有多少种基本形状，这个我就上网google了一下。随后我们要确定用什么样的数据结构去存储和表示方块的形状。因为我们知道方块是可以旋转的；每次旋转完之后形状由于方向的改变，所以图形也变化。</p><p>这里我们首先先列出俄罗斯方块的7本基本形状，然后再去进行下一步的detail：</p><p>I字形</p><img src="/2019/12/28/tetris/shapei.png" alt="shapei" style="zoom:25%; "><p>田字形</p><img src="/2019/12/28/tetris/shapeSquare.png" alt="shapeSquare" style="zoom:25%; "><p>Z字形</p><img src="/2019/12/28/tetris/shapeZ.png" alt="shapeZ" style="zoom:25%; "><p>S字形</p><img src="/2019/12/28/tetris/shapes.png" alt="shapes" style="zoom:25%; "><p>T字形</p><img src="/2019/12/28/tetris/shapeT.png" alt="shapeT" style="zoom:25%; "><p>L字形<br><img src="/2019/12/28/tetris/shapeL.png" alt="shapeL" style="zoom:25%; "></p><p>J字形</p><img src="/2019/12/28/tetris/shapeJ.png" alt="shapeJ" style="zoom:25%; "><p>从图片中我们就可以观察到，I形状的长或宽等于四，是这里最长的。所以我们的目的是用一个数据结构表示所有的图形，因此我想到可以使用4<em>4的一个二维数组。0表示空闲，1表示填充，如果把二维数组平铺下来就是一个长度为16的一维数组。然后我们就要考虑到方块的旋转引起形状的变化，所以我们还需要分析，每个形状经过旋转好最多能产生几种不同的形状。举个例子，比如田字形无论怎么旋转都是同样的形状，但是L或者J字形就可以产生4种不同的状态，因此我们可以用4</em>16的数组代表每个图形的所有变化。</p><h5 id="举例-L">举例 L</h5><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 17.48.27.png" alt="Screenshot 2019-12-25 at 17.48.27" style="zoom:25%; "><p>而一种方块的所有变形体的信息可以用二维数组来存储，依旧拿L形方块举例，它的所有形态可以存储为</p><p>{</p><p>{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },</p><p>{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }</p><p>},</p><p>由于二维数组只能存储一种方块的所有变形体信息，故要存储七种方块的所有变体信息则要使用三维数组来进行存储。</p><h4 id="3方块-初始化-左右移动-旋转-下落-：">3方块 初始化-&gt;左右移动-&gt;旋转-&gt;下落 ：</h4><p>一提到移动，可以说完变不离其宗，对于java来讲就两个大方向thread或者timer，通过图形坐标的改变，其定时的刷新来重新绘制panel。可能两者存在细微差别，但是对我来讲可能就像是方法改个名字比如thread要重写runner方法。而timer是重写actionlistener。（这两个东西很重要，可能简单的也说不清楚，因为他不是文章的主题，我们就跳过了）。之前的falppy bird和小恐龙跳跃我都用的是thread。这一次俄罗斯方块我就使用timer方法。</p><p>我们的要在这一步实现的功能是方块自然下落，左右可以移动，并且下落过程中可以旋转。那么一步一步来，第一步方块的初始化。</p><h5 id="1-create-rectangle">1 create rectangle</h5><p>这里我先设置一个固定的x，y坐标代表每次当一个方块落地后，下一个方块就会从这里重新出现一个新的，我默认的是左上角就是x=1, y=0。然后设置2个随机数，取值范围为1-7和1-4，分别对应哪一个图形，和图形具体的哪一种状态。</p><h5 id="2-左右移动">2 左右移动</h5><p>因为这里用户可以通过键盘的左右键来操作图形的移动。每当表示每种行为状态的变化时，我们就要引入事件的监听。左右移动顾名思义就是在y轴坐标不变的条件下，移动x。向右移动x变大，向左移动x减小。最后再重新绘制图片。但是这里有我们需要写一个函数，来判断图形是否还可以继续移动，当图形向右移动到最右边触碰到墙壁的时候此时就不能再向右移动，反之亦然。因此我们可以用两个for循环对图像的每个点遍历，当有一个点碰到墙壁则返回false。</p><h5 id="3-旋转">3 旋转</h5><p>就是改变图形的状态，在已知图形的种类和初始状态的条件下，每点击一次按钮就旋转90度。这里我们还需要判定是否可以旋转，当图形已经碰到了另外的图形，则此时不能在放生状态改变。就是我们在绘制地图时，默认0为空，1为已填充图形，2为墙壁。同样还是对当前图形状态的每一个点做遍历，若图形已经碰到最底部的墙壁或者两个图形出现相重叠部分，那么也不能旋转。这两个条件，我也是借鉴了网上的代码。</p><h5 id="4-下落">4 下落</h5><p>默认如何图形可以移动，那么每次timer重新刷新界面y坐标就会自动加1。如何碰到地面或者两个图形重叠，那么下落停止。</p><h4 id="5-重绘界面-设置分数">5 重绘界面 设置分数</h4><p>首先我们设定一个全局变量反应当前游戏得分，每消除一行则加10分。我们设定timer线程每隔一段时间重新绘制界面，每次当一个方块落地后无法移动时。我们会将其加入到map地图中，就是对图形的x，y坐标对应到map中，将原来是0的地方填充为1。然后我们还需要检查是否出现方块填满一整行的情况。这里就是对map进行遍历，两层循环，外层遍历行（从最后一行开始），里层循环遍历列（从第一列开始），设置一个变量来记录每一行已填充的方块数量，如果填充的方块数量刚好等于，游戏容器的宽度减2（墙壁）。于是我们将此行上面的所有行向下移动一行。</p><p>做到这一步：我们游戏就已经见成效了，在这里做一个小的演示：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-25 at 18.44.12.png" alt="Screenshot 2019-12-25 at 18.44.12" style="zoom:25%; "><h4 id="6-完善游戏体验与调试">6 完善游戏体验与调试</h4><p>其实每次最后一步就对游戏进行一个简单的测试，检查是否出现bug。完善一些小功能，修改一下UI设计。</p><h5 id="游戏结束-分数记录-暂定-重新开始-下一个图形">游戏结束 分数记录 暂定 重新开始 下一个图形</h5><p>游戏结束条件就是我们的方块累计到达了顶部，这个我我们可以写一个方法，判断在最顶上一行是否出现填充的方块，如出现，游戏结束。然后我们需要对比当前得分与游戏最高得分做对比，若当前得分高于最高得分，则更新。</p><p>游戏重新开始，就是将分数清0，然后重新绘制地图，墙壁，初始化方块。</p><p>游戏暂停与继续，对timer线程调用api，start/stop。这里我们用JMenu做了一个分级菜单，菜单里我们可以退出，暂定，继续游戏。别切阅读游戏玩法提示。</p><p>下一个图形，这个玩过俄罗斯方块的都知道每当一个图形初始化后，右侧界面都会出现的下一次图形的提示。这里我们就是新建两个随机数，分别代表图形种类和状态。然后在每次每次初始化新图形，重新绘制面板时，在界面右侧绘制下一次将要出现的图形。</p><p>最后给大家看一个完整版的效果图：</p><img src="/2019/12/28/tetris/Screenshot 2019-12-29 at 00.11.28.png" alt="Screenshot 2019-12-29 at 00.11.28" style="zoom:25%; "><h4 id="建议阅读时间-8分钟，-程序实现-java，-源代码">建议阅读时间 8分钟， 程序实现 java， 源代码:</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/Tetris</a></p><h4 id="总结：">总结：</h4><p>大概用了7个小时去进行程序整体设计，编程实现，调试，代码优化。然后4个小时去写文档。基本上完成俄罗斯方块的复刻，当然，还有细节做的不够好，比如背景音乐，方块颜色……</p><p>最后想说一说最近编程的一些感想，编程可能语言在不停的变，但是面向对象的思想没变，数据结构没变。我觉学习一门技术最重要的不是看概念，而是不停的实践，理论基础是在实践中总结出来才能记得更牢固。任何一个框架，技术都有自己的套路，当我们熟悉它之后，学会用计算机的思维方式去思考的时候，那么我们才能做到学以致用。（说远了，我也是差的还很远）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flappy bird</title>
      <link href="/2019/12/28/flappy-bird/"/>
      <url>/2019/12/28/flappy-bird/</url>
      
        <content type="html"><![CDATA[<h2 id="Flappy-Bird-仿写">Flappy Bird 仿写</h2><p>通过之前做贪吃蛇和小恐龙跳跃，对jframe，swing和awt的基础已经回顾的差不多了，因此这篇文章就不再一一赘述我已经写过的细节。讲讲大体上实现思路，设计模式还有哪些点需要注意。惯例，还是把所有素材和源码放到github上。</p><p>Flappy bird这个游戏是2014年一个在美国工作的越南裔移动端游戏工程师（Dong Nguyen ）开发的，然后在apple商店推出后就瞬间爆火，然后其自己突然让游戏下架。我在youtube上看了一些视频，据说此事与dark net相关（也不知真的假的）。后来，过来一段时间，他又从新上架这这款游戏，可是已经没有了当时的人气。因为我也认识当事人，也不知道事情的来龙去脉，所以今天我只是从技术的角度去复习这款游戏。</p><h4 id="技术选用与涉及技术：">技术选用与涉及技术：</h4><p>java8， eclipse IDE, jframe，awt，swing，thread</p><h4 id="思路">思路:</h4><p>由于我从事的领域并不是游戏开发，这只能算是我的爱好也是对技术的温故知新，所以我只是讲讲我对其的认识。我发现市场很多游戏都是单页面应用，我所指的单页面就是玩家对于操作对象始终停留在一个窗口中，我们通过不停的变化背景，生成障碍物去让游戏继续。对于这些单页面的应用，我通常的实现步骤就是先创建一个叫app的class，此类包含main函数，就是程序的入口，在这里面预设一个固定大小的主窗口初始化，加入监听器，然后再新建一个gamepanel类，所有的逻辑都会在这个类中完成。并将此类在app中事例化。然后分别对此程序中涉及到的所有对象创建class，比如小鸟（bird），管道（pipe），线程（thread），游戏本身所有的规则（game）。我本人的开发习惯是喜欢单独建一个辅助类（helper），存放所有的辅助函数，比如想图片的读取，声音的播放之类的。这些大概的轮廓搞好后，然后我们开始写程序。</p><h4 id="1寻找素材-调整合适大小">1寻找素材 调整合适大小</h4><p>这里我听取网友的建议然后进行过测试</p><p>小鸟3张 翅膀平行，下落，上升  管道2张（朝上和朝下） 背景图片一站 陆地一张</p><p>小鸟尺寸为 45 * 32 pixel</p><p>管道为为 66*400 pixel</p><p>大地和背景都为 500*500 pixel</p><h4 id="2-绘制背景，管道-，小鸟">2 绘制背景，管道 ，小鸟</h4><p>首先绘制背景，分别加载两张背景图片，注意顺序，当图片累加时会有重叠的问题。</p><p>然后是小鸟，给小鸟一个初始化的位置，作为游戏的起点。最后是管道。管道分为朝上和朝下，管道的宽度是固定的，也是给定一个初始值。</p><p>完成这一步，效果就是大概这样的：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 01.23.53.png" alt="Screenshot 2019-12-15 at 01.23.53" style="zoom:25%; "><h4 id="3-让小鸟跳跃-移动-挥舞翅膀">3 让小鸟跳跃 移动 挥舞翅膀</h4><h5 id="Step1-小鸟移动">Step1 小鸟移动</h5><p>实现这个功能，我需要预设一个jump为小鸟的单次上升高度。还有一个gravity引力系数，常识由于有地心引力的存在下降速度总是比上升速度快，我预设一个0.5，就是在我这个游戏中下降速度是上升速度的两倍。这里还有一点需要注意就是按键，如果按了空格键，小鸟位置上升，不按空格键，小鸟则直接下降，通过不停的点击空格键是可以让小鸟的高度累加。为了更贴近现实，我加入了一个图片旋转的功能，就是上升时，小鸟的头部会向上倾斜，反之亦然。此时我们可以通过awt的内置类affinetransform对图片进行一定幅度的旋转。</p><h5 id="Step2-小鸟跳跃">Step2 小鸟跳跃</h5><p>与小恐龙制作相差无几，我们可以让背景以一定的速度从右向左移动就可以达到一种小鸟在移动的感觉。此时我们需要用到线程，每隔一定的时间，重新绘制背景。我预设一个25ms，每25ms线程就会更新一次小鸟以及背景的位置。然后对键盘键监听，按空格键则小鸟位置上升，松开空格键则位置下落。</p><h5 id="Step3-挥舞翅膀">Step3 挥舞翅膀</h5><p>找到三张不同的图片是小鸟翅膀的位置分别在上中下，然后每隔25ms，单线程调用时累加游戏时间除以100再对3取余数，就达到了每100ms小鸟的翅膀就移动一次位置。</p><h4 id="4-管道的出现-移动">4 管道的出现 移动</h4><p>因为我们每隔25ms线程会去重新刷新界面，所以我们给定管道一个初始速度3。每25ms，管道向左移动3pixel。然后取一个在50-200之间取一个随机值，代表在接下来的50-200pixel会出现下一个管道。对于管道的y坐标，需要多考虑一点，因为小鸟的高度是32pixel，然后管道的高度是400pixel所以管道只是在界面中显示一段，我对于游戏的设计就是朝上的管道和朝下的管道总是成对出现，然后为了保证小鸟可以顺利通过管道，我给两个管道中间预留了50-120的pixel，然后再去推理出朝上和朝下管道具体的y轴值。</p><p>完成这一步，游戏也就实现了60%，效果如下：</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.02.16.png" alt="img" style="zoom:25%; "><h4 id="5-碰撞检测">5 碰撞检测</h4><p>首先先新建一个arraylist用于存放出现的管道。奇数代表朝下，偶数朝上。用一个i记录当前管道。与小恐龙撞仙人掌相同，如何判定小鸟是否可以通过管道，我们需要对小鸟进行碰撞检测。每一组碰撞检测可以分为四个方面，我用两张图片向大家更好的讲解。</p><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-15 at 02.03.46.png" alt="Screenshot 2019-12-15 at 02.03.46" style="zoom:25%; "><img src="/2019/12/28/flappy-bird/Screenshot 2019-12-28 at 23.54.44.png" alt="Screenshot 2019-12-28 at 23.54.44" style="zoom:25%; "><p>我们取到小鸟的头部检测小鸟有没有碰到管道的两个前沿，以及小鸟分过管道后是否碰到管道的后沿。当然是存在一定可能小鸟会碰到管道的中间，但在我这个游戏中，我已经计算过，线程25ms刷新一次，如果小鸟在进入管道前没有撞到管道，小鸟在跳跃或者下降，因为宽度固定，所以小鸟已经走到管道外。因此我只需要检测管道的头和尾。与小鸟的头和尾即可。</p><p>当然，我们还需要检测小鸟的位置使其置于大地和天空之间，如果超出范围也是碰撞。</p><h4 id="6-游戏暂停-结束-重新开始">6 游戏暂停 结束 重新开始</h4><p>暂停：设置一个全局变量pause，初始值为false。点击p时则pause变为true，此时游戏暂停。在界面中写出提示语，点击p键继续游戏。我们需要暂时让线程停止工作，从而使画面不刷新。</p><p>结束：设置一个全局变量death，初始值为false。当小鸟碰到大地，天空，管道时，death为true。在界面给出提示语，游戏结束，点击R键从新开始游戏</p><p>重新开始 ： 从新初始化小鸟的位置，分数，清空管道的list。</p><h4 id="7-分数统计-记录">7 分数统计 记录</h4><p>在主窗体底下设置一个长矩形，分别代表当前得分和记录，没通过一对管道增加1分，当游戏结束时，比较当前得分与最高得分。若当前得分高则更新记录。</p><p>最后呈现一下最终效果：</p><h4 id="源代码：">源代码：</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/FlappyBird</a></p><h4 id="总结：">总结：</h4><p>通过此次的flappy bird的开发，相比于前两次无论是开发时间，思路，完成度从自己的角度出发都有了一定程度的提升。同时也学到了一些新的写法和awt的用法，比如图片旋转；把游戏逻辑单写成一个类来封装；对于按键监听的press，release双操作。下一次，我想复写一下马里奥（mario），以此结束Jframe这个模块。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trex up</title>
      <link href="/2019/12/28/trex-up/"/>
      <url>/2019/12/28/trex-up/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾：">前情回顾：</h4><p>不知道从那一年开始，这个不重要。 google 设计师在每次chrome断网时加入了一个彩蛋，此时此刻，将会出现一只萌萌的短腿霸王龙（Trex）开始原地踏步，然后点击space此时小恐龙向上蹦一下。然后接连出现仙人掌和小鸟，在我们灵力的操作下霸王龙躲避一个个障碍。隔一段时间，背景变为黑色，随着跨过障碍物越多，分数越高。</p><p>这个游戏操作简单，玩起来简单快捷。同时缓解了我们在断网时候的焦急，可以说这只萌萌的霸王龙可谓成为了网络萌宠，流量大咖。这篇文章我们来聊聊从0实现这个小恐龙，别小瞧这一个简单的游戏，在其背后google工程师也是写几千行的js代码, 其背后的逻辑以及设计确实有很多为人称赞之处。在看过源码之后，我用java还实现这个高仿版的小恐龙跳一跳，也是参考 学习google的思路。</p><p>此文章我通过以下六部分来具体讲述，可以说这个简单的小游戏结合了UI，窗口，监听器，面向对象非常适合我们用来练习。</p><h4 id="1背景绘制">1背景绘制</h4><p>首先我们需要明确窗口的概念，JFrame&gt;JPanel&gt;ContentPanel。因此我们从网上找到资源（大家可以直接上我github上下载，链接在文章底部），然后通过设置JFrame的setbounds内置方法来设定窗口的大小。这块有两点需要注意，首先如何更改查看图片的大小，我用的是Mac，通过预览可以直接查看，并且调整图片的大小。</p><p>这里我就不多赘述，我自己测试过很多次之后，在宽734高286pixel是可以达到不错的小显示效果。第二点，setbounds这个函数有四个参数，X，Y，width，height。宽和高就是图片的宽和高，X，Y和我们现实生活的坐标系有一点差别，屏幕的左上顶点就是（0，0）的位置，这个刚开始可能不大适应，写多了就习惯了。然后把屏幕放在剧中的的位置，设置可见，标题。这些都是由内置的函数，可以直接调用，最后给大家看一下效果。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><h4 id="2-绘制小恐龙-踏步-跳跃">2 绘制小恐龙 踏步 跳跃</h4><h5 id="第一步-绘制静态小恐龙">第一步 绘制静态小恐龙</h5><p>和绘制地面背景一样，先找到一个小恐龙的图片，然后根据我们的背景调整小恐龙的大小。然后我们需要调整恐龙的坐标，将其放在陆地上。这些坐标问题感觉让我们一下回到了中学，推敲一个个坐标的位置。然而实际的游戏的开发是有游戏引擎的，所以可以简化位置的摆放，java本身的设计也不是用来写游戏，据我所知游戏还是多用c++的开发，现在可能随着unity的不断更新，cSharp也是不错的选择。我没有引擎，我就通过在本地的画图推算，测试坐标。</p><p>然后我们看一下效果, 这里因为背景图片width 734pixel，height 286pixel。我设定的小恐龙位置在（50，200）x, y分别指的是距离左上定点的像素。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 15.19.14.png" alt="Screenshot 2019-12-08 at 15.19.14" style="zoom:25%; "><h5 id="第二部-如何原地踏步">第二部 如何原地踏步</h5><p>这里就要引入一个图片与视频的概念。其实我们平时所看到的视频，是由一个一个图片快速更替而成。比如常见的24帧，指的是一秒钟扫过24张图片此时我们就感觉图片在动，就是我们平日所看到的视频。所以如何让小恐龙给大家一种原地踏步的感觉，大概思路就是找到两张图片，一张图片左脚着地，另一张图片右脚着地，然后这两张图片不停的交替。所以要实现这个功能我们需要引入一个单独的线程，其实和贪吃蛇差不多，我们需要小恐龙线程每隔10ms就去重新绘制次图片。然后我预设每100ms短腿小恐龙换一次着地腿。每次增加10ms，每次执行时对2取余数，为0则选用左脚着地图片，反之亦然。</p><h5 id="第三步-按下space键-小恐龙跳跃">第三步 按下space键 小恐龙跳跃</h5><p>这里引入一个按键监听器，当我们键盘点击space时，我们将小恐龙设置为跳跃状态，并更换一张新的图片，其实跳跃就是改变小恐龙的y坐标，我也是经过测试后，设置短腿霸王龙的跳跃高度为100像素。这里有一点特别需要注意，小恐龙跳跃一次后需要落地才能进行，下一次跳跃。因此我们设置一个值，每次跳跃了则y坐标变化，让其与地面坐标对比，如果小于等于则说明小恐龙在空中则无法再跳跃，返回地面。如果在地面上则可以再次跳跃。</p><h5 id="3-小恐龙移动">3 小恐龙移动</h5><p>这是一个很关键的一步，实现不难，关键是思想的转化，在我们的认知中我们认为是小恐龙在动通过跳跃躲避障碍。因此我打开了google的trex up做了一个实验，我把鼠标放在小恐龙头上，从始至终小恐龙一直与我的鼠标的y轴成一条垂直地面的直线。这说明小恐龙没有动，那么谁动了呢？答案就是图片在不停的从右向左以一定的速度在变化。</p><p>然而怎么能够实现这个呢，我在这里画一个图片（有点简陋，不要见怪）</p><img src="/2019/12/28/trex-up/pictureloop.png" alt="pictureloop" style="zoom:25%; "><p>如图所示，我们找到两张大小尺寸背景一模一样的图片，然后分别让两个图片的x坐标连接在一起，并且让两张图片一样的速度从右向左移动，当图片2到达x坐标为0时，图片1到达-734，然后我我们再把图片一放到图片二的后面。以此类推，循环往复，我们让背景动，小恐龙在原地。于是就给我们一种小恐龙动起来的感觉。</p><p>然后同样的道理，我们可以设置云彩，月亮，白天黑夜。（这里就不详细说了，感兴趣的小伙伴可以私信我）</p><h5 id="4-障碍物设置">4 障碍物设置</h5><p>现在小恐龙可以动可以跳，可以动，背景可以交替，现在我们就要设置障碍物。首先还是一样找资源，就是找图片。google trex up用到的障碍物是仙人掌和小鸟，我也就去找了仙人掌和小鸟。其中仙人掌有稍高一点的稍矮一点的，三个在一起的单独的。小鸟出现的位置是在大地和天空之间，有一定的飞行速度。然后找到资源后，我们需要对仙人掌进行摆放的测试，或者简单来讲我们可以把仙人掌直接设置为与小恐龙的y坐标相同。小鸟的y坐标我们可以生成一个随机数在大地和天空之间。</p><p>这里有一个关键的问题移动，我自己在开放的时候，看了很久为什么障碍物总是不停的出现在相同的地方。debug，trace之后发现，我设置了图片以3pixel每10ms向左移动，但是仙人掌却一直在原地，因此我需要对仙人掌也设置一个同样的速度。小鸟的话就需要多考虑一点，小鸟的速度比图片走的快，所以我对小鸟的速度，预设的高一点。</p><p>做完这些之后，为了让小鸟出现震动翅膀飞翔的效果，我对小鸟做了和小恐龙原地踏步一样的操作。对于障碍物的出现概率，我使用了和贪吃蛇随机出现桃子，苹果，橙子一样的机制。对不同种类的仙人掌和小鸟做一个概率设计，然后用一个变量代表出现的障碍物是什么。出现不同的障碍物刷新时加载相对应的图像。</p><p>做到这里，程序已经完成了70%，我们看一下效果</p><p>![Screenshot 2019-12-08 at 18.54.45](Screenshot 2019-12-08 at 18.54.45.png)</p><h4 id="5-碰撞检测">5 碰撞检测</h4><p>出现障碍物，我们就要考虑如何让小恐龙通过跳跃的方式躲避障碍物。这里我们就可以将小恐龙和障碍物分别看成两个矩形，然后取交集，如果不为空，则说明撞击了，game over，否则游戏继续。当然在这里，最简单的做法是，我们直接让对两个矩形求重合，这样可行，但对于游戏忠实玩家来说，这样做确实降低了游戏的可玩性，既然做了，我就希望可以做的最好。因此我在这里讲一下，我的做法，当然我也参考了网上的文章。</p><p>首先我们考虑小恐龙撞击障碍物可以假设为头和脚撞击，因此我们可以对小恐龙图片以整数倍放大，然后截取其头部和尾部（尽可能精确）。正如图所示，分别记录下两个矩形到左上顶点的坐标，以及两个矩形的长度和宽。同理对小鸟也进行同样操作，记录小鸟头部的矩形和尾部的矩形。接着对仙人掌取到碰撞区域，然后每次小恐龙遇到障碍物时，我们通过检测其有无重叠从而知道是否成功跨过障碍物。这里在调试的时候，有一个小技巧，我们可以通过填充矩形的方式观察，我们制定的碰撞区域是否合理。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 19.13.52.png" alt="Screenshot 2019-12-08 at 19.13.52" style="zoom:25%; "><img src="/2019/12/28/trex-up/Screenshot 2019-12-28 at 22.45.29.png" alt="Screenshot 2019-12-28 at 22.45.29" style="zoom:25%; "><p>比如，我把小恐龙的头部填充去测试我的碰撞。这一步确实很考验人的耐心。当然在现实生活中的碰撞检测，是有游戏引擎的，他是一个多边形，是有很多物理公式包含在里面，可以精确到像素与像素的碰撞。确实很多游戏引擎也都是机密不公开的，就像任天堂Nintendo</p><h4 id="6-分数计算，-game-over，-重新开始，-游戏暂停">6 分数计算， game over， 重新开始， 游戏暂停</h4><p>最后，我们来对游戏进行一个补充完善。分手计算，我们的方法很多，可以是通过时间，通过障碍物的数量。我就是通过时间计算分数，每隔50ms，增加一次小恐龙的分数。game over就是小恐龙碰撞到障碍物，我们对矩形取交集。如果不为空，则关闭线程，提示给玩家game over。重新开始，还是需要注意一点，就是移除所有旧的组建，新建新组建然后从新开始游戏。暂停，停止刷新游戏界面。分数显示，设置两个5位数，一个是记录，另一个是当前游戏的分数，游戏结束时从新结算，若打破游戏记录则更新。</p><p>到这里我们的小恐龙就做完了。通过这次的开发，除了温习旧知识，也学到了很多新的知识。也还有很多地方做的不够完美，比如没有加按键声音，昼夜交替做的不够平滑，小恐龙刷新的速度没有改变。总体来讲，完成了对于google 80%的仿写。</p><h4 id="源代码与素材均在我的github上">源代码与素材均在我的github上</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>greedy snake</title>
      <link href="/2019/12/28/greedy-snake/"/>
      <url>/2019/12/28/greedy-snake/</url>
      
        <content type="html"><![CDATA[<h4 id="前情提要">前情提要:</h4><p>相信所有人的童年里都玩过贪吃蛇，在那个智能手机还不发达的时代，诺基亚和摩托罗拉还是市场的霸主，那个时候手机大概每款手机里都有个贪吃蛇的游戏。当然，我这个文章不是和大家怀旧，还是本着以技术为主，记录生活的本质。其次，我觉得贪吃蛇这个项目简单有意思，非常适合新手入门学习java。</p><h4 id="开发原因：">开发原因：</h4><p>本周在工作中遇到了Jframe和线程的bug，JFrame应该是一项很老的技术，上学的时候被作为一门教学语言，常常配合着AWT和SWING来用。当然，就目前来讲，桌面应用还是微软的天下（window操作系统），winforms，wpf， uwp这些成型的mvvm框架，开发简洁，尤其是其前端的UI拖拽绘制界面，nuget一键下载各种包确实比JFrame好用很多。当然要是IOS系统，那就是苹果全家桶了，再往下说就太多了。所以回归正题，jframe虽然有点过时，但是由于java仍然还是还是服务端的中流砥柱，其稳定高效跨平台的特点还是被大家所青睐，再加上很多公司java项目存在已久，像替换不是那么简单一句话的事。所以在此复习一下JFrame和线程操作，同时也来重温一下童年。</p><h4 id="开发流程与工具：">开发流程与工具：</h4><p>Eclipse ID<br>Java8， JFrame， Swing，Graphics，Timer线程</p><p>首先我设置了一个1200<em>720pixel的画板， 然后将（25，75） - （850，625）的区域设置为贪吃蛇游戏区域。并把这个区域等分成25</em>25的小格子，长度为34个小盒子，宽为24个小盒子。其中蛇每次可以移动一个小盒子</p><h4 id="第一步：初始化蛇">第一步：初始化蛇</h4><p>刚开始蛇的长度为3，其中蛇头1，蛇身2。蛇头需要考虑到上下左右四个方向，我就依次找到了四个图片代替。对于蛇具体化的实现，二维list，或者listnode都可以，为了简便开发，我就用数组其实主题的逻辑思维都是一样。二维数组分别代表蛇的每一部分在x, y轴对应坐标。我初始化蛇的方向向右，给定蛇的具体坐标。然后我这里调用JPanel自带的Graphic类复写paint方法。分别画出头和身体。<br><img src="/2019/12/28/greedy-snake/initSnake.png" alt="initSnake" style="zoom:25%; "></p><h4 id="第二步：蛇的移动">第二步：蛇的移动</h4><p>这里有一个小的问题，需要大家注意，就是每次移动我们需要先移动身体在移动头。这里有点与现实生活相反，为什么这么做，如果我们先移动头的话，那么头位置改变后，身体指向的位置本应该是原来头的位置，现在却指向现在头的位置从而造成蛇移动后有一条直线变成了一个点。<br>其次就是按键加上监听，上下左右代表移动。<br><img src="/2019/12/28/greedy-snake/snakeMove.png" alt="snakeMove" style="zoom:25%; "></p><h4 id="第三步：吃食物">第三步：吃食物</h4><p>我初始化了四种食物，分别为橙子，桃，苹果，分别代表1，2，3分。还有毒药，吃过吃了毒药则减10分。因为苹果，桃，橙子的分数不同，所以概率也不同。然后蛇每吃掉一个水果后就会更新一个新的水果，如果一定时间内没有碰到毒药毒药则消失，一段时间后再次出现。这里有三点需要注意。</p><h5 id="1">1</h5><p>如何生成概率不同的随机数？这里有个小技巧。生成从1个随机数范围是从1到100，然后如果其小于50则返回橙子1分，大于50小于80则返回桃子2分，大于80小于100则返回苹果3分。其概率分别对应50%，30%和20%</p><h5 id="2">2</h5><p>如何生成水果和毒药？我们需要水果和毒药的坐标，生成两个数字x, y范围分别在（1，34）和（1，24）之间，然后乘25就是对应x，y轴的位置。然后每次需要确认，毒药和水果的位置没有重合, 并且没有和蛇重合。<br>&lt;img src=‘eatFood.png’ alt=‘eatFood’ style:&quot;zoom:25%; &quot; /&gt;</p><h5 id="3">3</h5><p>如何刷新水果和毒药的坐标？当蛇头的x, y坐标等于水果的位置则证明水果被吃掉，此时从新生成新水果。如果毒药被吃掉，看一下分数，小于0则游戏结束，大于等于零则仍可以继续。这里我用到一个timer的线程，每隔1ms观察一次。然后我再建另外一个毒药的timer线程，每隔15s，去看一下毒药是否存在，如果存在则消失一段时间然后再重新刷新位置，如果被吃掉了则直接刷新位置。</p><h4 id="第四步：game-over，-暂停-和-重新开始">第四步：game over， 暂停 和 重新开始</h4><p>有三种可能性造成游戏结束，第一蛇头撞击墙壁，这就是每次移动后，我们取到蛇头的方向，然后分别判断其是否等于边界坐标，如果不等则游戏继续。第二点，蛇头撞击蛇身体，这里我们可以用一次for循环，遍历蛇头和蛇身体坐标，如出现一次蛇身体等于蛇头，则证明重合了游戏结束。最后就是吃了毒药分数小于0，加一个判断条件即可。<br>暂停和重新开始都是按space，预设两个个boolean类型值，分别代表暂停和游戏失败。每次一按spce，先判断是游戏失败还是暂定，如有失败，则重启游戏，若暂停，则游戏继续。这里需要注意，不能在暂停时候移动蛇头，所以要多写一个条件。</p><p>&lt;img src=‘gameover_stop.png’ alt=‘gameover_stop’ style:&quot;zoom:25%; &quot; /&gt;<br>最后，我设置了一个变量作为游戏记录，分数更新则刷新纪录。</p><h4 id="资源及源代码">资源及源代码</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake</a></p><h4 id="展示">展示</h4><p>放上一个视频，看一小效果^*^<br><img src="/2019/12/28/greedy-snake/show.png" alt="show" style="zoom:25%;"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jframe </tag>
            
            <tag> game </tag>
            
            <tag> timer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>battle dev review</title>
      <link href="/2019/12/28/battle-dev-review/"/>
      <url>/2019/12/28/battle-dev-review/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾">前情回顾:</h4><p>周二晚上下班，感觉不是很累，于是颇有兴致的参加了一个叫battle dev的线上比赛，如果要是能拿到前三名，那奖励确实很丰厚，但是茫茫人海中，我也确实意识到自己还有很多待提高的方面。Ò<br>因此仅以下文，回顾并记录自己这次比赛中的收获。</p><h4 id="比赛形式：">比赛形式：</h4><p>时间两小时，题目五道题，难度逐渐增加，必须通过所有的test case测试，才能看到下一个题。编程语言不限定。</p><h4 id="第一题">第一题</h4><img src="/2019/12/28/battle-dev-review/question1.png" alt="question1" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question1.2.png" alt="question1.2" style="zoom:25%; "><p>眨眼一看，题目论述很长，其实是一道热身题，大概意思大家一起去出游，由于天气原因和突发状况，现在有一个人需要睡在没有帐篷的空地上。于是大家决定抽检，抽到最短的人去睡空地。<br>解法很多种，我就说一个我自己的解法。预设一个最小值，然后scanner不断扫描下一行，知道结束为止，如果发现有出现距离比预设值小，那么更换最小距离，并记录姓名，输出。<br>具体代码如下：<br><img src="/2019/12/28/battle-dev-review/solution1.png" alt="solution1" style="zoom:25%; "></p><h4 id="第二题">第二题</h4><img src="/2019/12/28/battle-dev-review/question2.png" alt="question2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question2.2.png" alt="question2.2" style="zoom:25%; "><p>同样也是论述很长，理解之后发现其问题也是不难，但很有意思，需要我们转化一下思维。因为当天我在做题时，也是犯了两次错误，才意识到他究竟想让我们求什么。题目大概说，为了庆祝奶奶的生日，某人决定用纸板去做装饰，告诉我们纸板可以重复使用，宽高都相同，只有长度不等。随机从纸箱中抽取四个纸板，可以对每个纸板裁剪成两半，让后我们保留自己用的一半，另一半扔掉，最后拼成最大一个正方形。问舍弃的面积<br>可以说这个题还是给我们挖了坑，我就是直直的往里跳，其实思路大概相同，四次取出的纸板长度总和再开平方得到的就是最大面积。我也是这么做的，相信第一次很多人和我的想法一样，然而这样做，我们就忽略了一个重要的条件，每次我们要将纸板分成两半，只能留一半。<br>所以需要我们换一个思维，反过来想，当我们舍弃的模板长度最小的时候，剩余的正方形面积则最大。我们每次最少舍弃多少木板，我们来抽象一个最坏的情况：</p><hr><p>First time : 5 cm<br>Second time : 4 cm  5 - &gt; 4.reject 1 cm<br>Third time : 3 cm.4 -&gt; 3  reject 1 cm * 2 + 1 cm<br>Fourth time 2 cm.3 -&gt; 2.reject 1 cm * 3 + 2 cm * 2 + 1 cm</p><hr><p>实际就是四次最小长度，剩下的就是最大正方形。 想到这里，那代码就很简单了，具体如下<br><img src="/2019/12/28/battle-dev-review/solution2.png" alt="solution2" style="zoom:25%; "></p><h4 id="第三题">第三题</h4><img src="/2019/12/28/battle-dev-review/question3.png" alt="question3" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.2.png" alt="question3.2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.3.png" alt="question3.3" style="zoom:25%; "><p>相比前两个题，第三题明显难度就提升了，实话说，当天我也是大概用掉40分钟才解决此问题。首先再读完题，由于之前在leetcode上碰到过一个与之相似问题，253 meeting room。leetcode问的是对于给出的时间表最少需要多少间教室。下一篇文章我会拿meeting room与这个题做对比，顺便复习总结一下优先队列。所以，读完题，我就已经想到要用priotity queue。<br>接下来说说这个题具体问什么，我们有n个电缆和m个request。每个request对应有起始时间和结束时间。问我们n个电缆是否满足m个request。如果满足，则输出电缆的使用顺序，反之亦然。<br>这个题有三点需要我们注意。第一，request是乱序的，所以我们需要用优先队列对其进行排序，用什么排序，按照题意，起始时间小的在前面，如果相同，则终止时间小的优先。第二，电缆数量不一定满足request的需求，所以需要我们在创建一个priority queue去记录电缆的时候用情况，如果有空闲电缆则可以直接使用。如没有则需要我们分类讨论，遍历正在使用的电缆，看看的当前电缆的开始时间前，是否有电缆可以使用完成。如果没有，则返回false，结束程序。第三点，也是最容易被忽视的一点，我也因为这个白白耗费15分钟，题目让我们输出的是电缆使用顺序，我们是要根据优先队列的弹出顺序决定电缆使用顺序，而不是自己顺序排列。<br>综上所述，我放上我自己的代码</p><p><img src="/2019/12/28/battle-dev-review/solution3.png" alt="solution3"></p><h4 id="第四题">第四题</h4><img src="/2019/12/28/battle-dev-review/question4.png" alt="question4" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question4.2.png" alt="question4.2" style="zoom:25%; "><p>当天我也是做到第四题，读题到写代码大概用了25分钟，然后就gg了。确实当时没有做出来，我在这里就说说题目的大概意思，以及我记得思路，这个题题目里给了提示联想背包问题。所以我们可以很快的想到用动态规划解决。但是相比于背包问题，这个题有点特殊，他的粉末可以按克买，所以还需要再去讨论。<br>题目，给出n种宝石，m种粉末，给出每种宝石的重量和价钱（不可拆分），给出每种粉末的价格，可以按照g来买。给定一个重量问怎么能获得对大利益？</p><hr><p>大致思路，二维dp数组dp[i+1][j+1], i代表种类，j代表数量。终止条件超出重量j<br>第一次列出，只用一种宝石的情况，最大的利润。<br>第二到N次，以此类推，max（dp[i][j-1]+Vi*Wi, dp[i][j])</p><hr><p>关键是粉末可以拆分成g，所以数据规模很大，我当时是将每个粉末拆分成g在此讨论可能是超时，没有通过，我会再修改修改更新文章与大家讨论。</p><h4 id="收获">收获:</h4><p>简短的来说，还是意识到自己的不足，第一语言方面，读题理解时间过长，每道题要白白消耗掉10分钟完全用于读题理解，说明语言还需要精进。第二，做不到学以致用，还是缺乏将实际应用问题段时间联想到已知技术。第三，动态规划和graph的问题一直都是自己的短板，需要专项提升。</p>]]></content>
      
      
      <categories>
          
          <category> Programming contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priorityqueue </tag>
            
            <tag> dynamique programming </tag>
            
            <tag> string </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sliding window1</title>
      <link href="/2019/12/28/sliding-window1/"/>
      <url>/2019/12/28/sliding-window1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/12/28/sliding-window1/slidingwindow1.jpeg" alt="slidingwindow1"></p><p>sliding window直译为滑动窗口，大家可能直接会想到我们平时生活中的推拉窗户。在我们实际编程中，他也正是模拟这个生活中的场景，先去拉一个窗户，再去推另一个窗户。这个过程中我们分别用两个变量去代表这两个窗户，一快一慢，一左一右，这也是我们经常提到双指针问题。虽然在java，python，javascript，Csharp… … 等诸如此类的面向对象高级程序语言中，我们已经对指针弱化，将其变为对变量的引用，很大程度上简化了开发，但是指针的思想在我看来却仍然适用，而且加深对其的理解也有助于我们的编程。因此在思考了很久之后，我将sliding window这个主题作为我的第一篇文章。</p><h4 id="导语">导语:</h4><p>首先，sliding window，无论是我们熟知的🇨🇳大厂，百度，腾讯，阿里，头条… 或是美帝的google，amazon，fb，netflix… . 都十分青睐用此类型题目 去考察面试者。回过头想为什么，仅以我现在的知识我觉得，此类型问题本身并不复杂，问题的难点主要在两点 ：1 如何在面试中将问题理解，并能够想到用sliding window去解决这类问题 ，尤其是模拟实际生活的题，更是需要我们融会贯通。2 实现过程中有很多小的细节需要注意，例如窗口的滑动，触发一定的条件，左右指针不断的变化，导致结果随之变化，因此我们在实际手撕代码的过程中，经常出现bug。因此本文从算法分析，思路解析，再结合题目与代码去谈这个问题。。。废话不多说，进入正题。</p><h4 id="算法分">算法分</h4><p>滑动窗口大多数是用双指针求解，也有一些特殊的问题我们会结合一些特殊的数据结构，例如sorted_map（priority queue）或者的dequeue。对于此类特定的题型，我会在第二篇文章中讲述。本文主要讲述一般情况下的sliding window解决思路。</p><p>一般情况下的sliding window会给予我们一个特定数组或者字符串，让我们去找到满足一定条件的子数组或子字符串。比如：<br>找到最短字符串包含特定字符（有重复，无重复）<br>最长的子数组或字符串最多含有k个字符<br>最长的子数组或字符串只含有k个字符<br>一个特定的字符串在长字符串中出现的位置<br>……….</p><p>此类型题的大概时间复杂度为o(n)，需要遍历一次长字符串, 空间复杂度大多为常熟级别，近似于int[128]。之所以称为sliding window是由于，我们分别用快慢两个指针一前一后夹着字符串遍历，类似于一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。</p><h4 id="解题思路">解题思路</h4><p>这类型题的整体思路是设置两个快慢指针。快指针从左向右移动，目的是在每个快指针停留的位置，触发一定的条件，然后慢指针再随之移动，当其满足某种条件后，快指针再移动，周而复始，直到字符串遍历完毕，退出循环。<br>因此重点就在于，什么时候移动窗口，什么时候窗口保持不变。下面我写一个伪代码模版，给大家参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">sildingwindow</span><span class="params">(String [] strs. .. )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理边界条件  参数判断</span></span><br><span class="line">If( condition )</span><br><span class="line"> <span class="keyword">return</span> </span><br><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="comment">//left 代表窗口左边， 慢指针</span></span><br><span class="line"><span class="comment">//count 计数，用于判断何时触发条件</span></span><br><span class="line"><span class="comment">//result 记录结果</span></span><br><span class="line">Int left = <span class="number">0</span>, count = <span class="number">0</span> ,result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//申请一个hash数组, 也可用其他数据结构比如hashmap</span></span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> hash[<span class="number">128</span>]</span><br><span class="line"><span class="comment">//遍历数组，right代表窗口右侧，快指针</span></span><br><span class="line">For(<span class="keyword">int</span> right = <span class="number">0</span>; right&lt;strs.length;right++)&#123;</span><br><span class="line"><span class="comment">//每次移动一个格子后，更新hash</span></span><br><span class="line">Hash[strs[right]]++;</span><br><span class="line"><span class="comment">//更具窗口变更来改变条件</span></span><br><span class="line">If(Hash[strs[right]] = ..)</span><br><span class="line">&#123;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前条件不满足，移动左指针直至条件满足为止 </span></span><br><span class="line"><span class="keyword">while</span> (count &gt; ..) </span><br><span class="line">&#123; </span><br><span class="line">  …</span><br><span class="line">   <span class="keyword">if</span> (…)</span><br><span class="line">  &#123; </span><br><span class="line">​     count—; </span><br><span class="line">   &#125; </span><br><span class="line">   hash[A[l]]++;</span><br><span class="line">​    left++; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//条件根据具体题目要求确定返回结果</span></span><br><span class="line">res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典例题">经典例题</h4><p>leetcode 3 Longest Substring Without Repeating Characters<br>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><strong>Example 3:</strong><br><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is “wke”, with the length of 3.<br>​       Note that the answer must be a <strong>substring</strong>, “pwke” is a <em>subsequence</em> and not a substring.<br>题目很通俗易懂，给一个字符串，让我找到一个最长子字符串，要求其不包含重复元素。<br>解题思路：第一次看到这个题我们，会很快想到brute force解法，两个for循环遍历字符串，外层循环代表其实位置，内层循环代表终止位置，写一个函数判断字符串是否含有重复元素。为了对比出sliding window优势，我也写了此方法做对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = s.length(); </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (allUnique(s, i, j))</span><br><span class="line">ans = Math.max(ans, j - i); </span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">Character ch = s.charAt(i); </span><br><span class="line"><span class="keyword">if</span> (set.contains(ch))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">set.add(ch); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法时间复杂度为O(n^3) 三次遍历<br>但是如果我们要使用sliding window来解决此问题。我们不需要用n^2的时间复杂度去遍历字符串，假如我们已经验证从i - j不存在重复字符，那么我们可以把慢指针指向j，而不需要再从新遍历 i - j。然后通过对比result与快慢指针中间字符串的长度来得到最后结果。<br>以下，为代码示例，通常情况下提到检验重复，我们大多数会用到set。所以，我先写了一个set的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> n = s.length(); </span><br><span class="line">​    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">​    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">​    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">​      <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">​      <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">​        set.add(s.charAt(j++)); </span><br><span class="line">​        ans = Math.max(ans, j - i); </span><br><span class="line">​      &#125;</span><br><span class="line">​      <span class="keyword">else</span> &#123;</span><br><span class="line">​        set.remove(s.charAt(i++)); </span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此解法可以，但是其最坏时间复杂度为2n，就是快慢指针分别都把字符串从头到尾访问一遍。类似于“aabbcc”<br>以下，为通用的sliding window 解法，我们可以引入hashmap，key代表访问字符，value代表字符出现次数。当hashmap中某一个key的值大于1，于是我们尝试移动慢指针，在map中, 把慢指针指向的值的频率减1。在这里有个小技巧，我们可以用一个128长度的int数组来表示，ASCII table 65-92 对应 a-z， 97 - 122 对应A - Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">hash[c[i]]++; </span><br><span class="line"><span class="keyword">while</span> (hash[c[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">hash[c[left]]--; </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">map.put(c[i], map.getOrDefault(c[i], <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (map.get(c[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">map.put(c[left], map.get(c[left]) - <span class="number">1</span>); </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>之后我会陆续在写两篇关于sliding window的文章，列出所有我见过的有意思并且具有代表性的题，归类讲解。当然我不是大神，所以如果文章或者算法上哪里有问题还请各位轻喷多指点！！！<br>示例代码为了便于大家理解，我都写的java，当然我会把c++和python版本的代码放到我的github上。算法题主要是思路，所以语言上基本都是互通，如果大家有需要与其他的语言，Csharp, javascript…私信我，非常乐意把大家debug。</p><p>放上我自己的github：<a href="https://github.com/wuhewuhe/AlgorithmeSource" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
