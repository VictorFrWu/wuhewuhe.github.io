<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LRU</title>
      <link href="/2019/12/28/LRU/"/>
      <url>/2019/12/28/LRU/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tetris</title>
      <link href="/2019/12/28/tetris/"/>
      <url>/2019/12/28/tetris/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flappy bird</title>
      <link href="/2019/12/28/flappy-bird/"/>
      <url>/2019/12/28/flappy-bird/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>trex up</title>
      <link href="/2019/12/28/trex-up/"/>
      <url>/2019/12/28/trex-up/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾："><a class="header-anchor" href="#前情回顾："></a>前情回顾：</h4><p>不知道从那一年开始，这个不重要。 google 设计师在每次chrome断网时加入了一个彩蛋，此时此刻，将会出现一只萌萌的短腿霸王龙（Trex）开始原地踏步，然后点击space此时小恐龙向上蹦一下。然后接连出现仙人掌和小鸟，在我们灵力的操作下霸王龙躲避一个个障碍。隔一段时间，背景变为黑色，随着跨过障碍物越多，分数越高。</p><p>这个游戏操作简单，玩起来简单快捷。同时缓解了我们在断网时候的焦急，可以说这只萌萌的霸王龙可谓成为了网络萌宠，流量大咖。这篇文章我们来聊聊从0实现这个小恐龙，别小瞧这一个简单的游戏，在其背后google工程师也是写几千行的js代码, 其背后的逻辑以及设计确实有很多为人称赞之处。在看过源码之后，我用java还实现这个高仿版的小恐龙跳一跳，也是参考 学习google的思路。</p><p>此文章我通过以下六部分来具体讲述，可以说这个简单的小游戏结合了UI，窗口，监听器，面向对象非常适合我们用来练习。</p><h4 id="1背景绘制"><a class="header-anchor" href="#1背景绘制"></a>1背景绘制</h4><p>首先我们需要明确窗口的概念，JFrame&gt;JPanel&gt;ContentPanel。因此我们从网上找到资源（大家可以直接上我github上下载，链接在文章底部），然后通过设置JFrame的setbounds内置方法来设定窗口的大小。这块有两点需要注意，首先如何更改查看图片的大小，我用的是Mac，通过预览可以直接查看，并且调整图片的大小。</p><p>这里我就不多赘述，我自己测试过很多次之后，在宽734高286pixel是可以达到不错的小显示效果。第二点，setbounds这个函数有四个参数，X，Y，width，height。宽和高就是图片的宽和高，X，Y和我们现实生活的坐标系有一点差别，屏幕的左上顶点就是（0，0）的位置，这个刚开始可能不大适应，写多了就习惯了。然后把屏幕放在剧中的的位置，设置可见，标题。这些都是由内置的函数，可以直接调用，最后给大家看一下效果。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 14.50.02.png" alt="Screenshot 2019-12-08 at 14.50.02" style="zoom:25%; "><p>![Screenshot 2019-12-08 at 14.50.24](Screenshot 2019-12-08 at 14.50.24.png)</p><h4 id="2-绘制小恐龙-踏步-跳跃"><a class="header-anchor" href="#2-绘制小恐龙-踏步-跳跃"></a>2 绘制小恐龙 踏步 跳跃</h4><h5 id="第一步-绘制静态小恐龙"><a class="header-anchor" href="#第一步-绘制静态小恐龙"></a>第一步 绘制静态小恐龙</h5><p>和绘制地面背景一样，先找到一个小恐龙的图片，然后根据我们的背景调整小恐龙的大小。然后我们需要调整恐龙的坐标，将其放在陆地上。这些坐标问题感觉让我们一下回到了中学，推敲一个个坐标的位置。然而实际的游戏的开发是有游戏引擎的，所以可以简化位置的摆放，java本身的设计也不是用来写游戏，据我所知游戏还是多用c++的开发，现在可能随着unity的不断更新，cSharp也是不错的选择。我没有引擎，我就通过在本地的画图推算，测试坐标。</p><p>然后我们看一下效果, 这里因为背景图片width 734pixel，height 286pixel。我设定的小恐龙位置在（50，200）x, y分别指的是距离左上定点的像素。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 15.19.14.png" alt="Screenshot 2019-12-08 at 15.19.14" style="zoom:25%; "><h5 id="第二部-如何原地踏步"><a class="header-anchor" href="#第二部-如何原地踏步"></a>第二部 如何原地踏步</h5><p>这里就要引入一个图片与视频的概念。其实我们平时所看到的视频，是由一个一个图片快速更替而成。比如常见的24帧，指的是一秒钟扫过24张图片此时我们就感觉图片在动，就是我们平日所看到的视频。所以如何让小恐龙给大家一种原地踏步的感觉，大概思路就是找到两张图片，一张图片左脚着地，另一张图片右脚着地，然后这两张图片不停的交替。所以要实现这个功能我们需要引入一个单独的线程，其实和贪吃蛇差不多，我们需要小恐龙线程每隔10ms就去重新绘制次图片。然后我预设每100ms短腿小恐龙换一次着地腿。每次增加10ms，每次执行时对2取余数，为0则选用左脚着地图片，反之亦然。</p><h5 id="第三步-按下space键-小恐龙跳跃"><a class="header-anchor" href="#第三步-按下space键-小恐龙跳跃"></a>第三步 按下space键 小恐龙跳跃</h5><p>这里引入一个按键监听器，当我们键盘点击space时，我们将小恐龙设置为跳跃状态，并更换一张新的图片，其实跳跃就是改变小恐龙的y坐标，我也是经过测试后，设置短腿霸王龙的跳跃高度为100像素。这里有一点特别需要注意，小恐龙跳跃一次后需要落地才能进行，下一次跳跃。因此我们设置一个值，每次跳跃了则y坐标变化，让其与地面坐标对比，如果小于等于则说明小恐龙在空中则无法再跳跃，返回地面。如果在地面上则可以再次跳跃。</p><h5 id="3-小恐龙移动"><a class="header-anchor" href="#3-小恐龙移动"></a>3 小恐龙移动</h5><p>这是一个很关键的一步，实现不难，关键是思想的转化，在我们的认知中我们认为是小恐龙在动通过跳跃躲避障碍。因此我打开了google的trex up做了一个实验，我把鼠标放在小恐龙头上，从始至终小恐龙一直与我的鼠标的y轴成一条垂直地面的直线。这说明小恐龙没有动，那么谁动了呢？答案就是图片在不停的从右向左以一定的速度在变化。</p><p>然而怎么能够实现这个呢，我在这里画一个图片（有点简陋，不要见怪）</p><img src="/2019/12/28/trex-up/pictureloop.png" alt="pictureloop" style="zoom:25%; "><p>如图所示，我们找到两张大小尺寸背景一模一样的图片，然后分别让两个图片的x坐标连接在一起，并且让两张图片一样的速度从右向左移动，当图片2到达x坐标为0时，图片1到达-734，然后我我们再把图片一放到图片二的后面。以此类推，循环往复，我们让背景动，小恐龙在原地。于是就给我们一种小恐龙动起来的感觉。</p><p>然后同样的道理，我们可以设置云彩，月亮，白天黑夜。（这里就不详细说了，感兴趣的小伙伴可以私信我）</p><h5 id="4-障碍物设置"><a class="header-anchor" href="#4-障碍物设置"></a>4 障碍物设置</h5><p>现在小恐龙可以动可以跳，可以动，背景可以交替，现在我们就要设置障碍物。首先还是一样找资源，就是找图片。google trex up用到的障碍物是仙人掌和小鸟，我也就去找了仙人掌和小鸟。其中仙人掌有稍高一点的稍矮一点的，三个在一起的单独的。小鸟出现的位置是在大地和天空之间，有一定的飞行速度。然后找到资源后，我们需要对仙人掌进行摆放的测试，或者简单来讲我们可以把仙人掌直接设置为与小恐龙的y坐标相同。小鸟的y坐标我们可以生成一个随机数在大地和天空之间。</p><p>这里有一个关键的问题移动，我自己在开放的时候，看了很久为什么障碍物总是不停的出现在相同的地方。debug，trace之后发现，我设置了图片以3pixel每10ms向左移动，但是仙人掌却一直在原地，因此我需要对仙人掌也设置一个同样的速度。小鸟的话就需要多考虑一点，小鸟的速度比图片走的快，所以我对小鸟的速度，预设的高一点。</p><p>做完这些之后，为了让小鸟出现震动翅膀飞翔的效果，我对小鸟做了和小恐龙原地踏步一样的操作。对于障碍物的出现概率，我使用了和贪吃蛇随机出现桃子，苹果，橙子一样的机制。对不同种类的仙人掌和小鸟做一个概率设计，然后用一个变量代表出现的障碍物是什么。出现不同的障碍物刷新时加载相对应的图像。</p><p>做到这里，程序已经完成了70%，我们看一下效果</p><p>![Screenshot 2019-12-08 at 18.54.45](Screenshot 2019-12-08 at 18.54.45.png)</p><h4 id="5-碰撞检测"><a class="header-anchor" href="#5-碰撞检测"></a>5 碰撞检测</h4><p>出现障碍物，我们就要考虑如何让小恐龙通过跳跃的方式躲避障碍物。这里我们就可以将小恐龙和障碍物分别看成两个矩形，然后取交集，如果不为空，则说明撞击了，game over，否则游戏继续。当然在这里，最简单的做法是，我们直接让对两个矩形求重合，这样可行，但对于游戏忠实玩家来说，这样做确实降低了游戏的可玩性，既然做了，我就希望可以做的最好。因此我在这里讲一下，我的做法，当然我也参考了网上的文章。</p><p>首先我们考虑小恐龙撞击障碍物可以假设为头和脚撞击，因此我们可以对小恐龙图片以整数倍放大，然后截取其头部和尾部（尽可能精确）。正如图所示，分别记录下两个矩形到左上顶点的坐标，以及两个矩形的长度和宽。同理对小鸟也进行同样操作，记录小鸟头部的矩形和尾部的矩形。接着对仙人掌取到碰撞区域，然后每次小恐龙遇到障碍物时，我们通过检测其有无重叠从而知道是否成功跨过障碍物。这里在调试的时候，有一个小技巧，我们可以通过填充矩形的方式观察，我们制定的碰撞区域是否合理。</p><img src="/2019/12/28/trex-up/Screenshot 2019-12-08 at 19.13.52.png" alt="Screenshot 2019-12-08 at 19.13.52" style="zoom:25%; "><img src="/2019/12/28/trex-up/Screenshot 2019-12-28 at 22.45.29.png" alt="Screenshot 2019-12-28 at 22.45.29" style="zoom:25%; "><p>比如，我把小恐龙的头部填充去测试我的碰撞。这一步确实很考验人的耐心。当然在现实生活中的碰撞检测，是有游戏引擎的，他是一个多边形，是有很多物理公式包含在里面，可以精确到像素与像素的碰撞。确实很多游戏引擎也都是机密不公开的，就像任天堂Nintendo</p><h4 id="6-分数计算，-game-over，-重新开始，-游戏暂停"><a class="header-anchor" href="#6-分数计算，-game-over，-重新开始，-游戏暂停"></a>6 分数计算， game over， 重新开始， 游戏暂停</h4><p>最后，我们来对游戏进行一个补充完善。分手计算，我们的方法很多，可以是通过时间，通过障碍物的数量。我就是通过时间计算分数，每隔50ms，增加一次小恐龙的分数。game over就是小恐龙碰撞到障碍物，我们对矩形取交集。如果不为空，则关闭线程，提示给玩家game over。重新开始，还是需要注意一点，就是移除所有旧的组建，新建新组建然后从新开始游戏。暂停，停止刷新游戏界面。分数显示，设置两个5位数，一个是记录，另一个是当前游戏的分数，游戏结束时从新结算，若打破游戏记录则更新。</p><p>到这里我们的小恐龙就做完了。通过这次的开发，除了温习旧知识，也学到了很多新的知识。也还有很多地方做的不够完美，比如没有加按键声音，昼夜交替做的不够平滑，小恐龙刷新的速度没有改变。总体来讲，完成了对于google 80%的仿写。</p><h4 id="源代码与素材均在我的github上"><a class="header-anchor" href="#源代码与素材均在我的github上"></a>源代码与素材均在我的github上</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/DragonJump</a></p><h3 id="关注公众号-每周会有更多精彩的更新"><a class="header-anchor" href="#关注公众号-每周会有更多精彩的更新"></a>关注公众号 每周会有更多精彩的更新</h3><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzI5MTM4Njk1NQ==&amp;mid=100000078&amp;idx=1&amp;sn=c183b7cc5016e9f34330020a8e3b110a&amp;send_time=1577568956" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JFrame </tag>
            
            <tag> Game </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>greedy snake</title>
      <link href="/2019/12/28/greedy-snake/"/>
      <url>/2019/12/28/greedy-snake/</url>
      
        <content type="html"><![CDATA[<h4 id="前情提要"><a class="header-anchor" href="#前情提要"></a>前情提要:</h4><p>相信所有人的童年里都玩过贪吃蛇，在那个智能手机还不发达的时代，诺基亚和摩托罗拉还是市场的霸主，那个时候手机大概每款手机里都有个贪吃蛇的游戏。当然，我这个文章不是和大家怀旧，还是本着以技术为主，记录生活的本质。其次，我觉得贪吃蛇这个项目简单有意思，非常适合新手入门学习java。</p><h4 id="开发原因："><a class="header-anchor" href="#开发原因："></a>开发原因：</h4><p>本周在工作中遇到了Jframe和线程的bug，JFrame应该是一项很老的技术，上学的时候被作为一门教学语言，常常配合着AWT和SWING来用。当然，就目前来讲，桌面应用还是微软的天下（window操作系统），winforms，wpf， uwp这些成型的mvvm框架，开发简洁，尤其是其前端的UI拖拽绘制界面，nuget一键下载各种包确实比JFrame好用很多。当然要是IOS系统，那就是苹果全家桶了，再往下说就太多了。所以回归正题，jframe虽然有点过时，但是由于java仍然还是还是服务端的中流砥柱，其稳定高效跨平台的特点还是被大家所青睐，再加上很多公司java项目存在已久，像替换不是那么简单一句话的事。所以在此复习一下JFrame和线程操作，同时也来重温一下童年。</p><h4 id="开发流程与工具："><a class="header-anchor" href="#开发流程与工具："></a>开发流程与工具：</h4><p>Eclipse ID<br>Java8， JFrame， Swing，Graphics，Timer线程</p><p>首先我设置了一个1200<em>720pixel的画板， 然后将（25，75） - （850，625）的区域设置为贪吃蛇游戏区域。并把这个区域等分成25</em>25的小格子，长度为34个小盒子，宽为24个小盒子。其中蛇每次可以移动一个小盒子</p><h4 id="第一步：初始化蛇"><a class="header-anchor" href="#第一步：初始化蛇"></a>第一步：初始化蛇</h4><p>刚开始蛇的长度为3，其中蛇头1，蛇身2。蛇头需要考虑到上下左右四个方向，我就依次找到了四个图片代替。对于蛇具体化的实现，二维list，或者listnode都可以，为了简便开发，我就用数组其实主题的逻辑思维都是一样。二维数组分别代表蛇的每一部分在x, y轴对应坐标。我初始化蛇的方向向右，给定蛇的具体坐标。然后我这里调用JPanel自带的Graphic类复写paint方法。分别画出头和身体。<br><img src="/2019/12/28/greedy-snake/initSnake.png" alt="initSnake" style="zoom:25%; "></p><h4 id="第二步：蛇的移动"><a class="header-anchor" href="#第二步：蛇的移动"></a>第二步：蛇的移动</h4><p>这里有一个小的问题，需要大家注意，就是每次移动我们需要先移动身体在移动头。这里有点与现实生活相反，为什么这么做，如果我们先移动头的话，那么头位置改变后，身体指向的位置本应该是原来头的位置，现在却指向现在头的位置从而造成蛇移动后有一条直线变成了一个点。<br>其次就是按键加上监听，上下左右代表移动。<br><img src="/2019/12/28/greedy-snake/snakeMove.png" alt="snakeMove" style="zoom:25%; "></p><h4 id="第三步：吃食物"><a class="header-anchor" href="#第三步：吃食物"></a>第三步：吃食物</h4><p>我初始化了四种食物，分别为橙子，桃，苹果，分别代表1，2，3分。还有毒药，吃过吃了毒药则减10分。因为苹果，桃，橙子的分数不同，所以概率也不同。然后蛇每吃掉一个水果后就会更新一个新的水果，如果一定时间内没有碰到毒药毒药则消失，一段时间后再次出现。这里有三点需要注意。</p><h5 id="1"><a class="header-anchor" href="#1"></a>1</h5><p>如何生成概率不同的随机数？这里有个小技巧。生成从1个随机数范围是从1到100，然后如果其小于50则返回橙子1分，大于50小于80则返回桃子2分，大于80小于100则返回苹果3分。其概率分别对应50%，30%和20%</p><h5 id="2"><a class="header-anchor" href="#2"></a>2</h5><p>如何生成水果和毒药？我们需要水果和毒药的坐标，生成两个数字x, y范围分别在（1，34）和（1，24）之间，然后乘25就是对应x，y轴的位置。然后每次需要确认，毒药和水果的位置没有重合, 并且没有和蛇重合。<br>&lt;img src=‘eatFood.png’ alt=‘eatFood’ style:&quot;zoom:25%; &quot; /&gt;</p><h5 id="3"><a class="header-anchor" href="#3"></a>3</h5><p>如何刷新水果和毒药的坐标？当蛇头的x, y坐标等于水果的位置则证明水果被吃掉，此时从新生成新水果。如果毒药被吃掉，看一下分数，小于0则游戏结束，大于等于零则仍可以继续。这里我用到一个timer的线程，每隔1ms观察一次。然后我再建另外一个毒药的timer线程，每隔15s，去看一下毒药是否存在，如果存在则消失一段时间然后再重新刷新位置，如果被吃掉了则直接刷新位置。</p><h4 id="第四步：game-over，-暂停-和-重新开始"><a class="header-anchor" href="#第四步：game-over，-暂停-和-重新开始"></a>第四步：game over， 暂停 和 重新开始</h4><p>有三种可能性造成游戏结束，第一蛇头撞击墙壁，这就是每次移动后，我们取到蛇头的方向，然后分别判断其是否等于边界坐标，如果不等则游戏继续。第二点，蛇头撞击蛇身体，这里我们可以用一次for循环，遍历蛇头和蛇身体坐标，如出现一次蛇身体等于蛇头，则证明重合了游戏结束。最后就是吃了毒药分数小于0，加一个判断条件即可。<br>暂停和重新开始都是按space，预设两个个boolean类型值，分别代表暂停和游戏失败。每次一按spce，先判断是游戏失败还是暂定，如有失败，则重启游戏，若暂停，则游戏继续。这里需要注意，不能在暂停时候移动蛇头，所以要多写一个条件。</p><p>&lt;img src=‘gameover_stop.png’ alt=‘gameover_stop’ style:&quot;zoom:25%; &quot; /&gt;<br>最后，我设置了一个变量作为游戏记录，分数更新则刷新纪录。</p><h4 id="资源及源代码"><a class="header-anchor" href="#资源及源代码"></a>资源及源代码</h4><p><a href="https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource/tree/master/BlogNotes/src/main/java/GreedySnake</a></p><h4 id="展示"><a class="header-anchor" href="#展示"></a>展示</h4><p>放上一个视频，看一小效果<sup>*</sup><br><img src="/2019/12/28/greedy-snake/show.png" alt="show" style="zoom:25%;"></p><h3 id="关注公众号-每周会有更多精彩的更新"><a class="header-anchor" href="#关注公众号-每周会有更多精彩的更新"></a>关注公众号 每周会有更多精彩的更新</h3><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzI5MTM4Njk1NQ==&amp;mid=100000078&amp;idx=1&amp;sn=c183b7cc5016e9f34330020a8e3b110a&amp;send_time=1577568956" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
            <tag> JFrame </tag>
            
            <tag> Timer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>battle dev review</title>
      <link href="/2019/12/28/battle-dev-review/"/>
      <url>/2019/12/28/battle-dev-review/</url>
      
        <content type="html"><![CDATA[<h4 id="前情回顾"><a class="header-anchor" href="#前情回顾"></a>前情回顾:</h4><p>周二晚上下班，感觉不是很累，于是颇有兴致的参加了一个叫battle dev的线上比赛，如果要是能拿到前三名，那奖励确实很丰厚，但是茫茫人海中，我也确实意识到自己还有很多待提高的方面。Ò<br>因此仅以下文，回顾并记录自己这次比赛中的收获。</p><h4 id="比赛形式："><a class="header-anchor" href="#比赛形式："></a>比赛形式：</h4><p>时间两小时，题目五道题，难度逐渐增加，必须通过所有的test case测试，才能看到下一个题。编程语言不限定。</p><h4 id="第一题"><a class="header-anchor" href="#第一题"></a>第一题</h4><img src="/2019/12/28/battle-dev-review/question1.png" alt="question1" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question1.2.png" alt="question1.2" style="zoom:25%; "><p>眨眼一看，题目论述很长，其实是一道热身题，大概意思大家一起去出游，由于天气原因和突发状况，现在有一个人需要睡在没有帐篷的空地上。于是大家决定抽检，抽到最短的人去睡空地。<br>解法很多种，我就说一个我自己的解法。预设一个最小值，然后scanner不断扫描下一行，知道结束为止，如果发现有出现距离比预设值小，那么更换最小距离，并记录姓名，输出。<br>具体代码如下：<br><img src="/2019/12/28/battle-dev-review/solution1.png" alt="solution1" style="zoom:25%; "></p><h4 id="第二题"><a class="header-anchor" href="#第二题"></a>第二题</h4><img src="/2019/12/28/battle-dev-review/question2.png" alt="question2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question2.2.png" alt="question2.2" style="zoom:25%; "><p>同样也是论述很长，理解之后发现其问题也是不难，但很有意思，需要我们转化一下思维。因为当天我在做题时，也是犯了两次错误，才意识到他究竟想让我们求什么。题目大概说，为了庆祝奶奶的生日，某人决定用纸板去做装饰，告诉我们纸板可以重复使用，宽高都相同，只有长度不等。随机从纸箱中抽取四个纸板，可以对每个纸板裁剪成两半，让后我们保留自己用的一半，另一半扔掉，最后拼成最大一个正方形。问舍弃的面积<br>可以说这个题还是给我们挖了坑，我就是直直的往里跳，其实思路大概相同，四次取出的纸板长度总和再开平方得到的就是最大面积。我也是这么做的，相信第一次很多人和我的想法一样，然而这样做，我们就忽略了一个重要的条件，每次我们要将纸板分成两半，只能留一半。<br>所以需要我们换一个思维，反过来想，当我们舍弃的模板长度最小的时候，剩余的正方形面积则最大。我们每次最少舍弃多少木板，我们来抽象一个最坏的情况：</p><hr><p>First time : 5 cm<br>Second time : 4 cm  5 - &gt; 4.reject 1 cm<br>Third time : 3 cm.4 -&gt; 3  reject 1 cm * 2 + 1 cm<br>Fourth time 2 cm.3 -&gt; 2.reject 1 cm * 3 + 2 cm * 2 + 1 cm</p><hr><p>实际就是四次最小长度，剩下的就是最大正方形。 想到这里，那代码就很简单了，具体如下<br><img src="/2019/12/28/battle-dev-review/solution2.png" alt="solution2" style="zoom:25%; "></p><h4 id="第三题"><a class="header-anchor" href="#第三题"></a>第三题</h4><img src="/2019/12/28/battle-dev-review/question3.png" alt="question3" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.2.png" alt="question3.2" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question3.3.png" alt="question3.3" style="zoom:25%; "><p>相比前两个题，第三题明显难度就提升了，实话说，当天我也是大概用掉40分钟才解决此问题。首先再读完题，由于之前在leetcode上碰到过一个与之相似问题，253 meeting room。leetcode问的是对于给出的时间表最少需要多少间教室。下一篇文章我会拿meeting room与这个题做对比，顺便复习总结一下优先队列。所以，读完题，我就已经想到要用priotity queue。<br>接下来说说这个题具体问什么，我们有n个电缆和m个request。每个request对应有起始时间和结束时间。问我们n个电缆是否满足m个request。如果满足，则输出电缆的使用顺序，反之亦然。<br>这个题有三点需要我们注意。第一，request是乱序的，所以我们需要用优先队列对其进行排序，用什么排序，按照题意，起始时间小的在前面，如果相同，则终止时间小的优先。第二，电缆数量不一定满足request的需求，所以需要我们在创建一个priority queue去记录电缆的时候用情况，如果有空闲电缆则可以直接使用。如没有则需要我们分类讨论，遍历正在使用的电缆，看看的当前电缆的开始时间前，是否有电缆可以使用完成。如果没有，则返回false，结束程序。第三点，也是最容易被忽视的一点，我也因为这个白白耗费15分钟，题目让我们输出的是电缆使用顺序，我们是要根据优先队列的弹出顺序决定电缆使用顺序，而不是自己顺序排列。<br>综上所述，我放上我自己的代码</p><p><img src="/2019/12/28/battle-dev-review/solution3.png" alt="solution3"></p><h4 id="第四题"><a class="header-anchor" href="#第四题"></a>第四题</h4><img src="/2019/12/28/battle-dev-review/question4.png" alt="question4" style="zoom:25%; "><img src="/2019/12/28/battle-dev-review/question4.2.png" alt="question4.2" style="zoom:25%; "><p>当天我也是做到第四题，读题到写代码大概用了25分钟，然后就gg了。确实当时没有做出来，我在这里就说说题目的大概意思，以及我记得思路，这个题题目里给了提示联想背包问题。所以我们可以很快的想到用动态规划解决。但是相比于背包问题，这个题有点特殊，他的粉末可以按克买，所以还需要再去讨论。<br>题目，给出n种宝石，m种粉末，给出每种宝石的重量和价钱（不可拆分），给出每种粉末的价格，可以按照g来买。给定一个重量问怎么能获得对大利益？</p><hr><p>大致思路，二维dp数组dp[i+1][j+1], i代表种类，j代表数量。终止条件超出重量j<br>第一次列出，只用一种宝石的情况，最大的利润。<br>第二到N次，以此类推，max（dp[i][j-1]+Vi*Wi, dp[i][j])</p><hr><p>关键是粉末可以拆分成g，所以数据规模很大，我当时是将每个粉末拆分成g在此讨论可能是超时，没有通过，我会再修改修改更新文章与大家讨论。</p><h4 id="收获"><a class="header-anchor" href="#收获"></a>收获:</h4><p>简短的来说，还是意识到自己的不足，第一语言方面，读题理解时间过长，每道题要白白消耗掉10分钟完全用于读题理解，说明语言还需要精进。第二，做不到学以致用，还是缺乏将实际应用问题段时间联想到已知技术。第三，动态规划和graph的问题一直都是自己的短板，需要专项提升。</p><h3 id="关注公众号-每周会有更多精彩的更新"><a class="header-anchor" href="#关注公众号-每周会有更多精彩的更新"></a>关注公众号 每周会有更多精彩的更新</h3><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzI5MTM4Njk1NQ==&amp;mid=100000078&amp;idx=1&amp;sn=c183b7cc5016e9f34330020a8e3b110a&amp;send_time=1577568956" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> programming contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priorityqueue </tag>
            
            <tag> dynamique programming </tag>
            
            <tag> string </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sliding window1</title>
      <link href="/2019/12/28/sliding-window1/"/>
      <url>/2019/12/28/sliding-window1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/12/28/sliding-window1/slidingwindow1.jpeg" alt="slidingwindow1"></p><p>sliding window直译为滑动窗口，大家可能直接会想到我们平时生活中的推拉窗户。在我们实际编程中，他也正是模拟这个生活中的场景，先去拉一个窗户，再去推另一个窗户。这个过程中我们分别用两个变量去代表这两个窗户，一快一慢，一左一右，这也是我们经常提到双指针问题。虽然在java，python，javascript，Csharp… … 等诸如此类的面向对象高级程序语言中，我们已经对指针弱化，将其变为对变量的引用，很大程度上简化了开发，但是指针的思想在我看来却仍然适用，而且加深对其的理解也有助于我们的编程。因此在思考了很久之后，我将sliding window这个主题作为我的第一篇文章。</p><h4 id="导语"><a class="header-anchor" href="#导语"></a>导语:</h4><p>首先，sliding window，无论是我们熟知的🇨🇳大厂，百度，腾讯，阿里，头条… 或是美帝的google，amazon，fb，netflix… . 都十分青睐用此类型题目 去考察面试者。回过头想为什么，仅以我现在的知识我觉得，此类型问题本身并不复杂，问题的难点主要在两点 ：1 如何在面试中将问题理解，并能够想到用sliding window去解决这类问题 ，尤其是模拟实际生活的题，更是需要我们融会贯通。2 实现过程中有很多小的细节需要注意，例如窗口的滑动，触发一定的条件，左右指针不断的变化，导致结果随之变化，因此我们在实际手撕代码的过程中，经常出现bug。因此本文从算法分析，思路解析，再结合题目与代码去谈这个问题。。。废话不多说，进入正题。</p><h4 id="算法分"><a class="header-anchor" href="#算法分"></a>算法分</h4><p>滑动窗口大多数是用双指针求解，也有一些特殊的问题我们会结合一些特殊的数据结构，例如sorted_map（priority queue）或者的dequeue。对于此类特定的题型，我会在第二篇文章中讲述。本文主要讲述一般情况下的sliding window解决思路。</p><p>一般情况下的sliding window会给予我们一个特定数组或者字符串，让我们去找到满足一定条件的子数组或子字符串。比如：<br>找到最短字符串包含特定字符（有重复，无重复）<br>最长的子数组或字符串最多含有k个字符<br>最长的子数组或字符串只含有k个字符<br>一个特定的字符串在长字符串中出现的位置<br>……….</p><p>此类型题的大概时间复杂度为o(n)，需要遍历一次长字符串, 空间复杂度大多为常熟级别，近似于int[128]。之所以称为sliding window是由于，我们分别用快慢两个指针一前一后夹着字符串遍历，类似于一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。</p><h4 id="解题思路"><a class="header-anchor" href="#解题思路"></a>解题思路</h4><p>这类型题的整体思路是设置两个快慢指针。快指针从左向右移动，目的是在每个快指针停留的位置，触发一定的条件，然后慢指针再随之移动，当其满足某种条件后，快指针再移动，周而复始，直到字符串遍历完毕，退出循环。<br>因此重点就在于，什么时候移动窗口，什么时候窗口保持不变。下面我写一个伪代码模版，给大家参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">sildingwindow</span><span class="params">(String [] strs. .. )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理边界条件  参数判断</span></span><br><span class="line">If( condition )</span><br><span class="line"> <span class="keyword">return</span> </span><br><span class="line"><span class="comment">//初始化变量</span></span><br><span class="line"><span class="comment">//left 代表窗口左边， 慢指针</span></span><br><span class="line"><span class="comment">//count 计数，用于判断何时触发条件</span></span><br><span class="line"><span class="comment">//result 记录结果</span></span><br><span class="line">Int left = <span class="number">0</span>, count = <span class="number">0</span> ,result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//申请一个hash数组, 也可用其他数据结构比如hashmap</span></span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> hash[<span class="number">128</span>]</span><br><span class="line"><span class="comment">//遍历数组，right代表窗口右侧，快指针</span></span><br><span class="line">For(<span class="keyword">int</span> right = <span class="number">0</span>; right&lt;strs.length;right++)&#123;</span><br><span class="line"><span class="comment">//每次移动一个格子后，更新hash</span></span><br><span class="line">Hash[strs[right]]++;</span><br><span class="line"><span class="comment">//更具窗口变更来改变条件</span></span><br><span class="line">If(Hash[strs[right]] = ..)</span><br><span class="line">&#123;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前条件不满足，移动左指针直至条件满足为止 </span></span><br><span class="line"><span class="keyword">while</span> (count &gt; ..) </span><br><span class="line">&#123; </span><br><span class="line">  …</span><br><span class="line">   <span class="keyword">if</span> (…)</span><br><span class="line">  &#123; </span><br><span class="line">​     count—; </span><br><span class="line">   &#125; </span><br><span class="line">   hash[A[l]]++;</span><br><span class="line">​    left++; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//条件根据具体题目要求确定返回结果</span></span><br><span class="line">res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典例题"><a class="header-anchor" href="#经典例题"></a>经典例题</h4><p>leetcode 3 Longest Substring Without Repeating Characters<br>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><strong>Example 3:</strong><br><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is “wke”, with the length of 3.<br>​       Note that the answer must be a <strong>substring</strong>, “pwke” is a <em>subsequence</em> and not a substring.<br>题目很通俗易懂，给一个字符串，让我找到一个最长子字符串，要求其不包含重复元素。<br>解题思路：第一次看到这个题我们，会很快想到brute force解法，两个for循环遍历字符串，外层循环代表其实位置，内层循环代表终止位置，写一个函数判断字符串是否含有重复元素。为了对比出sliding window优势，我也写了此方法做对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = s.length(); </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (allUnique(s, i, j))</span><br><span class="line">ans = Math.max(ans, j - i); </span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">Character ch = s.charAt(i); </span><br><span class="line"><span class="keyword">if</span> (set.contains(ch))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">set.add(ch); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法时间复杂度为O(n^3) 三次遍历<br>但是如果我们要使用sliding window来解决此问题。我们不需要用n^2的时间复杂度去遍历字符串，假如我们已经验证从i - j不存在重复字符，那么我们可以把慢指针指向j，而不需要再从新遍历 i - j。然后通过对比result与快慢指针中间字符串的长度来得到最后结果。<br>以下，为代码示例，通常情况下提到检验重复，我们大多数会用到set。所以，我先写了一个set的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">​    <span class="keyword">int</span> n = s.length(); </span><br><span class="line">​    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">​    <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">​    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">​      <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">​      <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">​        set.add(s.charAt(j++)); </span><br><span class="line">​        ans = Math.max(ans, j - i); </span><br><span class="line">​      &#125;</span><br><span class="line">​      <span class="keyword">else</span> &#123;</span><br><span class="line">​        set.remove(s.charAt(i++)); </span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此解法可以，但是其最坏时间复杂度为2n，就是快慢指针分别都把字符串从头到尾访问一遍。类似于“aabbcc”<br>以下，为通用的sliding window 解法，我们可以引入hashmap，key代表访问字符，value代表字符出现次数。当hashmap中某一个key的值大于1，于是我们尝试移动慢指针，在map中, 把慢指针指向的值的频率减1。在这里有个小技巧，我们可以用一个128长度的int数组来表示，ASCII table 65-92 对应 a-z， 97 - 122 对应A - Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">hash[c[i]]++; </span><br><span class="line"><span class="keyword">while</span> (hash[c[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">hash[c[left]]--; </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">char</span>[] c = s.toCharArray(); </span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">map.put(c[i], map.getOrDefault(c[i], <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (map.get(c[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">map.put(c[left], map.get(c[left]) - <span class="number">1</span>); </span><br><span class="line">left++; </span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, i - left + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="header-anchor" href="#总结"></a>总结</h4><p>之后我会陆续在写两篇关于sliding window的文章，列出所有我见过的有意思并且具有代表性的题，归类讲解。当然我不是大神，所以如果文章或者算法上哪里有问题还请各位轻喷多指点！！！<br>示例代码为了便于大家理解，我都写的java，当然我会把c++和python版本的代码放到我的github上。算法题主要是思路，所以语言上基本都是互通，如果大家有需要与其他的语言，Csharp, javascript…私信我，非常乐意把大家debug。</p><p>放上我自己的github：<a href="https://github.com/wuhewuhe/AlgorithmeSource" target="_blank" rel="noopener">https://github.com/wuhewuhe/AlgorithmeSource</a></p><h3 id="关注公众号-每周会有更多精彩的更新"><a class="header-anchor" href="#关注公众号-每周会有更多精彩的更新"></a>关注公众号 每周会有更多精彩的更新</h3><p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzI5MTM4Njk1NQ==&amp;mid=100000078&amp;idx=1&amp;sn=c183b7cc5016e9f34330020a8e3b110a&amp;send_time=1577568956" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
